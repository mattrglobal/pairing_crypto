use super::{
    create_generators_helper,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURES,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::bls12_381::{
            Message,
            ProofMessage,
            PublicKey,
            SecretKey,
            Signature,
        },
        core::{
            generator::Generators,
            proof::Proof,
            types::{Challenge, FiatShamirProof},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use core::convert::TryFrom;
use ff::Field;
use group::{Curve, Group};
use hashbrown::{HashMap, HashSet};
use rand::{prelude::SliceRandom, thread_rng};
use rand_core::OsRng;

pub(crate) mod test_helper {
    use super::*;
    use hashbrown::HashMap;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &HashSet<usize>,
    ) -> (Vec<ProofMessage>, HashMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: HashMap<usize, Message> = HashMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    pub(crate) fn proof_gen<T, R>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &Generators,
        messages: &Vec<Message>,
        revealed_indices: &HashSet<usize>,
        mut rng: R,
        failure_debug_message: &str,
    ) -> (Proof, HashMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng(
            pk,
            signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
            &mut rng,
        )
        .expect(&format!(
            "proof generation failed - {failure_debug_message}"
        ));

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let mut proof = Proof::default();
    proof.m_hat_list = vec![
        FiatShamirProof(Scalar::zero()),
        FiatShamirProof(Scalar::one()),
    ];

    assert_eq!(format!("{:?}", proof), "Proof { A_prime: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, D: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), e_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r3_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), s_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A': 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, D: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), e^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r3^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), s^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(&bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        &messages,
    )
    .expect("signing failed");
    assert_eq!(
        signature
            .verify(&key_pair.public_key, header, &generators, &messages)
            .expect("verification failed"),
        true
    );

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        &mut OsRng,
        "proof gen failed",
    );
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("proof verification failed"),
        true
    );

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert_eq!(
        proof_deserialized
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("roundtrip deserialized proof verification failed"),
        true
    );
}

#[test]
fn gen_verify_different_key_pairs() {
    use rand::SeedableRng;
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["afcdfcce59bef91fb6b16b3175d8a7854700d03499a8a7dbeb3ef81a076697c61be26252cca76afb14205509c856acaab80bd4bbcf992fe4e1c4de146168c758bb6b1dfd297973cbddf8ddb8965f2df1e925b73186e278b0019d683285546491aa9af5c2c97794449910a77af5f59d90be25c7d3e3dca41929a2e98f4405639beea78f50c3a3f67c68ad526a192cfed23b380198bc67d3439b918b88f6478e55935238921339a30daacba99740b20df56854149432a13320cc5769938456a5fd8756d38cc3614e1e4180b25a31f831123a5d7a7eec0a0674e6af91d74a1d25bc85529852ca05d65f0ccf08e195edfaa2363635139fbcae2706751f62479f01994b410c19549396785ff183f2b585a2980fa32d69637fee4e2a0fd77d2c894f752493d71336a0e8473cdc0d04583869a74657e87c2a6cfced606073d030ba396ee59983951f0c3066b7afc723b48fd0cc4f8ab752a9d123e57d4ca57cdf2a6c070bf2cbc8b72ac709a6f1de9f3c95f5101177f53a8e0ca005e5946a32a4843d47c7356f27ba2e3f3668c8d79669f408ff5b4897551350763a842f9a343530b04405eddb39a31462e810fc96bfeaa3dbc62002613006720c740eb7274262b09f651a1261fc24ee2c22dcd1e7ec75d77dfb269f7e885ba9b0db3c33f275a4a4357ca823473c5298f389482f271a14f51e26", "8d45cd4cb0a568361b0f22b241c8e3ca35808f2ae978986483bf5fcbbc2acf48b2bd53dc35bad8af352245e3004df56592fc92284dbe690326914005d6af48154652fd898fa65215ac4fc1ef5dea73ef34f60d5f2c8deae0c3320f8590453d25b1c2184472983caf20fe7e0653352fe5925dec9fd22f3316ebe2316ceaf6233848e0bd6f531a10312ded602633b24e6929b9e712719d8d0389e6af8522b1d53739b37b12eb9a5f43d1f6684102293e1965680f587a82fffe3c946e51809cdd189cd98f8a49bfa48b040e62839555c300143a9d57b9c12e085a66203abab274ff68b2cfcd00ddc6126cdf6ea62d86f73a27bbcd2b64c03fc398a2c903dc6328059660e893368eaf86e68b3432a629b9284788dedf85389c88e24f356c870be192e6e951fd4db870394ff5bb9da8d5c7b116ce57fb902390c8a87b95d78f17281ee046a1028ed73c4002caed880b65e65f02b1e60ef1c3c6788669c99daa89f92fb393d6530d068e81e4d6b3af030d7f131ca1f27a9153e8fbd0177e2715dc07c37bd64ae8606992669166a5879bfa4815189ded2201f833c2f89de199c7ce05175120cffa497718a8c8bb3453b28262cb5309b4fb4a2ae021bf00ed502ee1b80af233a5bdfe8bf3814b9f70546431bcbf", "86cb99e5174e61be21dd377484608c84964a73a8ac37d00eb186c7084da019a4d95dff70e3e8c8c6c007657aa8d39eb7ac822bceb468ae75409ffaf0a407454652f4a794ec464453e0f0789cc0a69040268d292b14a7ba30dcbd5b05b67eadf58579be33e3fa70d19a167eaf52fe586b6ec85b1d90687da82b98a2ee69e6e82f774235513ac635526cdcaa63eb9a8431459845e8f89a77a87747c99eaa1ab705d7b615e43a8fe8a7f0ac4c9dd6e50bbb0dbe51cb5539ce0e7ff44b7191701a9354f4c553fd02972ba39bbf7f786f64b56b0d3acfd61c268499275080ac933a81db09e7017c4a5c2bc84ab740ed0d8929376b6238753313d78646440e5985381f3c06043df65361f91a30dfa66e25efc64c55571fcc97d82888e24ab6e80c516cfa0b04c43dbe191a66e426ae0c5ec10b578adf44303dcf9efd85d7727a21e07751e9f853b147aba40dba3e7229fbdddb3e5cc22598d42f49baa18aa42d266889fa81434c7da9011a87cb5839de03c6254e383269e74a1558ce3641f49918b6c8ef18eef8f3e87b5b95bd4f7b7340f0fb549c16bd5fbefa9cc807ea7d1fe91b9266cd43f9a65e7fe21eb7a1342a97d5ad", "b305a3543d6e576e81a2138033c7dd47aa26e0577cd1e897cd175b172aca26d4f2f9f28f2978971c5d8120ac67b346ffb1c2c12331f0c0744e63c965c0cfa21f2d63f6acf4c5feb274b5040943e5ef743a63a6e51c0ebf40268c757bb0e1d44696bd051aff4bfd5f9a0f3e19fbf96edd930f6fe5f7c00631d8bf16529a7e43e37e0efe7af8d8c1fee1d82751212f1386551530e5550c42d408d507a2c948987bd69c1e61bede3a8a4ab22e79b0ebc5e25a3040080669c2b069d0a1a25321079aeafea79d05f0c75f5b6606128c8665c320586bf85dca9134030da2dfb93345302edfa5780ccc1827ac33d2883bb367e63cff95070ddf5a55718ab14708b14327d5c9cf48cc4e37893e03424649c818d14d0c750b0c031382e2fcab2b391fe53ee89d9e0ac8dfbcca22a0c7889fcd23f006ae2198de108beee814bef24ad14310b3a43a2fcfe8fa44833663e8871463e127942a4e8892a820a878261fc9a029a4d7836439c90374566a50815e515a37a421d47c445841097c0e786d8128de405ae7994892fb4a736909f6d4a8a6ce062e", "873fea54abde813a38c97c070b6735b6afe91c62058e2c9a37fd77c15324bb52cc40499cb7a4db780d1534c60c328f06b16568c33c0c93d452769b0f92675a5f315609f306ee5330b40c4aa16841935db4a87f6ebc1714d0d4956863517a1161ad3487a70330a5e9645b370f66ee30cf615fc0971aec6a22bff93f7e5194e2891d5edd2fad07fe35ee3df9dd8d0d8e335d545808b5e2ef09ef7116898945d9ba268419eb937e84750a23e81705912fc863373ad4223929fb5c97cdd006e1bd702ef6a2a94b539dc80732cb25d93019e610c17e36625e31f16a3b1058a903b71750588fe1362451f422b42a6bc5ae43960263d150be76e78fe15bb40c662dfb95dc20153bd43390ffb3e741de342338001a80f298d943a2287f7313dd99b872e0cef6e42233f29be1673683d2ab00a45256699a9efd63df3bf4f3e4c646c530436d8af9ab7ef31fce4100b187fa5a2f9c0fdba40f76afed5166fc4b97e1ad4f7683911c270fda598cb27fb5cbce07eec8", "87f9c6026a5e4e6929f20208b4df6cd3465c928433390f1a5cbd33e7bd52471291f4f4af9fdb78aa4c3dfa028184452997ae605c117a7f2a751e739792065b8fccccbf2e75fb412120aca94e5391ffb7a73eae9ec26107af5bc9e72ab8d24a278df918c0bbbde130b052575acb850233d8bfeee187fba26ef67d004d21db6ee2778e0922551eae8ac3c1e0e08c0078bd4c04ccd938038317e45cb1e0132811eb4d7167feb01e7992d8ce920e1489d14814a6398260b0f953781fe138c2cdea55a204252ad5d67e141640e37d17324af16a34e5719ad907f39d15f23d3aa93112df66d5c32bf7499c9e5655b1494407a500c89c552e75ce2af122f72f3fa86c4d7e6d5c708bc4ea68413338a243459bf73ef219e1625dbd7b13b022da85b53f2cfd9372ffaf5547c1c823897513e424a56a88df58603f6b8a7136625598405ab061768bff5e97efb78c1b4b5f5a42e6b9"],
        ["b380236b5db43bd8c67d59adaef544fad55cb4500efeea59a580fd09bfead209bbcb2ecca8d613e143a716c060da45008d4517c1bbe9453ad7c319a2607859162f71804d0526bdaa6ec2ff041e12535152b01757f6a249d3074e8c947fb8e7a48fe115fed1ebdee56ebdcbce1860c4d273382d223879ac30e19d08ac4eab7080036593de7fec0a3b2d771d7527d81dd81329aebde3f8b9321c1ef4c4610a0e74ccd5d80737067d67fda499a12346644d083a9fbc4e786e5b0b88eb527a6fd14e4b935937ed93ede77635d113745fc67b3c59cc2f0f5c3e16b9d34749dc4cf7f9c688b34e051e47713cb90ee6e108a1343423231651f1878c808f768666eb53ac879dee0508e7d0388dff57c42ee2990a4baaf3c66dac32091f9c5390453948dcd1af58fc983075d5d97e9ab9f9894f2531d23b0a5ab29b2bc2ed31653afb55fbcf9f1d71c97f8a4aa28e75f3394e3c9f0ca540be3b2a918a9c7aba58e0162bf622fa7fac29da5bedd4adc3a1fc59d25802f2ed6212741a7c0b333bc6bdea18a42f084a5d9a1acabb0cf42d3d52f642624c6ca7d6056dad19495bd7e8216006ea18e8e4bb9d54f6c31c30d1ceebbc0ade245d9740566bcd3f20634a284d5cd9aa9fe4298e834450c3aa569ab584080823516273c8b01e4078540d1b797557ce221f7099a052998800f252b48eecfdf68e", "b53f8a3d0a33a5349ca475cfb5df1e4fd2333219ca04fdc1e05a506d2aaa12deb4d788ef7a7dc9a3740401a127a079f9b878e1ba3aa7d2afebf1fdebb80c818ba28bc4938cf1d339afaefa09e9e74cb672aee0959416dd03fde8d859c2223509b8852d393a3744cf5b29731b1aa36b6924ad91217b6b32e95614dbb2911a2c6fc42444bf519791efb58d5d91aab73ced5b7d4c431c0381dec878b533afe41211b4cf64099f5d2dffbd43b841a9a1ab275188da72d8456c6bee5ec223def4ec6ce5025e70df9f050e45d360803a4765b85235992debda88206cf574e4fbb90d2da1ea293ceafb610b58b19e560161fe377221e070317e42778ec33e6b1147a8175cbf2165557820c6e62408613b53e31d4fbef1ec975d022e82fcd93b06b73310e29ca1f1e295d87cc473d1074009d5b054aa75828479cde5cfcc2189e510f682895359540ca6d3660576c3f7c88e46a96622637ea2d9fb0b776326f545bfee2e3edad8ab3838f06492e9ab8dff3d0c05722d0018e6905818836e56ab5a18d80ac7df305666be270b319c73a78dd7f7db3cdf77673ca899060ffab875c2a78104d0b8304818f0df819d9fa3c9b8e1c83a52ec13b24567d63038799eb4ef4058b81ea827a195a5b9f0ad97138b6c7308be", "961d25508956749ce41973ea7cbb4295c9491c43a8794d7ed71fab32217daa61755329da247f396bb52b9cd17d5c12c68002f2544dce431ae9ac78f0da470af89bafb27c63abc3d61d194c2c62b3d0777936dce35f6a5a4467dbc78a5ac8c13ab23581d40513b3d35d7e6888456982e416d8dc1715dc50564f299f226369d4c4783cea81261c521e0b9fc59f3abd44cb4571cf3ca107c0c350a30c8fb784adb56db5027b9b07b822dcfde68d2ebdc0ad6bfaedc733ccbdb7d3335ea0eff390221deec4756428309c649848305be7659f1a87e6d83014c0534e301f5fc8e4e44ee8048494f4abc2917198be9c236fc466115e6369bcafb2821385f005c4c3361fd13911eed432f8604bfab57695d9975c3b95272ce5766d819cfbd82e67ee9f54d1e11a208cbdac976fc36626b2a83944263a8d9120564a8ae1fad3536af5ee180ec82735fbc97c3335c370d1e354c10657fd117db39da278ef20ae44b149c02a2b7d28dc2898cbf4eb182cd22e04c5b14d1a280bce161060fbeefc16292ba1d432c037602c8f399b7c462daff473bebe2503ece3b962c0069ce84077778097d8ba7fb8f75d137732e549736e96988a41", "abddd7438df67b410c50d09a1deac45dce9803e7126a278e6b4a1e523c429832fa443bf5b0c14ebb63b9cdc97961ce8ca47f2e675e2f8d2b861c2e26b6873fe9b7e6bdfbc88e68fa28483c08ab813cdb1bc9aa0b6c1277d8cc46d95f68415e7980c581f2dde25c1a365163868c44fd7fecd78bab5e096eed051a070dd72d74df5450be3f41da3547a6dd170281f7cf7263d652fd8a9877fa9e4fced8b739c9601f8479abb19ef91b1ad88eaa7b991113359cbd40ff3d10c2c17ec36b098dc1c0485f0ba7cb8725fb91b9f2efbfa2037115aec9548f847a46230425e0caf497a55c8fdd3c55491c25eb7111d0f51041434a306f8fb49c90f1f5ff7ebe6713856ebe229d4369f881da83048c68e28d7a6a67953b185327583e65e6a868f0a943735c27dbaae45d138bf01585e962af0d9057987ba5ec33ce4af58e27fb9e553034ff08258f740258a3fe549ec8722cbbde3ab6fc51fe819d86a4f2c5b4262b3621df97339c01057d1887ba4165c9e762b768193bda767d8f0c46fa01142d6e84efb5896575c60409ee5200eb99384cd7c7", "94853156ca1e7e60295a211ffc833a4038cc8cf11a4f71e40fa736489e95c4387d76b75f8ad131eeef7ab2ed91014efd8f537708464dc2642ed126189184be44e652c7e5f262abf2402ac1e604b8fc9e6dc79f0da2cf747c3db6592ae07d9be49004c577bb382fd76bc8e2e2a377f4a183b941e99b919882faaba738e3acf749ad13683b1dea150f4145503d591e56aa12f0bee13b5357c132c03d5e9f8e38e1d7d8f45fce052c47d212873b9a9689bd4d146568e401595ef8eeb4aa2626a19fb883eaf76c08c56319a8653f103a4d540782787fcf80c354f2d43cd2b14b38700ff3a99790c84d252f0e51e89007394a3d7d2ddfa78adad8bca80935f24c74178d6429470f0456f5e2f45cf0e256e60b65093ecaf8b480ecb49dd4590e008c9a67ba25d5b932ce1dffea8d73ff71fa3108e6e57eee9304931b4f1b00c4246462eaaabf871042ef88b806a30637c9bf941c67644aebc6b9fdc77e245dc0b6f178950c62145d7260c7b245eeadf157b2fd", "81d9b3aa2967ed8f69226f2a9bd8b10afab91c66d7732d202a778f4f4f73fe05704ff2f3d9caa98e20f631bcc582ed218b88a51f3c68540f184d1b70c71e517f8e7922524e53cf9d270b60924a523f17b4ce04ef084017befcde736371fe224ab1d96e7916f8daf2ab9adfb8115b8b16eb8f63c6d9a1dee95d3131dc8bf5f27a343c7c5d1cb984a9e3d6063f7c719a515ffa7e810cb6c2526610e5779646fd7d5b1fb7edd6aafceaa500febc1bde80f82a2afeec05ecebc2869d27578f4142f85d56b3465cdcc3307ef8220bda73a4f6715d0d2f051745d1c48e51510da0453f526b919c5cc445e483e3779b940817ce24d9c30ce37c2f5cc780c8e39682c2d8a76084da8911734d07c2d23723bed7471071e9f10fc6ecbe3eed5ed06c30063f9ed83517148fcd7e7dcc6d8ea70ded7159555633d9c2a1908a1ebff5401c362d7ceba32550476aeef3de4d16aa4c0b12"],
        ["a0d57dcb01d53c258a5e708049b5eefbf8b9f3033c71fc356622d355b3c10d0959fa417bc76ee1e72e1e07dec95fdb61b6df7227d210376d9f1fa28ce9753255b6205456277c60566807e1bc90a0f64de6caea092fe7cb75c7a7740830ab345ab79bb3d27630a24069d67a8d809ca9c57f4e1c71c7895e91b591ffa93d63ef55a8aa33b8d801c632e047d5943bd471d7603b9ca1aaba786df4e91eebfaad197f50c303d0898a301310dfbf7325064d344c0f3111c152e332e53d9087e8580dc26f82d0686b09700acc219d6b4a69b6924f1e998fe5b7eeb9e48c75ecb64b555d69b3731c59a7b1e39b5a598ca684d7ab1aca7333e05f984339f8da8dce96ed760a253009296e6c2de91295a6549009b533a844417123bb521e6a60db2afad0c9ac9f4d1ae9ad2b627423b4fea678e9601dbc4cad1a835b68e918d1c1610e21c8ddf59dc912b566235f9b5abcd34d8ecb32a25596be0d5ec26384ebb51b3cb21c6c694125e1fed72714e58606d5eec49e3760ed598dbd760b98ebc64110da7394afb52f0f5f93ff19c660b02fd8e6932d72db750d665ba804f400aa3e4bb2f62ca3c8e055ac082cf75ab03479bd03f0d9464fdc77f62a4a8fa0c1e85e1df49d88db5f40cb15924a61e8e4006229ae9b7925c3e634d83a45f49efe7f1396894b83189580e2b808c2223e9b80444e410e43", "827687ad8c4eb341db3b9132a0f9fbde3b50b0552bd75a769100bc0e975ce05ae134da1c57dcf75517fa3d8b8362b182b7bbd13ea85f4a90284caa26afc2c63ac8cb7f2c713148aef28c97bc5d56b95936b52f07846ceefc58d552f2502a458e90931d448aed173839d7e09f7a8fa681ab5b3e91dafb40ee9ec58ef25dc50b6bc3413cb3998e245dfdbb45bddbd2fd20418013713140e69a8752578e79bfe83fb79ea0557069f812a983528169bd75d04791fafb1248395c4b30ec9415712faf12163de71f0afb4ae3d70fb4bb8c21a75ff6b1aad3508e729fb6a14a6fb3a1b466334abdf956eb400887eae7758f24bc144ebf9efdf72c957f190967e8c493d3944a533b445b52d7b7874dd46bf4ae041081f51a56c0dd4c3a3c9583139f28124e17b9662727526c6267ff41e9b35add2c820bbf0f6be7e3a970cb021725cf089f9ec5989ba26fa6f666e6547070801365fefd96cf78d64dd3ed96976c670e33f93602039d223f984e079c8994e6f9a6356f08d0faed9fcaaa2f7a671e68e48c575d1b903fb5fb164441ba34a83202422920526649a90ac345fa5c780d2966c94b3eb7eea81cdbc285699df01b27b68306cb90489020ea3e760e0dc0ffeee06d52559d40d6d57113b7572951920a0f9e", "a67626c5d6a6e414260f3869dec403d4c1dc9c84cf3a2fd4e9c1642d4a7d3ad4b7f22632196a9f70624153a088eea2618cd90a88730c889a2a3d9c0b1b0fe22090fd0ee64d42122dfe6250ab80e04a43b73ad0fd47d820dfe9c115a30082c1118b2c5f00bc31e207c7356788efaad926ad20645f67566b8305717341d3a7332c4f2ba12437343727447cb16f048d749a64ba98406c47c4491935a4dd6a1ccdd2115966ac886cf57179064a2c61a2727c2c304a0dd13787f6a322f0d6ae63301f936f03a987ce0a5a2a853d3a61f201f523c38c8cebb5aaa6fe1e2788994260a3341c7b43fe69868397fafa23328560c06af129ee8afbc9ebf634388e31681b9a46be7067788ed614c2afd6f440b4a2bd46a15b7c757fb28edd4dba914b5f509b594ebdd8c65993870f0886345144b6b95fe5c039e956a9fb107c8a2f5fab2320b44125503b86272ff023a120d83f88a75589fb61ce638851b2732f60af5895bb65d1beaa8f0e062fbf14c03b9254735137c305d5f4c046fe8184438435e5bf26c2608a5f52f69ce795b6109bc3b562ed317782efcff803af2e278df921f0bd15178f4f08d7a23d891c43f5e964b21e6b", "a8d966e1b3187dc2c552fbd16dfb247a49eff35a4fceefee1796e2ad8192e3016043399e113ad0db001390d2201a017d8d8dc6cd1c4a7701c3ce19cd9e5dfcd8e7c491398ef29cc87a07048c744727c06342951a5c2094fea94982326908c9af9186a2c85cdc5f8bc87e75a4c17d73f034d42057887b2f0667d25308168e5a3535be0471a6bcc0315fdc6e47996f7e42487a8f27e65e4c9333087c4bd83b5909fc857b9bfb6f3999412e34d25fcd945600803e370e065e6a83b3ed874a48ba5ea094c56a29605f2906d7976186757c872c3852e2d7abf95a13a3d39919c158e943b12dec961df079f30b453c25ae2a98608f3770ec5014189fe83eb1f24657afd6396ebdd35d3772b67d3dbb49e2dad45dd989745e5d1f6e778d85826597026bc8a9b796c2e8f317b73b86839d2daf16430f38ae8f344afce702b1268b05bfd5ee5d83515c10ed0d4d563705b0ee6702676601b94254d06ed88827904efb9f8a680514c19a2198027aed3af17657100a6e2ad4bf5d5d33da1ed272eb0ec0c2ae21a3cda3f4f8e358eb1277cd4ba2e54d", "81681f8d2275d105bb4fa7c4f2463f436ff976135a555d154d514f751129d6076e73c0e401851530d419118465cfb0948893c4ea4d0bdd5b8b99cf811d88a578b487315765a0aba94f246e5c528790cd465ee6e35e5dd766e6cadbca389d1c9082ad770d7c75be63bbafe12e37d8543240d15c601e9f7f343cf2f9e4692abd5d6ced0ba24d65c2a247c57171c13b3738299131d7ae5b7f2401e1c511fef391e62b36a2b3739aa16e386b21da13b0daf92ba5a0342b5e07a3138f9ed3af5f9552402fb1c577a44ecd70492d5c88440e1d6a18771b2aef4ab2c3a3a594a9239638f6e2795d62661a568a3251e008a7d35e5e5f3605bc82237e94b4466d425ef21cab272e50e5e147b92675ff976af724a47315f095b34fde1fb5dcf65ba8d9a06453cdf6119be208407434c375907711a83ef5adbc21c9a5e1b935492e585f2eeb2dd4197fa4af531ef3071de3afd723a66c1df092a685fd7770dd30b85fed62d54702f4d6a6b3f4f13cd1ebd95ed2b267", "961137cb999e3d61fddcd9b7c2c3d42f46d68376054ee8c0e705b2c267359c8cc55d187e34ab41af2069be3e154cda658aaafad60ac2dc931aaf4f8c9eb84a3608444fed28dc5805f81c4dcb7c96db56238ab4ad687ee1f487d49753dc4944bfa5872cb392d9adfbb7e354a308c9b511e6cb58fe3a4da504626dd93050ed0af384197616e6d496b0ff5db29b5058c9465d03c90d12581469c6e56a795ad488e27efc00b22d79e12362246f75a81ff3ae6ab5202b4d5040346961b577bd0ae2c1378754091f20b1b59f41e1115763e7d4508c606ef196fefbaafbfb407ae4366885b6a3a4749c76506a31cb302167070f239327aa0e330dc0662ac25321e565281e05bbe2b0b5552046601a10fc6b68ee5d7f184d69684f0c3a09a032d098d30da968d717ae0a07f2e063ee7794a0fbb24d8ae1da47653d01021f66a2b3d2768e69bbdc5247d80be888014e8030cc164e"],
        ["84c850cc4a5646ad49f52cebf574dd4b24a480e27231b9d84aaee784039385cafe563d6cd9a56d5c2f116a308d21d0b0ae14baef6f92b9634e75dadadf7f0433d2c967826af7351d05ab38bdf54c092957214141cb85a5ab9546c5b789158367845f66b4b5d12f43754dc3c336fef921cb680c08c230201be52c57b16c4a8894e7f3dcf61690e825d234f442fe68d69a6b3b4643c997f29ada58b97b4671c6db8cc928a426b6a708028e2b25da2481fb45b7c6a3acbbc03dd95865e711d5ecab67cef20654e2efd4055f898d2b04b80037b861bb2cfc522efa62b81aeba1cbec4ae5f65ef3a4f1b978829d39c9994e0c5ac1b188276c3f951f2051a335da721f7fff8696a4e098a91d74ac0143d6c70005a85b36149d7c272093d040fff4cc9ae4922d9eef32b0b6e7a0afefab6dedf66f104ce5e33e24fcfb5dbd9730f5c73688dfcf6851b08d254c3bd2ba8d6766bd31f41c82947c2f79aa9d3aa6aaa476efbc3091b92e2f70f5de8c0b42880a0e436c0fc5125f07c7717b70bfeca6007aedbe79b2744780b1d0089bc612408ea7cd3e8cc9a4eb1cb210a2e04c71d82ee61e70876dac39d793ea4cd843b725f332bb54a5fb7df5b6fda50e04e423e70db02ded838101fe2019d6f711e503b9e53cff4e124f17cbc23a46d1c4112ab1c0125982c19cd9c7a2fb3809ebdea03bc748e7", "b8b38c6feae4b82d97325a1c5bee703376f185e60d960554d161dda2aa8007169d4e3cf23dae5010659822afcd3d7ef6afa33b02e7ca15470d4b16346fb50046dc48e8f597d778b6aeb3e33329661b887adcc74abae93cab9de87700542e4a628395dca05f5673380342a2799021c6a5da8240773ab54b95906cfd93898c1d00b159b1c6c64f1b7a978617c4498c69195e1b45285cd4ff7bf2b6a64085fd6879cef402f776b60f4dddb1d89e4e9c1eff6fad681821996d07a78073a5fe396a1753094fe4d4baa3e2d99a12e850ed60e30a25f24f483d446e24e47dc406816b78fe9ddd8d9a08696a05ca4ba244a4dcbd1ecd4339610099971a7711c53d48afb8acbebf72885ff4bf3821a8c04fb9a60914fb47e49678a43f25063074b4a2fe33e51d6a8009b049dd95d761e7d3d63fc962a78d543c0552e6cf47c83dd2f48fc34fb61a2d2fc1faa59b0f0be0e7eef3033dc99d50a131316f2919281048dbad641add74aea88fb26c5521f9ae2c15b818699ab28229e297e066fb24c29533a1f03901c37907b9070d4c48b82ea4f1097251cb7817ecd047e9e9e0346129469a0b2693317d7a236e5448468779773831682bd4892a0a6649c0d445b480c9c4ad5edf50b2d2ddda85f6043b6fdcaa7ec08c", "8e15915e4dafad102c503e05477b040a14232ec307345f68cb7a7b5cde9110f9f2448f8c35214f33371bc1a434bb77dc88fb7cb21f9a03d5f7d92147dd62c994c2febd17acaa7ff7cf9691576a6fca49d0cf9096f366f11987d2bcc6408be7a5850fb4bf6324895dc3096e31bb6248fd3a65317099496978c8666c287283db5dd15597e572be865e92cd0a0c20467c7a615d958d0e485efb94cfb29b580effb06c93cc43382bcfe2b5b46a9347e1a2b74097edee6419c81fd57c3e3924b9d0ed37352e70758a5a8bf0d0e70bc9a727e455c2ef70573a0ea397e6efd410eeb1e88087572ad7ab36867c7b9ddfd305bff85a56243a602052a717915b3d8dc3a7fff2bef68093d69c6f8c5d0f2960ee57595dd1e2b3b2034182667b09a645ed0dbfa39e6cf7664f7dba7452ce3b7d79ab0f3971ad70670881df4a74995e37db347d00c2da4b85296f8a12b0b7c0bc618dfb0c89a75ec835e7a562c57b924f71577ab26770a0b8444880df769e0aabce5058002602d6217699405572ad18a32c9dfd18f500d924d205f47d7a3cfe0b67ed07441d6f5499f1a3b4d555fc27dbaafac82d96f11a73f5881ede0b7387c029c66e", "a42eba8dfff601b9ddcbc2d8068c586e2b2b99838ef3ca6594626c3f2bd4eb5af08286ebd302d407cb6fdf1eb3db5f5aa9b803a43ec4b8741dd055cadd586f6ccaefc68063be885961f3812b1a3e645bcc5af114a144de7c179c977f968de95e94fe8bc8d9550370f170d3b48f9275e886bf0f0e82d1e46dbb6faf5bd0e36811642a20d0b325007c3cd7d8858078be1f18c8027479f590c730c76f3d4b847a6492939f3e1fd03d1263e5e8460c9e682f0b9f3b5c13fc339894a604deaf894937219fdb14d40f248cf44293dcf8d7431810baf682f1304317d1a59c7d99345bce7189dd7c38f6d5545e65e6cd8a7a728927eb317d7711d1d34beef08666e3cbec09a379d7525b320482439af8955c56f75e9f95872a1abf9212945e2991452b470eea366131517f5497e41faba90cd13529a51e34f87657eb5c8972e4678cfaebe5cfd557434ccc6b5007c175f46c7ec12857a7e6ae892a441699b70fa95cd77c7c3aa144ca7163023cf15fc6558a2ebf09e8ca9e26403b010e65602b9528a7e102c36f52b2c7105a4704ce2d4d6b5262", "83f6b7d002b1c9aa8697b03bee0ab2746c86c16a44af40fbdd5df3f896e967d33a543a12540db9596a88222888273c9b9948ea340c25d285ea74078f2bfe9b3168aae93f34beb38bbb7d519f855ee0041568aef6f905ab0e4a17ff9a88759d6ead68269eb15c841024d3007aa70b2a09a9e4f4867a16a1249e716aaaee6e6df9e31660df5f4b104146f695b18201d2f36cf59daab9bd0902355423f86f6bf74ec9fdaa498a89d2ac32f1e011887937531eb9d85f5886809ec3c42d43d6cfcec1773848f727fa63b643f168632a4e197a2807f88e27cbf820a4f7651c2bf6cfdbb498815152b085fcda0def456f6122b30f9cfe88ee195e09d3f8ea1d91fd8db20778dc451171f23dd8c48a0a09352f433f7b8208b23be636ab58a97687db0e4ac270f334a1b5b033b185d1a97542b2043f0e8f22718d927a6f298d1240b7147f78569a722a5e90a8d102292fee8b4e1b2ab19a54c95c1b1456645485b12226245adbde7d61c3b848b964caa20de70602", "aae28de2a1412f8c9ceca4c95ea51fac4c996cb8418d69cf12ba522dd1c757955d5ce6ac1da04492d9cadfba08ec4b9e818fc765d832a7782b04dc50a92632bfec27727d3c66cf834605e5bc508eac2815cd67564df9352df9922aac6411ebba98c47c239ca9b01d07fc21475def1ef16b4bba73e4a0f76088dc0073185e888285f0e055710ca9b82d2e5ac7f4567c07126bb56d34f9154e9c692135c16ec43112bc40db25fc16c70e7e65e832ec66312ea5c7f13bcf1f54f80ab7c2839005b980674bc05de00c72120d6617250ae1c22275b077dcbbe3d5d46eec7db098ccde41bff6f73ed76a9f59229455f1b595a32e4daaea215883b5068d0bcc24892e720993db6b4a7e434385caecccc6a9e4cc1c26dba34fcee5a1ee04883809ad86546a04ef52e87a8db7a5bc437f069e9866289edff0c3533327967e42b68334ac4a24dcbd3da9c6606f2977bbba1486aa24"],
        ["982bd254df6b4d34c43ce39f3e4441fe4bacaf1a2e5de792a873c50e1d910e9d4e0013f05d3321882ac5d44ea5c2e699ae32dde7772d96c92b30be1de5e8f4e314410760e8ccc49b9c671bbf615779e604a7f2887302d23042da4317265312e988df303cafef687e02720966158a33e660c08e4dd2afd529bec8d5ba48c906ea9a4c594b99bb11c69f389a5b6e7770e15fe234a4fc9a774b8504f90ba875def8e8e9d377b3f2cd2ddce9607652376b9318f5c1a4940f97b64068bdb4c3782bb8718c7f2b4ec86ad1d5ba450964d87f8841f7e0ec8730e3544a117e5f74b1484c0f4749e22cc4f9c52eec2ea13ad8ed6d0dffada9e4916a6a646040293007204a7b60335626840948263f29f17fe820532a6cec457d86096f1cd376f0cd74c161fc8ada87c9c48962371537c5f49e0a8e5645a91fd84783b6032f5945d33fa1680ec3b9ae17d8babe1e1e2d77e021bd606861b34c49060d994c9438fe1a3d1c5a1354136712f0006e70aeeb13af8f77371304921b5da5b80947457f3eef9ecadf41d83bdd17434deb9ed7428619d9fe254e4252af4d6feedb2ac46c7373510af8a8cd90daf77a228016db76c495d6935e176438672c1bb1b5bf17a5e82766d166f2dc70bef1cb99a8cb67c36a615024245025895e37cbf3cb2b625945ae80e9097343be3cdd52564d41fa81db88d4cd1d", "aedc5c59f89c08402b3609374d74af3854401c6750dabacbb6933e9b4330e475e0c77e3782063617791e2a2a9db95b21b578ee85f76610a78a190869d7b904769b5237b6fab528336987da6bd875129d2751971e33f14906f6d20dba1d0accdaa6c63ab8f3606fa49ab503abb0a2ef3b717eddaf37366de28c4723c6e07361d7baaac2ee2f46f777e8e05b6cfb5c53812497e557d95537610f688ffb6626b4cd5fc3df37c2542116e6b4ae6af423805c652bb03d470e7ea2906285bf3391d84c2557bc8bd4f90c5f9d91a900a9c10e4516dc9de7e1e300742ab31acae1755b28efbef302ddd94f62ac3416b7d55521d75d37a768ea2439e764e6c8f65b4ea12d808a28be2060fd616c915e32dae963301142b033cc7d1646c7bc4e7ec592d0811822d3cb60441a25e2a4b612ef77f2fe2001734b07a97819e3eb53d6ba2db5737cad5f32f47c84a053412dd145fb8c4352db29fc794926315a96253c5b3c2ffe73f1a8672d3eecbd11a4f5d073fe9d2e1c4d287f477caf31c25bc183faa1bbe463d57d040a19c3b21e99fa9fa35f762341233751bc715cdd12514d5dbca96212b5a458a3a9bedb3902b6a6495e91234a67658bd293c1435af54437fea829f6d65c870b2861b9d2c6303bf54be36b4af3", "8b3bc5aa955f54e0ce04c3c9dbf3b581b883288440c4583c8a45110d1746ee763f6c1fb7654b46e116081eadd6cd5f7795629d9228063f1c7009e5912b702b91ed2904d5f915f3a77bff920ee5e780322cc1f4c705006dc5d3426309c4ec4d2894b45918c8c550c2184e9c59c9c90d81dde12e4d740a9d19ca6387329d6827be68b35e98bc4ae3b787aa952972a9f4f424b1c63313b7fd25f94a35be2ef0b2062286a8d63187f9ff02ff63bc674a571341ed1e7ad6a448e03864f7e638db856520250a61fb2d99294db07aa928ef781804147e4d0020244110fd3f24b83f11a813ff3a285925f5587975f3aee152752509ddb24480acafee719eaca30b9de010754a124560d0c396cc9434e54e5544e0206f18fa82400a31d217a9bcdcaae633b500bf0a304c48491314a9df75000624658f96a4a1d06c8d6327fb8671b8477c600a2d9870629e0600b3ba30fd0195511c3e005fc2f26d66353fccda605e4d637d3b0e20588e4429c2122ddf4cc75e89542f84e197da0bb0c799d7c9a873ec5c6b1446c18cdb68de2f0a2c5a64617885458d53659d4000e3f0030ac36fa0e25435b4282a29b98fa267ab2ed347385ed5", "96d94340bb3007dce658a2294e4b7458e602606775db5e29063abbb920fa090b7e1b41b0b97bd753172177ebd0a9679bb2e55d0b100140fd97d9f687762b685c3239e90919671f06937f7b92421ad4ed5df513293d7805a27d069f1ea17c2639866e8a4169a2121bbd86a815063d27619bae238dd911da6f39f7635e84480b4f7da2e2ac4cfda0a2e442dd20b3c98bc834058abc7ee36860fc0c2286b0a6cdd2e87a56ea080e8ca8d7c559e39d351b851e0c9199d8cd4fc7ef6634006d7ff47c807aa8f1c95350e789f94325c15dee8c6f033fa3a096cdf7ff13693e329731aee4516d861fd9285738bf244a7c87f4c36e7ed1ab135d5f21530dfff3af3ab03376062d9893851ef9e160e2b05d81f6622babafecab274e15689be2ceb8a9377c9f243a06c30f1754c12973e10b93993f36acb758bc326f5f390b49b2ade1994b97010aaad91a27cf4f383ced43c7196a512f533a5d5804d3cc0662dd117a3f0b1a0c197c93e28d5d6e597bf402e9136d36d60edaff04a75c05461512136f44e2546d337a7308736ea60e9baa0bca3866", "b0217fcdf0d1444d3f0b117913fea8f5c1ff5f1413e0d68ddb426d4f3c47db92bdfeee78261e627e032aca311865be7396dec6800c28945005c038a1b4664ce40457564efb3aa0affff70f1ef8cf76a16593dcb5fd20af3bd795d9ee36d71a01b4d5c265258ff48c5271e90a7e3a32112058853789de6e1f8ac61f2d0224241874a194f47fcead1c62f7d2d3245d178c2a4c969bd96a7353f9334927aeb7d492a45b162c04595278223ed2b9f4e7500d335a3d946b5ce8a9fac452043e642063d361a00db0cbdbe58600ad301eb5fbed458b54ceb8ccd7b392cdf6ffdd81634da9b6fba9b63bc9fec19bb305567ee9a049f8fc50816d3f04893aa8a041411a7b4dadb0d0a4754a3ae0ac0ab9dc2926ad1c29919d2bee5fed3c5ffcaf5b2b242351df5fc0ed841ac0c5e5c3c4f30acfb50301d5014847062b77b778667fe12ef9890734f1554e429ab711d645bb4eddf327f1e3d66257b9543cd5539fadba69dbf1369d760e1e859578fa30ade0cec820", "85162d7f4ad1014a3a0f70d36b0f03ae56e02b22581b1ceffb8b388f7ae6b1e87ca3dad8b3612fa7f88ccb471f417cfc83d7f084c582d0aa5897e13f23ebcb681c6d5750d130312558b74bf2a3cdb00e1d9811b89150ae4f9269307b49bb27178e2fbc632a49d901f80dcc7e336d76c1609f77d87b5c111a3a77905f186a01080857227e043bedcd75600317f8a814aa033361b9b1d87389c170a367c1c0d8165f6618255d099d50a5e965bd1c48c6334f9472e076df70b39949b0d21663679f1348696100f8aad9d516b2e7c524c4d2640a7ea29dc1393cfc7c86a0c55d23d1dcd5f8bf60d788625f0a3769072a01ed36bf853743336286058e2ab0b4e5b482d79f752496eaa26142f5d1521ed2ed3524cca24960389a08af43fd70371111db4e0da008038331443f7743dc654e1dd656dc30e5f74745785b20fc8f4930ee27c9f4740b2504b5fa2eef27a595076455"],
        ["ac52db737cb62307d046bcce920d3046884ae1b43810c510dc1ff59c8a4a735744aa75ebcbcac4fec36dd6bd5a2748d98f6e2dc520d00a1250b0770cc9a1bebe5730941c531c440b23f23e652c49d9c56c86dc78bc378aa2180c75d20948ce76916d0c1862ae6078a1469205a842b08bec617f92b321d2ea0ad7446c80995092c681584ddce8728a2f298a3730eceff2566e7aad520dc93e1c56a2e1bc2fb8c1b2a031a07186980d3544839d9ec6f93e62680161b3326b874cd7b1433a93dc673261e5c9dfe6aab786f9eace7c8ad28b19925d513c69069221cc6730ca475199b3a5e2303c4e447efc498e8893071c1f030b1c3c6f6ac365b27a52050bd5ee4e1681ddbdaef57d3755a182065bd5c11036d24eec226aa71544fff95b2f8c8f18137e7b3fa5a0473422d96dc5c0e2c25b04865d16426c01504ebac85ffe9dc00b2430a0ce188a37c29c9de1369d8661f95351149fbae1363d2d43e822103c3bc163e6aa9ae1c7502fd869c9f2ef16e8604dab33c627cc021a0572bac801abb0c3e1e808806ee86fe79f702c0f4bbdd7f47015df45220ee5eaac4d7a8bfc7dba25a814e375a359a1ef73fde8eee5134e5654b117a7672e4c2725c95c382aeb76bf4e3bd22c28c16f4ff35ff0bf0bfa269b27f5c0bc02f97c1c12154b97f16004f18cc69c6701063395028f93da19e6aed3", "867bf7b5141f0d4cb8149fd64388bcde4ec2e2904d6e8e99c8193725e8705714991d98960e016c783cdc19abe8eb5f71aafde7ea7d7911aebe375127d48b851e77baa722e86c5a995d8ac374976b8810bb8c547e57fbc1e1af3d8b4517e7e7e7a2e51a553ee133f198bb9b7b13269a6d2fca1674a677bc2fcb400871907cc5e2cfd330415a5e950a15aeb3c8915da8a3164557baab8d7dce80dd92a7a720db8743e27c6d8885b17260f6d62a080c6e7d2178a654e36416a31cc501d0990e52c69c3d89fd940cc1605b4da8234edd008c688890deeb5ec841a51fee29b523e67218db3e39d68d80a63ef3d9a161ed3693493d2466852d5368f577fb013aebe4787a6de7363f94cf66ee998d0e3bc5cae1712a1b2bb54b58a1243791ba1e61606ef9d6995830a70abadd91ddf0eaf2a2352ba4cc9cf943ff3203362533d5f5e3cb35fed20a27c7ed595e8b453dc2cbf4eb2afe78184114ba9c6571761ff6505a4b7474a60000691412d942e664a0d942ce62f8d9a431c0fdd3d377786242de4d858ae91cc9e2010cd490c05a93560e4e48494e42495e6cf49b710b5b19a9fb1161ac5e58c65698cfe781e7bbb23915752052fb96a1b39de0bedd9c86d3f1cfb336028915095c4d1e6adc440ff8e3eb3f68", "a6e0f0abed3096b8121d2cfe10746b1becb512bc8b47c0f1504d2eb849decb686f6110fb308ad2595a87a7751882fac78743b3e7da3bcbd5720c5b11cd8aeda8c9097b057ebbe29763775d2cdadbb5d347ff091b67d60da7f98b2ace0b344d4eb459a9c41624e574b96a8bb98ccdc8e175b34f1d32934a7e7d8a0436a0cf7bdc2f505d60bbea1105fd964af5086e80553d0554ae68cf8809e03b630cf07a9d7866bdac99a12b53ab9a632bf265a13b726c03a245e3036a91c875938b80301067c3dd137ada0932f538022aac6148786b47553a00312b90e3fab5d32bea95ed1826a71a3a2a030a913053d8fc507f993850eccb23138c4580db672a5cc9f159d90cc059490a7b23365c328899468d190e09582415d5ac0ec5cd962c9472a7bef908415d78a06735b43c5ad5a73f32ceec3c152860b08572cd68e440e2a6a3689c38f1d98eb1d63588acbeaaf5f54d93333f4309f15434169549168def3bb39afe2763a8fc615c46864918c5c9519538a91f690b3dbb4e72591d2c0bd31ac7551980a02ac1d99bf5cf57d88d44a756d5e32212dbe8a952f1f565f408b7a0562e80e87c6b3f4280edfef942aa7fa46cf545", "b7ca5c820ef6056fb5b64b850c614702cf181a25387e2644febab01fa3fc24328dd461ec1ded1632e3e6ad3433d55973a18fc1f9340532ccb56e02ad730a55f40d39823babb5e2687c183570f29ac4f824efd8b22920c6308d9a9009bef3aeab871ed893935ccad3976d11f3dd429ea32c2f85942281b236f40cbe79f9267d33842e913b40f26c57fe0ce464f478794b35c46ca9568630d99c5640ee403a4701783d75c36c54a4ca61fc69eb9c3c41d156f8f66a81b45c9a4e1a4d4cfa6984526005fbaa6ca6c75c00690bb7bbaa2adf1de86a5e06f786210ea463d015abc8f802a15a13b3251271e99cc6cb336720242f33ed43fc19c6009de43268bd927aa6bcfa9715254714f732eb5e9651aaf61271296019c33912e5e1a1a983408df1e823733d91e3823111be97aa7b09c0b2e06c7007583fc5bba5b85ef9f2b80ef2958fe38ec546db53da0c83c9efde51211f332175083eff1db8b70e904b69fe845fe3e236d0bbce60902f4fce902e0645873fa2ddd8aaa502f9aebf9d7c7875020a75541f2644e4b1f5b820b128111b6072", "91074337736b93e437e5c4007b958c8b476d94355f3b97013edb6b5ce314b7c3a1d039ad1822cf1d3cb80ff291ee5441a98249f9bd27be5be201bd9b002bae86b8ac7e6e3e712c38c747d9cacd6ee517a73ce3414dab9a5bf0121cc98d00693faeb338e8a4c2c27e0d21b1ad57afd588163fd93d3b0ae024bfff6cee54a2dc8d929d56a26b33ca61cc28f1635fdc70cf03ca264518822e0cc09eefe695bfc5fb7caf4d1adb81795538a0fc04b8fb5f013f37c7e6c4bba835be860e4daa85274706d88d4c055a0790b4eefe5aace372a606a04d11fa88018c3dc1359a4315d433eeaf0c09cdec30337cd561d3b4a3f6d761ab775669e2ff86eb44afc9322f875f6478457c5fc4ffddc0f0cd6e0f8576d5350454e66d72e76aab74f344efbd218ec45f4fb7fb2c90ef3727523efb7c04ac619968419df9cc6115c148de165ee5a31dfb37c1d9300c820122f00e1f793a546de6a2be995e41ab65b3e7d8b4aa1b7e8bcd7ab8aa6af09e451aba542db52ef0", "8c5f29d5f472ae7fd6ae51860fe91dfe468d303510fe34fb4addc53eea01eef9255a9ef88d57cf4af36fe9d78020fbe7ade20d8d2e2014335e8f740cc3a4cbb261b653788d53c81ce3146d91048f41c941c21ec2ed8d94dca331b6fc28349611b1c988248d289ddbfdd0430ae2f51b2bd2fcb383d204962c98353f4c5edf2771f020a4663c529b4d0d7f589e8497a8d842c94991365d27794fefaa3430374699ca910be46ad978d48eaa8252e3f474e2375c26e5432f8e5a52bcd27b41b775c1e9e6a435f100bdb7fb358bfda2fd069a53a9dcb267db2d94a34c802130d803aabb9eeece3b9e6c5f520e726868724a81066e95d222a219f3943898c13f07ca1e9d93e8642932874896a0ea4ebaa8914c1027c583f1cfbd1d16042aefb63030566eac0464d99979dfa029809dfe989eba6d15bd87769ab8f866bbf8ddb0d06e8cec304e1a355a16464ba74c20e31b8bee"],
        ["93b6bc882842742b2a187905faf8d667271e8f18cb9b67ea33e22ee89eae5966873697710569bc0cd421544bbd084f40910cb5122c43eacc59ed463a55e8b3d3c94b8fbe389e857f4790931a5033b828136d7aec7545c31317043857ca714008b1a0c3e526fead87f986e0c03de7a316e30f85b6635aaf46a19ff1fbb580057d7c56e19fbdcc26784e6de01cbfd56d6f5467da6e52780929faf5e39cce1ad58a05ef0af819db9100047813cdda9a38d85474698543139c4fc770d96754ebb9ac25f52bd6c74f8bb93f56a8c695657e85249264eb189caa2e9ab73cabe1966954d25f48144a9139df03fccbb3f2ad5038092b4a30535edc30f89edec014dc5a19675485802e8cfa11635fea16b304344c3dc3817723d0f31dc80157f8a8b43467b902d7f445afe538f18cfed8ffe477dc5746f63891afdddee0309814bb39685288bf75a3b1fc1e723df4219a71c310ec37cc4335f56b04089eb265325c655f9a99107de77533992308f5040b9d5588bd2edf4f4e7bff8f74adf6c32eaba34b4c26d35c1ac6f844f0c786e75882561e2b6660578ce3bcc43fcfd6f52998b3db0a53470acbf21d01d2fa3b28e25a76e70c4a1ce70348d934a0ab5f4ca83c1a61c6a4af0d2b0ccd8d84da8690a37ede886e306c8df4413565d2775e1dc5ad12e43d4678275a6e3c5116b13cf6f6ebb0f50d", "886213b38fcfd023512cc1e6b904730c6a6b5a3bc5cd0d571959536683b03ee6edbb65625015e1e349d46819957b7abf8568442eeaaba73f1baa9f5df1ffd6d28fb92da68c2ca6962b8d264ea0de8bda52221fedd54bb953de2c573b229c3fea91b49d1460f72b241ad40910a745ad27a6990eef3029611f3ab44a653ce15fd47907794a301c97667ff847b5d7f9564020261ac8cfe62cd3e135fe0a8d0e1a726e1a162203b6e9e27dff25a0ca33299b6e1853bbf7e356dafdc5b9b171353a34fb93cb85bdb3c498927457f5575c7c59557dd1c88db25b2d83c21c0be9e6bac79f314b122ac7f7915f1b7de001715aaa4144fc7195fe1ec03bdcc3dca6adace090fbb3446b48cf7ae75668f3bc5a8dc85745df26e1554e455003877f57a7b9b3c82286b3bc7a0f11ebe97b95b30430e0241c4edc94022294e32fb84109b22376cb68d174cd52abcd9f6053982d8cea851242c1703df68ef4b6bc59440ce80a6a07a5123bd3ea1e682d6efdd2e41559fe44f9c1433e56b92a05580049eeb938cab72daf804c882b988fe545144788b19158a4fe42c619d39edd7cdfbcaefab88801a4bb78640baf00903e26c46dec255833d432ceeb5d32974e210b39edbb10658d6c6853a06eba6c60001690129c67bf", "94d550f033d40e8431f1dee3806ddf765795b6a52fcd1e8df698f39e6e2a21cc8725cc1f70423b878ab2b6d8953f7a0e8236ce7d50ada1bbebeed843d11b5d6779c0f4f01b5d492416664349fe1f34dde8cfbb21f286c4a6059a3a4d7348e4a6a18e7044a3f94e5d1fb8b8399164f895a59d18d8573d356198367ae844c9aebe3606d6aaa48cd21e0bc90b90291e92a63b71ee31afa31c390c2f6419a5ceb70c717088a1d0478d8ba1f74a8a8ec7f85814568ae063c3c7ee760c9fae37cf4c10068055ca0f2eed6c0948662aca344320293e050f573c77588d56ba9b348986e5388a52a30a260709c56ea9281ad525850604476e5707e7ce2aa46bdeed7cfbc8164a27c2e24409ad53f0a7087f7a41b05312604f454ee142434542456d191b83b8f745b4cd92a3b251b85d4ee37df355191016f6682f42f777c0399d1351fe1ae2aa73756366c58d41cd0a52d9545b4f6b6cd48ecc022f96194492c3282b27f606762eaa0623ee161ff765b56589a1002afc47c318634b8ba68c34d178d3ff6488cfbc5bd32f52acf153415b9b973ac84736a15ffe1b51f899a6dbdbc22861f70c9aff5824aba002efd994f0c53398df", "b289b285fd24fba29e82a48c05f542655cfeadc56f09b5c8cf50423709741835441705d4d93db545015423a4439bffad970baf764a11e17b806f786c70a0d91b545268a44b9344bd0d61dff1105250881cb820879c56a5cca6a1d9be2e183f9b8c8eaa9c2eecea62d5f2bc07710cbb6adc4ae0f5941b322f3914762fdbf9389f2f21f451e3d7c51e332ecd03e64ba6b403da22cdeb1ed52b9ef3f16c77712067344175af7d7c87f0011b23e441b635982afc002e4b04e22b5c70cf1f1abd39e747bc31b756636932ac5ce736902939f8616ad3d19002a148f53d6cd79d0ce044f81292a62075b28aea2800e3fefff8b31a648f7120c33dc470206ff2ca961973505b218bfa8ca0770ae54cf00734db5f0445456dd6cf8c65146da9e49411e8de9d95d316692a36d872b8b87d588036230848cfbd9502668f3fa834ccfa328187e7922a1f90c307fe6c25eb66c91ed8fa38d72054cd0293e280a5c6a4cfc095ad85762514a2aa671878bdeac3b0f2be5714ae1a5b3b28acdb6ff81eb2845b16f883b54be6b9a6a0cc398ebc43189a5cc5", "acff3cd0cfaaff09d49ddb4a4783df39817b7123d8c1c411c2cbf6275fe4a94484fe2662bf2fdb802255ff1aa5428522b11c80972ffefea4cf1c232ac3d2f97e653c5d83e894d9372e02645b3d17c32f6fd9dbf6799b8205d6cb0c4d60a54f80aa0c6cbad20d5d3789bed04cb177021924a935590d5901bc940c7095139a055fbd70634ff860ab53418bd8cc720448241995a69747950f4f5a92ac537ea9dbe3663e8c19ebeb7548e3c378f4b9d014463af1d297a6617be860a9df24f564836893e905a3320d6eed469a20a0c4004efd460f579b79b20cd4b1b50f0cecdc08f3f7c995f215b3eaaa8f69b51a4443b13523330fb0d2d5efd88a4690bd9178e1eb6b40a8e3edbb9ea01643be9bb61115315d3d0f07d38fab6662151c1498e51323bb58edb605da12cef8419a1044da09290f2309237b5f64bd6951a7999b8c08d86e8c8720498638a74896981bf50fde4e29b2c3b133448e5ba140f13276804faafbb004c52e142b779c6e0cc1a95ca1cb", "8bc88154849b748883d5a78c934bd83983e88cfb30622297843d65a039cd63b5c9c3968316087e224d581a24ee2ae17495a58ecbbffff2e3f466856747e4adcf21afeefd8dc255c4c8decc8357a79d6275b552183e571f6200483fe2232d12beb9eb6a6612290d3cc6c55d5ca3ef75150b6ad0dab54f8794c5a56df5969406286738aa62d255ff7dc7a0a7dafbc49d0013914c5c6c4a76d10d461d9d083aede528c77124b551e16139c2ac9df9125f8e0518d9a3217a28a1ad413482985fc27de5c664c1be5629541680ec29bdff6a6a49816378ba21b3d20d9f22f330f83956488b6f597b88113aba1c0c4624b489d320d75ffb5d021678d01cd398ff367d1bf695db49b252d51a61d98cbd3f1a8ce032aa322cfcd6ed8ae75301392f603b8a426f2abb2be7616e2c953f4b2c1ef1c02898c8c4ff76c1b798c654b85b4cb63ca3d0c5c3dd99005e93cc17265debcaf0"],
];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(
                TEST_KEY_GEN_IKM.as_ref(),
                TEST_KEY_INFOS[i].as_ref(),
            )
            .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = Signature::from_octets(
            &<[u8; Signature::SIZE_BYTES]>::try_from(
                hex::decode(EXPECTED_SIGNATURES[i])
                    .expect("hex decoding failed"),
            )
            .expect("data conversion failed"),
        )
        .expect("signature deserialization failed");
        assert_eq!(
            signature
                .verify(&pk, header, &generators, &messages)
                .unwrap(),
            true
        );

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = HashMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert_eq!(
                proof
                    .verify(&pk, header, ph, &generators, &revealed_msgs)
                    .expect("proof verification failed"),
                true
            );
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            &mut OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            &mut OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for ((key_pair, header, ph, generators, messages), failure_debug_message) in
        test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature = Signature::new(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = HashSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            &mut OsRng,
            failure_debug_message,
        );
        assert_eq!(
            proof
                .verify(
                    &key_pair.public_key,
                    header,
                    ph,
                    &generators,
                    &revealed_messages
                )
                .expect(&format!(
                    "proof verification failed - {failure_debug_message}"
                )),
            true
        );

        for i in 0..messages.len() {
            let revealed_indices =
                [0, i].iter().cloned().collect::<HashSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                &mut OsRng,
                failure_debug_message,
            );
            assert_eq!(
                proof
                    .verify(
                        &key_pair.public_key,
                        header,
                        ph,
                        &generators,
                        &revealed_messages
                    )
                    .expect(&format!(
                        "proof verification failed - {failure_debug_message}, \
                         revealed indices {revealed_indices:#?}"
                    )),
                true
            );
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<HashSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        &mut OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages.clone();
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<HashMap<usize, Message>>();

    assert_eq!(
        proof_all_revealed_messages
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages_same_but_shuffled_indices
            )
            .expect("proof-verification should not fail"),
        true
    );
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());
    let indices_all_hidden = HashSet::<usize>::new();
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        &mut OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect(&format!("proof verification failed ")),
        false
    );

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify(
            &PublicKey::default(),
            header,
            ph,
            &generators,
            &revealed_messages
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify(&pk, header, ph, &generators, &revealed_messages),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            Generators,
            HashMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert_eq!(
            proof
                .verify(&pk, header, ph, &generators, &revealed_messages)
                .expect(&format!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            false,
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_prime.to_affine().to_compressed().as_ref(),
        a_bar.to_affine().to_compressed().as_ref(),
        d.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        e_hat.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        r3_hat.0.to_bytes_be().as_ref(),
        s_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
