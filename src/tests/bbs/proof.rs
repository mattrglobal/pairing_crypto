use super::{
    create_generators_helper,
    get_expected_signature,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURE,
    EXPECTED_SIGNATURES,
    EXPECTED_SIGNATURE_NO_HEADER,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFO,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::{
            bls12_381::{get_proof_size, PublicKey, SecretKey},
            bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        },
        core::{
            generator::memory_cached_generator::MemoryCachedGenerators,
            proof::Proof,
            signature::Signature,
            types::{Challenge, FiatShamirProof, Message, ProofMessage},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use ff::Field;
use group::{Curve, Group};
use rand::{prelude::SliceRandom, thread_rng, SeedableRng};
use rand_core::OsRng;
use std::collections::{BTreeMap, BTreeSet};

pub(crate) mod test_helper {
    use crate::bbs::{
        ciphersuites::bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        core::{
            generator::Generators,
            types::{Message, ProofMessage},
        },
    };

    use super::*;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
    ) -> (Vec<ProofMessage>, BTreeMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: BTreeMap<usize, Message> = BTreeMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn proof_gen<T, R, G>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &G,
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
        rng: R,
        failure_debug_message: &str,
    ) -> (Proof, BTreeMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
        G: Generators,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng::<
            T,
            R,
            G,
            Bls12381Shake256CipherSuiteParameter,
        >(
            pk,
            signature,
            header,
            ph,
            generators,
            proof_messages.as_slice(),
            rng,
        )
        .unwrap_or_else(|_| {
            panic!("proof generation failed - {failure_debug_message}")
        });

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let proof = Proof {
        m_hat_list: vec![
            FiatShamirProof(Scalar::zero()),
            FiatShamirProof(Scalar::one()),
        ],
        ..Default::default()
    };

    assert_eq!(format!("{:?}", proof), "Proof { A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, B_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), z_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, B_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), z^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let mut generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("signing failed");
    assert!(signature
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("verification failed"));

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        OsRng,
        "proof gen failed",
    );
    assert!(proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .expect("proof verification failed"));

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert!(proof_deserialized
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .expect("roundtrip deserialized proof verification failed"));
}

#[test]
fn proof_size() {
    assert_eq!(192, get_proof_size(0));
    assert_eq!(224, get_proof_size(1));
    assert_eq!(256, get_proof_size(2));
    assert_eq!(288, get_proof_size(3));
}

#[test]
fn gen_verify_different_key_pairs() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["9628b2bcce351ab6881610fe7ee43c66db49c249e3836f7c8bb7b69be79613d0bc1fe7767aa6afd53e1f430400a4d5dfb2ab5fb364fa43d2ecadab37a4884fff484dfc8e09163119b0ed7a1f2cb676733ada8279ab13299a352d32623f43123d658385cc031150cc1f8b57a763d2c1d4cca76bb213796cbba081b2b30ccb9b4861ebf0e13b765e63cc14fec40d5e1677cf333400e2634decf057484dfeb360025a9233ba631f44f340d7cf1b83bf3e90263bdacfaee921b56ba8423d251e65456c9d137ea159b6485d6df98118e199e9b784598dddac88a174d9510fd13c3e3a07198ac6513296d2a0856abc9a27b320f8aab0f7a6dfb04bb682a8eb6f38f0363e23d94989ee5b535d9b26eec86e8365c85e11da671722639e0f41404523cb30434a2b8688bfa3486937629d74899cdcf7d57ef98feaee4ece84a8ba4d17ebe32dba50835c28c09ec6505e82d6e5c1424e44ccc57e510b9063332602e03e63d00af6e86327c587ef5fc22912ed2fe8f934b6e3a8bcc6a31121c1fac0924d160f", "966c6bd76bcdbba320b6596394aca283e77c558bb84c905c6a3a51dbdab7a27dc437252273b74e06c3315d43b454378b863c1304812eacd80c9b3e21dfc485591a036d76751862425fd40e0c9282146ae44f8b3f31da4fdc4b3f2a665ce195ee0587bdc400161cdd8f34504fff1117dba442e900c7c1aac93a33dd9275c5a4d03c6e4c23773986c43a422b7e5750d732e1260fdcacaab4dccacc8cbbd61a7b2b616d99842529e2d339a07fdb3015663fb82da88986820163430248b25ceee26f5ccf9289150b9076aa86e3a3fc82ad65cf02e5c005d5294b9d9e83c11039cc070aeb9b7e76092f11298fecded03770017d77490a5760faa9f6550888e9ed3ed2564f55a63e52bafdb329c3b6b2340d34c230874657374948ef56297ff06a26040d7a55a9e5c8adbf83ea82f8588f45f3aa3b819787c07938984cb629750662c92dcf03b17a2577ae2c940d695ba810e00dabb8ccd145d5d33f5800c468f5b238", "b19cae6ea309380160780f51ca327a325c087a7ba93cd3a2bd9f74abc1d69a25f1d5f5488608ac77d08d4ca90e5e69ecace594a435427ca2ba2f5529db0e730d54114e674a4afa3630901ee709e3c08afa901ec8f59f74740ba36f39d231ffff250f2624e4fff5209efc1fca2366c5150756cf38ef182e9f29c5138a86d1ea3c15ba0595f06a30c522dc72d22216ad1c4cb92bdc41e26ea341a6c11e170dad9b2aeb493905a2701a7dbdb178ddbe8aca871d192a4804993633c973c4f2964d1b3765725ba6cda69bcb974e63e2eae727d9b7796eb4abcef598ce1962c6947b5d4c4f4b93df46de34b8c56374ffc731019f050a442e05bb850d0b0dd5cbba6343264061e1fbc69e05bff89042ec0b34d995cb437254cbb37a09ccdd6cff3446e7304afea05dc85c7af7a4d74c9930c9f65ad824391304c6cb61625a89a22ca8ab", "b0e0381d765a34c580d03a34aa66d451241d895437917c5b5ec4dbbed5c31e4c87808f2b5263c7d9ce259e12b0fec44b8b637e73eeb413b4c1336723cda9a4f0d10614b6f30b5688c3715d72cab56b86284d5619ff24ab0fcb0f93625ac8f1bf30b612374913d04c169f29c5db7a8dbbdeb1e13f7ef5f97bf7ff694aff0ff6fe59ce920b218dab42ce8de431671243602cde8680454dd6ac76a1130a0587c28f071fdbbbe3881e2479c3ea7f18e80d60a5a0ad8636373e2c4e8062863fe17d22431624050207b1bcee8734e02b4fd9a8a9966b1b8fc7c41ca64185960aafb1e825c47b267b0220cb0ef88017635f0c9fccb83ef12ab54e36d1e9020f224e3d2464678978407e1cbf54f292f4be3704d7cd661defa5f85e022638a2f75a9ac1e1", "8da2578c1ca349585aa40cd22b32b4bafd191ccfb191e72f083815d1422864302b9246284cb9d87fcfbe6d230705970091245869a8826db1700f5b73a629f2c044409241947c0a3022c1263dca3770bf8886b36cfbb438c1d06dc0e4606999cb1a2d71b355928ced3dcc464357fede35a57281002ab7e57dcd222aaa46a17ac00f7d3e1c9ca6a1f7c799be8bb01a71f5be6c93e0a139c1bbce5409fa38e8d779484d5ace530024436015bc5325d99b1efd245387540858b714b2c4e763cbd05a56fcfd9a20361cafab94c8bff58386c88bb17656835e9ce53638bd54003a17ee372c54973ea126c6f8e9f9a2de4949570c409a01ec3dacc42c576929fe74ba65", "95fac824d012b56f37511081211632322e6622db1f354eb712e884165bb4ec9f0d2f11096ea75c24de4726a6dd680748b3b230380e9ce79246504fb3ca2e9a560d7a7809edc392c92eb03693591916b1970691932aad49ff64294fdb0d519f516b616134cfca918abe44a073d16cd2ce3498c030f99285d32e1c48ff85765b2c18351d03d9b0fa9c8ab4fe60f8b18fa318ea1047fe6196186f3a970d34ab098831fc5f7ab47148d5e6aa4ea4ac1cd7ac548f911077c000e6f500a4752f2854c356ecbfbdd6670b4bf3da8889b19d76a9ceb8ba06d37a454ee15cf429701c5a93"],
        ["acb0e15dadde2961d725ee22aafcbd26a81d518c711b235f9868db47e46731dc4d87d6ea7f8a7d9b1e15185fb872db52a0092017ca2a3defe8ffd7640142436fa14408f82e2b187f8283275481f192456e67104438e24a782666d10332ea0893128308079e6e300b0e6a6ac6c49b5fe24618bc66d1e43777950204b1fe9a2d47711315b7ead72b21d39ff13298bd57881a3ae5a2fd557e302109d63b8bbaa3635cbcf8a87221dc646055288f8f105f5bf609c552aa9f63e7fa0508765296211e45c9f360ed9565870fd2b2a2e3f7447c6c36035365509e87947b3b168168dc4f4a6f6a9d8a191aac522618c5ae874b5582248656194d18c493362840a2b374680dfc7009a1a5d1335cddd84273c3ae8a801cda238a01eb5e3cc563d10f10170d645546600fd659c85dac832ef73b3c69c406a26eb16f160bf15d1cf078376a890cb6c27bccfdb88d6c7ae58bc2d19732835e0af99046e5cf92cf28964c2fe1393e4dbc764bd824ab256e566c254b0bd71aede8f1e3cb9d13606cbadf02c15dd3", "80d1ef445a20e876fa71dfd024eb2272c5d46557214a92919359cd32e29c1c8ce651e1e753f673c6762c1dfdbf4162c792d55b004fa9e8c565ecb20f434b5dd85f85695a958a60ee1beba9dda62eadee1af744869865ab98859a62f02ff1f942120f07ac39f42faa1876fcdade9bc4f2209a9bdba3baf1b0257d6397b70424280fe2d6c6b06496c3210017338d04ce0427d3d23a830e83776cca027aa7535f5f09bb7edc800f25ec80e7f7ab5fcff62bdf751a104fd735d5bc97263e500ae15f1e814219f903f833bb963d960692a4c9ecb5f299c58922e45f9b34e3096c6544400daab9ec0bf34484e18b5b01ea842ac60ee7f2326d1cc7f0a4f2c5fe3a0c9e663afb5455ef2999c82f27d4d1bf7c8015bfa75a67ef59b586ce71c16e48b9bf456f3fa81825a0e33b7184cfbfdd2b30acdde941ac868e107025337fc324e23a3bdf32b2521fce77f4478fcd37910af3672bbe4aef1725d382b7f534dedc9f05", "98c91ea14a8188859ab837c9c0cf9ff869258046b76b9ff85253f74df5b0f15c130e1c4e511715259ad532e7a2325b5e8c630f53042d458976a4dcf245fe79c1aa7ed2c23cf7e6f880b032af76aadd2b11f7a3d071785ebd4dec9dfe0e2f296725acf0f3b346736156e83de17218dd2ab1528e24e1f423581cdf6bb501ae70a912a878658397a98d7768719b68986d20184c62be5299facb0d3b64be4d86e15d208eab0f4637d8b38acd657bc7fcc57b96378f922141bcacbc3dc08c7548c5b60a63523b967801060898749d8d0f814676ad6fce1cc3239e8a555d36751f71f22ca793246913629035b830913e886d1a422fe73c1afc15a6d53c17b1774f14fa5dfc5bf405798cf57259f7132cc96a2bba3d127f2a904511d2302e41c53cb701576d47973b5860e05f6979c68849ce8c7a1de232b6b4a24c1044603af6a8d050", "9028f32ec2dc196937683592581f6e9ceb9f73fe3fe9b3df4ed384455a973b03cedb36854013c7d7c8ebe573b8540a5395a0a9a2b1884ee8bba05f7ad9cba60dddd922ff54bd1adc228779a819f472268ed41f47d42435b66772017cf9962c82557dbc9b7d75dcd07c9ec304d48d3bd5599a898fd492fbd0fd06ec84c9d8b12d2c3e19741f24222cd80c2579573b15de2d995b8a9ddf642842717a3115e3b1bc058bbf7eab8e0cc2fa572c0f9f3708726efdb76c4d4c503fb535850513dc703c01ca0e392f2ba9b4e899e09cd1712e3e48fb528b47e82a730546bb30f832ff8d16f92befc606a936a4f24cb29d70a99d37b5f8301b4026f3875b3f147818dbab0a48472c49dbc6f34b9a4e72a463b558230c7f7c601e8140208a4b6902434db8", "ad87901f648f44a07ad831d77fe4a7f0886f78b0c08cd78ba9d6db418e8fc15fe2eafad32bfcb92e6b19fa3305ca98128c912350e3362c143aad1fcc9d921fe938077db70ddcfc24aad57f39f052de20e67564f20d8de009e4c34b17ad317a844cfde2c89620ca1b62e176f52b346ebce06ace9cc95042615361605a5aa524836c9f0291e94d2d0639b60659c7eaa53b1d99094d23bbba132ca0c5afea4837364b1a2c6ce1f94627d37aaf25f435566ad6cc0865e3d98ea8345a9d0d204828230dfb7044e10569e64378aaf36127d40bbd0df0c8ded8062a3dd9230fb14c02845faac9cbe08e2f526121eac5c6c84f9df29508a13cbd3f751c05b99d317c15de", "b312b849b6c7fe473c7d2f20701506a4bf3795eff64831031981f5266fe79327c2ca6290f7c7a08228f7210a5aacf91fb9c921071ee0e3b55339581480c6d0a2fb56288f71d3f327e0586670b8fd774afa7b3a2cbe13d9158783397c79f056fb1474c9063843dd9d5bb49d2d3d273a1aacccf39ad5034c36f92e57b301b47f9b479fcb75aef8451345cdad29e2973cb9d8af87284b90fec046fcdbf7dcb6bbc73d0093ade8b910347cd93b0dc8feaa9fda5ba969d344b8f84e356fb6707c91aa3a70c5b186fecfe0dc633c1d409f0b60b087123503e62ac252114372179f825e"],
        ["945b637a55b7649f4aec6ae1dcee4ff09fe78d748421a5d7f7a4d2d4671d58bbf9b6e129771f07f7353898aea2d3dc0e8f82095dcdd904ec0fa51b7fb9dbda35313459a674ed599929f68b2187af1a8bfab2f038b9a2620f3a96e9397d566dce32ef92e423f3812dea234ed5bf6f24b2658695229eff01cde45e5e23b8675b44308f9deef65199875f83d81ad1c1e9ee5bb3b7f25809efd1c7e2c2e5e969a7ad40105974d5e167fa4f27c5d7d0f28af0647b95b04f57747e62bf5c7dd3ca41503b4ddadbcd0c5663d499effc422437e1e96506ddb33ead9745ea267b076967ab44ce02dab376d6fa35694d09d0111e7e4c208751144ba922416507e64d9f25905dac4df584aeb7343813d54301cccfc6456be9d29eed5611bdbce900a0465eb55632b67473aa669220dc13bbb920a99de3f8f95ca58029dd89eb0df5f9868d2e39fd35980de9a9b9ff4de9ff046e30cfdcc053f9c032518843e3a286e2d494121744d149b024d378598e45b0df4296dc1b2e262b6a711072e907f7cfe0db1bf0", "87a49c19b7ff81249d307acd9db4c1ae50f02be6dea191ac48de43cea246e555404a61ad06853cd9751d2c5dcb9564a485a6e9e658b79fbd3142f8b25127d6b503fef6ed2a05d1732d7a2aed0fe184c5baf2d671b428c5ee6d98d23f7d36d3be0479478ec855147c723685f19d52e00075ebc0388c9d61f29840272998c2b05a0fc26d029fe0c632dd317f2f1fe97f929c5980d3eaa874d09fb5227fa36753a43cf611f525df03d032b7c3c54b56624f65e4b19bb107e3d68addd45036ec87ba611feecc4102b5d03d9f871a32b7aece0bf281271ae5df8b829027b6c6e0a767515a68f9e6c3e4beeec42ba54d035bfd5b9190ce47aeb0586b4b857b3669805e16c31e5f681b959153c150fc1fa66a22e607e90a3a99d0cbadfb00743cdcab25452341a3f69721e70597f0169008c940fec4c16e90f31dcc3ed67b7e1818d68a5bf4d8285790a5ed7ff6b1802ca6134f4c307c57fbbcfe34f98633cc5577facd", "b3f58e82636fb6f1a9a52fe93ed81db20d79798aeba646d78d7ddf7055f577cdae31e856aa4b0e904abd1860eb98febe938e675db62716b5f44699e9b8427ca52a99758aa1e9419b59fcefd079f32a404f80004d2998d4f07688ccb1f65c6275191d5cc817ddb518ba5096fde426c052febadfbe9cb1f20a9df81712ac6bb9a8595c6f2df24e8e1619c528a002a09ed87edcb6bc9d08845fc86956cab118c8b7483ead8ff4f7855898683304490401a424ba5416f8c3305012e69be6d90c9e6c0b3f72936320c6c875d8fc922aaa325f7ec38c35b8d97b87201f44572a0e67712c4acd73cb9924d02bcce7e2f7f105d45cf0aa0684eaffe111a5531cee5888352300ccd75453f9c7d69aad5fe176c11ee8fa2bc681e3577616491348109270e8649d3f40ac8d2be3c94183cda15caf5974d1c213f1931946a09cfbfe459f2466", "a211a05a0005030799759f15c46ec3e0eda05fa2ff0afee882156e023de0a0cd29e9615cb49ac0f2f9943a0c112798caab888db76e5e9997a1cab2af917c90c900e825e74c9104ba41a50d284f7f6dbee8d07dcfa5bb89013cd73d712a4d61475e86618f5a89a015c8f442a93ea0f8971adb79fee53840de2ecf1fcff53e3ff113791a5bb83a916382305be1588eb7b3f49505b0ff07ccda6689c209228200a31ff4fd1ae8cb86ca46d2341927f1c6e4269420c660b8bb0b013fbb369b90780f43e533084348aa5eee0943b7214e7678a2f05cb08c752f0fb9e12883d4f2e0f72b2b114313237d76e62f09e39831f4bd5137e23b51020abe61d24bf26323af4d0eebebd04d2d5d682862310551d8a68a75ce8033d3b1f5e23776e899c1d4f208", "84b3e0eaa2c3a9ccd6de0adee644f800c8b3dc53b2c000cf136cae8f8d86be85c90daa83c975990e16c50239c3ece2beaa9991cfa0be2563dfe1358039127c57624da809a19e8397e5688587c0f5e16dd5b5d6c0a564756218fd9ebbaa43c9da0549662d3c9dea41b0fded76044262e3df122fa3838bb34e86ed2bc842686ed207bf5ed89be801c8f962753d2c92128dd5d7b32b9297a08a845c073b08a46c992da77423b3096b05227d4aa9ea065476df33c5719fa7b99b885455e67392fa1d2261298cca3188f49e96aea34a6ee206aba004b0e00199cec65aaa471051ab95375b03da4b596e3b6ebc41d8ff8dd4c9b26bcffe8d00a9a7edd8481daf72d7aa", "b5d42b2c718da0cf89b1a9ef12204d0bf50e1e575dbd2fdec12a2ea1f7586efa31d1c5399bde1e059f179250f5aaa350b69b4ef14284288e9d7ce2bf7d050428b03a787095f11bb30432adec77de4197e2c1201b6e968729db589e1bcef6b27a39745d2fee07a4481941f4cb70a9f86087963fa997bf727105904ef115d3b2cc4a187a93c02a674f1a22ddf21d4c05fa024d00986d7b63740be7b66cd16df5d0658d2b35879d8027959d1638a20234867ec23cd0ec3f32c80603bdbfc4fbe6295be9a51a7f5eea1a72950b8ae125fbf302f8bd89b31a1628bd77d57053de9141"],
        ["a267467795ddc630eff1e1c637504fc5ec16c95d38540f9657d77f940b037a14d4647ce980299b0a4899d53a0dee2ccf9103a72e6fda6d162a4ca5801d507e76726823f71d094979b907af54a36b639e797e3ab69171ee78423da1662ccb961d3c6190234ed69c2fbd5f6ea41cd870fae05dde992ee8f6d38abd7de9ed8d49656038bb9900a42b96d9cedb625c8abb09df1eba80e67b497fb074938f2ed2349036f69ea620f0563b1cb867e401b932ad0e380e66c0432ba36fc52f5df158974558a62fb78c1bc6617ad2075f3db51380a3ba8cd566940aca39e3cfcf268afb5157b7a869904b02bcc7012c3720278342c37359cd7cee867667d8024e748a3c24112fc43853223c55085428896b93d0357e4fa3ccc5f943e05f29998dd6cdd496340e197c112215c74185576e4780ad2bd040cf5399b11eaf30a235da2c7492c172df122d1fd3bda0b0d74114b049163077115b95eb403099d9846fe0f6eb0da261e08bf4ff5cbd59cf76472ca36cee3de0fb5ad2fc2ab41d47683026df59ccc5", "b9da2edfda6a359fe3d7a60ed9f0872e9e836cbd6a0b3ec077c8e6525c7ca79690e917fff5189a2f8cde83c6c891c748b9b89fa046d88c7f1cef9e8bd86509bfa7e8471ee1e361f229180c953af4df6330f73772b92b16a54fdb895b0b06fad111f8895aa1e0652dba9084e6d3992a031d83c0b54196518880451fae308ceac82d29f6beeea9ecb55f50a72fcb4047bd9a9cb9d0d5844535232514650b09490112601f49659b64ed07e9e197a1cd27034e5cce91f344ad647910a731d27d2b1721cce3ff9c45c765e1a27d92d3a6e715aeeb3d359623c281133af54cbd579d03331215864ade042aa4278a38f872cd49722a7a989a565735d37e6f955700f11d2212507e2927d724aeeb569b9a2fb21cb7521b2d4b753dd5357ba44fdab7812c3e5450c351259e31ff42b30e3dc0f71e99079f86e9be311ea1a472203ae23ef41a2ef2b8aaf7a029eccd753fe7d7e099cf8610a7211e8b2eb03b577ad9668200", "b34dd94e1d231be569dd5b51ea10973df70848a8b1f1c2d80c9bd75eca3af7be3aa1a5ff95fac73182d944878cf9cac58ac8ede80b46b6e093af8f7cd8477f29efae4dc93e1ecbc7421bd39611f338e304bc763168d9d411aef551ea1d5acaa2385d34b57dd5671f239c8f27cb141a6328a5b01cc809170e7d795180545b32cf5647753bb947dee704637f36cc4e9244733bfd95829a43ce003452f39c8d0e195e30b5b7043262aa899b34bd111aceaef036fe045957f23e314e73594cadd10c73582860184546835588e68ed1604bdac7510c4660ff9ce96454430dacb8b40465e2b903fe93e0ca39f519346201c46eebce17f7ee591e340acf23d44fbb6c6e57e86e223a933a0df8429a0581c18a9496632adf7d43e250ee0feaf7259a02fa569dc0998f108e4b715ff330cf400d3cba0a2a83afbee6a4aa7406ddfa7e2242", "953910cd441d0bd0201f2185c85c939bc8b3fd5bf7e979032555ae6cb48d7cf036a1e2b631bf6339150d613a5a58362381c1c8a6aa5f289d2e3e4ab7ffdcd8521e32fa86dce9d95ec0e04aa46475094d040b88e7e1755cb9c9316e446d1a1d3a19f3a75fbb226be885394b7e63c703b3708a0b7f4476456a7693b1ba0e47ad93256b912a8014980c6ca3868ff6a9e23e6a25208aca96de0f68e09837740953375b70e192dbde4325330cc2eb211e58befa0cc2568bfec2a8fdc71884c3e3f9f048f29dad0b6c659fc21fdcc42b5eee452cfa8672d5b250bdba95970038ebe31a5c08679e126e52faa7993353759e546145a7c7e5461d98242310d420f99578ea48148732d962999db40695ebfe49dd27facfeacbd3553a0b6ca852573a3dc926", "b7078179d43f93dd97e87a956cc1c4b8731fc2f4d24e1c9b4183a2b695b080bb63a511d68166c46352f3d2211f84e1928a2e8452a4c007274a712b6d439ce6a391566cc055f75ec89afdce7a92a4c18e3d99f60f96ac38000d96824167f1c27c67c332c15932e7cc766921a08682f4ef6e314e5af4e1e163814acb5c2d6ccf1851f10e18c7f5c4c1eee68975b102d967f79d1e4e1769e3ab948b5a95560219975115b25856206a44072c79240e0a53b5cb03d11de7b059c8c9ac677a37989dfe6fd2ea733814a8d1827ed492e3fcb49f65a4bb3130357dfcfac23be835a821d16198cefcfd9e2611b45eef70720290bad964cd6a892b7e4f08316e41e71c2873", "b08ec56c8aa6b4867df2e32057d2e6e87862f2a3d89a0cb9633bc8bf31ab4262ecb540e480aee02c488028f70478be6190659fa58fa8781de29d6efd67569579fe90c07949919f653ebbb79af5377f117f4de816257abf1d9ceb6c2071891a0438fc6cfaf86a3ff8ba61b7b1ee48b1c8d7b1b3d1e582ff889ead54c6b2fb202c6d8999c29737dbe8ba67358c54772fc15594fde9bbdc52843ef3c0b288d5e1be0bd8ce07a621e4cdeff514ede70b56a968ae246cabe558a8608449ad659d6df00481582451010408bcc2b5346cd2b443f77085ab9d34b69bc7a22e1b58b91a37"],
        ["a0e3e72f5d4a52a0dc66854c6914a3f42bccc70ef9d44a557cc6d7c7aeaa85b588c995d86cc76613e7e06797fcbadbbbb6d14ec97af88dd3204ca5e73561f85ebbd1fa696abf4a1f2480b9f4bd904870f6e22e8f95d3524d8f736d6e5a64f4b0171f55f0e2fd33535ddf231bd3ebc1b8184178fb51f5979872e647fb29badb81378adcf21a1cb4e263f22170d85afee27b7d868e6465994907ba7e27f5e4ad5038f01fae963d44d4412983d7a55aac66af657b9959a9ab83d053d66b67e0423442704d29a7285540f34ec80c84492ea9c6bf1c547d310b8a8df26d13a2294c2924632a852c1b91524ea4ab62ef821c1e735dbbb5a614c049d6e4db44b994866f68906673f4e2e842303afb67ff9c50091644388f0dbc362a1913baff4f0cbde26cc584776a25c370b5e7545a9132a6828704fd0fef4daeb28e8c289606d5b79e2bf1fc639dd449b5b96cb24e39188792dd741c5349ba29701b73d26205dc0dfa39b2b3024bcf1d323cea6d6343d2e674a58bac9a379377b5cad09cfc96f907a3", "a9c28d0e531ac4de6d9a537c47513b7f2edc72731a525a55761ae2cf74fc91e7fc98cf64afb0a2a6cc3c571aabb656b18dc3dd148e78e66b2a0737423e4f6332e436c0b91b4ab3e3d49275faae2e3041b4547791d41e4f2687282436198d20f349311ee12e54059868bd14ec2e6836d4e7863c3b4c9b2ffff02c68d7760da3aa29abdb420b33e5ac201f4440f8fa7fb76cfc471a9b476e93066643a47f52086f49835339365bc22c082a07d4b5bc8ed95000a4d3db539ed4d4362b36cf95082e2962b85b6b47d6d65e50c7f451cea1b7173ac9c7393d7d4465322f9783866c4a40e12bd96eb126d60747ecd95ff57e01a3c74f3ecbc16ce1de030e6b8c889c0614949b1285041398dff7946bf0f878b5e6af9081550f0edcad32a5476009c03230242c151e4ec3dc7b581faae23738e01c8b345830a68e02231107a211f316c307b6c5f66e0480b1af58370b3f48bb8f6920a3558e6eee87cc0d85b556b325c9", "b0c79dda863fb644fafbabf036221394cf7ae73ef63b1ebb3a8b7bbb47bd0a9d2c3710751906544e07415cdbf512b8f789defb601f40791ddf1eaf91ee311b2129977903ab62a7cdb868eb4cadebfed30adc93f8f5132da30187fa692a3bfd81309151c9657ea1d0f12e6e6335ba8f4ddc27689859809e07bfa9f09c31eedc5c04d1e1c0ac943b873cfa9a8f2e4eb1edbcb7073d217e9fac95c4e47bcb71d61f293d38f432a160f89c413e8d6a561ffbf33115211b4767fde0b285eea9e34c2c21cf77ae60779e34fa4452e00c7e936fbb72370dd050ec3459b9b15c641e3cdc0d0fe3f69e1057c631a093a7e0009186bd455c027cecd722c1f9b536ae345f2b2607842af25cbbf862c0ff0cb322810155509ce88fece7bc26681dbcb8c3a3884553a6faff23e703e2791ba1c43aabc2ac068ef4046c5e7ec1e496f805a35faf", "b66f5baa924ec6fd36dfe4b21cf10fbace245b40e0a1b48bfd01ff7b51327dd03819dd94e63f074eb74ad3a7027107d984a3c13c3acffb49f7336f8528ae77ee37f125183aa381f3f7bddbc1975de83c4c121e86910caf18ba776497fcb8b1c336e5328da9288b7f76ac5bac084bcb1b761e17ed8604f8cbbed967ad4f3b931415d542031bc34223f30fc215b2fd69e220c9f81d5ba186ddbbae31f1777cee0d2d5c41cf995ce9f7e4a3ba3c5429742b87316c52267f9b801d1cde590196428a325d3ecee56bf08e576c847fbdd2264228d8a18948cf662297c8cdfb14d9fc8b2744211ec5caa0faaed4767cd06944ce9880b99ce6b410191e80683851325abb4b3b3b697a98ce0ba7d5d933e027ea16ad3c4ff6dc6c47024061c190d0e8e569", "99f8fdd8965e173a56fb358926d95f2d5d25e92a198bff13ee089a7ee0f56ed7d99e4b0e81fd7f16f548cccf763182908f0642264a47f49e593351cebacdfd56f66342a4a3286a90c606960fce20ea02a16d4bdc86ca65cf7bdb719059b12e061ddb8b8ca8b90720336cb6835c687c807062555efd16e937eced4afdedfba6ea3a48f4a80026d5e1fa4b818bca976e940321c14e5066d0b18387299e68a8cb7f6ecd4ee7f9229ab974f525899f7b2c0bd0e1fed242f15f6a8fafcc361944d1fd484b3342607b2478de83842cae50230a14d33819901cc9f78c839d22f36eb66c2ed171fa7f29c8141dbb60cdb8ac0bc19172f375d0bd66b828a20d9050614213", "942ca561d8bd29c84b80e6873c5a8a3c9ef35661520c56d36c40da495c277ba6c8c0bcc0e193b93a6d5fac94fbdbeacd8e1da89632239253909ea1f8af92192c0c21ee8defff804db7d473a614fe87de0d208d610329bff175994782988343d451fcddd4fced6835c016ead4565d45fb9ba9fa25f3caf3eadb806b2c7737fde912fe171a244e501e94e44c1ec1196bcb3156b1e5931043be4927f1f66816845a29aa6accf8009533a410451385de68b9f1dbc594b185776dc8dcb867ce2230f51281cbeaf4eaf00abdd11796adf062484a6a96b84fb76f017199a16364784cf4"],
        ["a8f75d444982e40daf4a12cc2b9905908eb667b7defbc4d9cf73d39daa9fe5e1f1d1c41757bfa963559c7c9f7332166a910125f8beaa8a4608ff36eb3516f961b1d1b51352882bf5cd0f4ac976f4517071cbd4caac00110a35f505a4b5df867c17f1d6437b7227f54dd9bf429c8b058ba63d592aec15184e00591c1452aa73aa2a9b32b83477008a17e308159f50a09f8a49ce1e457caba410186c06fea630fc00e1709c7df7df43ff75a4c18cb880cc201b79adf43a2bd09b3d84ac6b52943943b06a3a0a09df7a21596555a3d954bdb7cd20b1c34428539b18494126d3e8a423e3cb010672f21d746e398335dc70fd452d246bccb0b8988775fda01c734a9b5c7647bfd96e4e631726bfaf7f64df5f9a4c97d4ffafb910b40e240bb3768bdd14dd2e6e1bceee6e0e5538120d351df6c609ae25a57c7cd360cb07264ecdd0a14ab638aaf30507cc9da97761926f4f6eaf813afb671ec0bf879a2dfb49a980335481c96c7ae3c899a661be1fe63eb55ab7ffcac08fa7c77f4eb95f8e8d94cdf6", "a7bf8a3cde4df101a62610732e67de612ff17796775eeeb3839d5e9222e3b227e637be41a4e272554d08f8a32fc7799d90f447d1fbaed3f102f79497f1463b8e05067118b0be9187a8a35de1a7385183d905e8d6c358177ccba6be15477d35283753e4f6a31f37d9b1642344a96babc183af847de753abfd84b06483376f420740749b8a6d4e696de09240273ea15cbd8db98a5ccf975dfdaabb3538cca1aec871aad8b7d5cefbb814836d23048b25af2116f2cd4c008828fcd3fb8c1901838020ab0be2bdbe8bca778d0e806b4774b0121c0479cfe72d0dd97afcf77bca5643313ce8b33965dfd2ba4cccc071a5123f912fc2124e171b7d95260eb34a6eb1b45756aaeda9080858bfd96a1f96b5228f32f43c015f4cd11d1ba5c78f9579ca5c6077dca40b6eba8611c522c997206b8667a07f21d02f7d80f703edd7e98dfed058017dd72e144d8dc7369a7db6b8583680ccfbd12fc61c58a466de86dbceb79b", "82cec7a3eee9356e7c45295a34c7498ca5792d6faab91b8121bf9842f182eaf73e024ff7d21e5ad62090d410352b7d168d912190f3bbe224af477e1ad5ce13b9767d335a2715eecc187b0f5b2c04c8be0fc0d800a8e949a1e3ddb473ca70838457a6134d54fc7b77a27962ee4f274d9b52ea48874ecebe594c8f789c34b416fa66c232cd7001264e3fdaa69e90872418116225e1bdeff3b579c59efb3d8a86e751b19eb3b2fb5cb7f65f40cf0221c2c39cc3a2ad51bc9db6ff0e01b7b7f0eb8410a3521521113c668c3704546de2806ff276743271bebc748408f9752db1a22e38ccf33bd16dbd6b7a00ba77ad0a3525b7946b7fed0c250d2ccca430a134ac4f4353c7e2b4a843cdb3c08fb73a746e04614753569a3f31c0b6bed615942cae7e433f48b02d9d36e683c67de14a516bfaa2d614cf2f6274621382e5af894d576f", "b1ac84ca1c7f75de583d2d1f99fa994d09ef0bab2e902d1f492c05c057fbb459d57cdf82a7a0551efdb2e9695dd5a0d5a497fb83855d1b0fda2bf2e26da447be83432593058f3933bf3bca9ddcfc8b9de810eeb8327967c2b8a544281894e77346ea24805767bad38fa974d33963d40410283f02782718e889b2b24d7b5fded50319024799a2599f91f43164f24ba06d3ca110f3fe86a3f11f05b50405336d0a2e46a250631561adce5c80ebac594f8a376ad80c0ee85754215c4947aa8e5e6748426785886354d51a83c8a6bb94b1d54a24d5ce67ee709e597cce79679917a13154c06bd0874d7ceeeb33dccc26cc8d6f7b9488113f35444a6bd475f37115e051bc26a72c9e480f3bc7ff2f6032cf8d015526164252442578e45b61b55c6cb7", "b317131de29066498cf6d2536936baeda2bd17d0ee61a91afb70fd5d4c21f19a306b42420716f8b6edae4acb3fefb902b3b04b9919f5ed46a79cf9dbb3e69fff362b6e91b53f106748a0f52885fed669dfd780a0a28bceb4d87b46af6cfac63620aca227a24bc3ca83f6398448a8bd61005e1e2511664e2e0a23a7427077e5203cdf9e2f05b4caf8ea2657e5d2adaebb79d80ee21f0a435ba6001670ef6ef68f6bae839633a51133936431e3b8f9130e792167bc0f43ef5d6375650fcbc418d014b88f2d96607b879390cfd18d87914b70c5ee978a80d8685c6bc641ece032d63645cfb0158c1dd6dcb27259981822d0a594bb28f8fb7fc201420f9082190631", "b94d0e34d28cafa1db97e63f69a84c018eaacacf4735f5f3ec48639c06f1220b0fc82282d6659de464ae8d9a97eec3f685aaf1503997500d2523f48a79b90420e0dbae8e2cfa9c4c7cb0d98c0652ce29a7b2803f8897b987095eb07f1383d619264fee75cf56813bbd2d5f7f96ee430c37c3b9137d0e269ec2b9296339ef09b30f9b56e003effb108b19f5f728f1781bec0837b343734ac3a690b879511424ca5a169d9aee7fffab031848c9549920ed82f873bad7d2197eb4fb3593033e341f03fe75128835e20fa6679b063fc105c000eae9ab41bb7ed1a61024604e2edeb6"],
        ["8d18b2605427e4e2626aac8a426e7bcf269eb8647c747e720cd167301d8db857ac4f30bbb7db93d126346adb949f4635812efc8aa3f2f8a9467756050b18d6d207491b0a0b1234e648ea3a6758739d8d8e796ac9078561fa14674027fe0c5b9d0d29e74d13e18b98fc173a8a3d8d1592bdcd2fcca6bcce9631c6cd820862732d5d7eb3adef48caaa21d5c5357fadd93764c2207594134fe46801c6e1d347c0ec23a128dbcf78f17d06736b83998a227cd53cd78b4bd7d411d8cd9bb113524dfe0f92b0adc65eca068b5f4f9a163ce93f8efe626b3017d3835ab7aa5153265f74557aa3d55f343e302df63e89324b5a53ba46429ba476cd67467ee1bc5b3fec9236aafb2e374f4ba58997d1906b87e7d4edae6ca49f789b9327739a3adf3ae675686d36ded98f7352083b09eeee220638da04da43f0c2a9b58a67ef87670dced6582011239faeae765d747f807b4881286800e9426dae35eca395e009be7a41e521197aa37829e57c3bc53885dbb48c9b0951cedef8bad0601fded59127d50434", "a63a0983e406570817f4d2bf2701c2c1cea28c7ae6a3588f2921bd8b0d4e9abde482b7826daef88df1733415490b0617a7dd92783bb39c70781c9e1b9bebc046b2746fb94d8dcac75091b1ab3f7e28e293296a99ca798f4d9d1d81935bd1ce6252a5274caa83d68f37261890cf526440b88a71bb48220ce3e8efce9847f6dabd460248308af48b1038172f65bc77c950e23b09fde030c8c6b43930cfa5ef0403292acf3fc9cd59e1e8d47d6c8d0219d837eabbd3a3db7a761a965a44b843a33f0f139f16a7a5d1e584e62aec2b4c038848b7afc68864abd1bd3addc7ada759eb62ff55f6db3c10d6258e108271b45e0d75153b460cacbc168b477c7566968f4c693eb69f58ad75d4210d7cf4b75793622871e2535e87e637d4cf9a3ce69487ff31157a3b28ee76d7fa635096f10560027276e4097564bd4fbb7d3a6d60d12750301935a0f94c8729553a961466fb756f9ab3a065bc35809a7d7b2582f00ffb4a", "866bcd43a948d4e5e3a88186228d424b8afd5f0aba06eff3b3dbf30d5affb6de41c44acae7180aca8f4f83a734c8c494a011e7e89f272693956955a259dc9f794b27126b5f7a9a5a62e12b00a9aee53aab482dcbf5437ab7f156d9f6355523226a723bc484664a25bdbe851eb03446d11e760b41ce568b25fce5e651e74738093017b2d84f6064dd56f75d0fc92b6f17cc005cc3fe62f07ece2cf51ed717b0a0610f6a3b73e9f5c999482eb2bc5681e4833a4ea7528b7a397805f3a1b6abdab33b528843ddeb6e8f564db5b5f390609331a1bcdb3943d2035228c4b72c843ce121f83461567a09b21ce29b6dfe326ce49295909102c72ee6e2ebeb54d7ac20ee1bf13e68048b98021da6bcb2968d50842ce6ffcbecadfeba03d642d092917cfd72a6861824b45b060a6d56162599d2449a4229dca58a2c7b5c9078cb165f0b09", "b1c604ad4cdf26d6fe6b0f57044b9c572d0f4c46aa7d064f8fbb6f92c6d21d176f08efa4c3b9a0ea902bfdbb804bdc2faa732d6a0f62f20843fd6308d3a406ec7102d61510b4568680abb3a96bbfa1c36f935efb38bc22708c5de16d560de2d929ac129f05aef61b0e1133f588c6e4ff5bf3b0488042f5f494bf847c942d787f3ef7ce15d3597e9b579f550ae5da3dc20885f14ceedf85f9d82c449165f9d81e047ab75e0904519b7cc7fa22d4b7f822e62221fcced0a673ffd65a87d7a8e6531a4d999a40462111151b50862ff97cc0354bf121f3c79de9106f95586799cfbc565332a3a4fa7e431b976f8de59730c06b6bb3842aa70824aab396964151b64b5c8769fac3d518863a8324f4541682f0bcafbab316d792eeb3ebb7bcc8e1e715", "a3ad8b0026c1cd2c644a7b9362bc2ad39cbae0fb7c9010f84bd582dbe6912d948753b5a96dac70993339ae8ec8db2fadadc4873c82b5f6cb0efa8d6000d353208754293a13b28dd629c231d9c6f7a6c2150c486345becacf85294bdf529d7c5b075802fefe17155aa0a6bd01d35703cc7a9ad6742cc6dffbd0cf41a39a3074e945f3ec22c4111e51debee34cdc6fb4d746086785178cedd82f3e793bad0c70526e5dd85c5be382cd6cfeafe717d54143d9e176c47ca1c1d562e6f2567c6b46a2273924bc636d986ddfa6d0bd806ccc40b951e2786700ce4798e42c1a43c3438a6493b342be18e58d7c0b1ef3d5f95c6d1c1da40de14bd795b5e584d4488c0054", "98453af520c9774eddf58e5b5ac312693f594639aacd243e3a2711f49af1cf1b59ee760ecce43a8dfe6db669b1e0fdf5b8cc067b7d3b6f8bacda62119c5327df0b9fbadda51f812d67717312773feeff0956df8c3718405a678e3d37cff8e217027765c3bc0b61166612db199039fe5790d0b8df3574149e671d316fd8b53edb571c103f230d2ff205469c05c527ad0c67d4cf617f0353ccf07f8eec42a3d6420ac51ba3cfe45281568a7e6251361d6cfdbcb1f6527343f022d3bda32e1c75050d47bfe44817b7b015b247dc0272cd7fc12461e1531b43ac9ec951407a96ac9f"],
    ];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFOS[i])
                .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = get_expected_signature(EXPECTED_SIGNATURES[i]);
        assert!(signature
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                &generators,
                &messages
            )
            .unwrap());

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng::<
                _,
                _,
                _,
                Bls12381Shake256CipherSuiteParameter,
            >(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = BTreeMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_msgs,
                    None
                )
                .expect("proof verification failed"));
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test no header and no presentation header proof
#[test]
fn no_presentation_header_proof() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let pk = PublicKey::from(
        &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFO)
            .expect("secret key generation failed"),
    );

    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proof_with_header = ["a9b2867f1fd36ccfdc8222af91587e14154539fc19272898785231b4f884a5e8b799fa8d2ae5b9ddaf362a9ccd528e27aa566534b9d8ec774a5b809334100b64c29d8f63aabbb2592d14467202034be85f7b592be301ef8a3188b0a8a42d63e6340273c34eec2a33eee3c368156ef307f7f24476b7374a861d48729ed5cd019e174982ea4fe6c80174c5006dea1a2de2b6f461937a1d752d8afb57e04871dca56f25a7677f53d9538e66899586c4c214b07b849a177ab61176d5ebb9d3bb0a5542b7a94254ff0718a5c3345377fc2c11b8ce5a0a0f984268b2c112e919a4c9d737c1e9abffe875b8345288c7169b68f142d11948d4be74a831953bc0fe2370876fe4d5a0c55d0676988b8f924765849066258dc86a1e8380bc8e49b31d183f346dd7ef1ac319264c9ab6da23c35a2dd9e672b5d2c32a753976bc306852add9701d6893911a0c45f52542cf0ed04e98522235ee3a1d883195f65fa922c109f784573375a4ba96170c50f52cd0a64f6426a482b2b96049eedff6528173f26c3e10", "88fc6011aca569c60fc99c17ac4bc9d11f18273adb2cbc88b0a2f550463428a9ec4ea2c6b714776c60a3ae1d25842411aabebeffdb442170152409710a5f58ebb61e723261030753b807ec958a37bd0a7b3da7b1b321e06f6ad79653cfb3808c339d1273aac1ceee8c71d3f914d42dbd604982d1d3bc6b283f0300d33ddb4d483099a54fc45f4ce93f6a951f0e088bdd828b03d3d76ffc52afc74ee0a2d5819a29a0e4c1bbaef4aa00c799346caa23f4d9c58c9fb1a8813d4fd3a379298160764f3fdcf461162b27abcfee81f11279cd49f752d75fb52f4eda6d24c9f927fb6817db2ec05f594409a2f9e7356ca233e7d1c28251463629d819b029cb0daa9f2e5dc01576a18defdf705f7b2074a244df418e3e328e4e80f472539fbcd72e733764d240f5b59d9c47fd8de0ff8883505ad29aeb57ca14c5f0bbdf2c32782d62eb13c6d33eebcfb001f09d3cee2b6e1392d69ac257b06c5210711197f9306b54c6", "a2a3b2c6cf047bc68acc24046b1459be0d1c2e681fa420a4849e1bc90a90768ef912c0e7fcdd6df46eb1965d1231dc2781bfc8cbd9b974970b1ca9202e9eceedf99bcc1411351204f471e0a9d1732ac1068ac1bdef1711724491b294a10f5684706f771f8ddcc94577b81437c367a42c8bf2bb5a1649abf1a859340d26d03147502dbd46df0cd62ccac23ed037f153407e1ca7de127bb3432b8a92dad8b0ecec68faee24c5d63ba057f62bf54691ffc4097f1cbbe1ff2b3048255292523fbb9251034e6d958248b5e88c84a11596ca5e4557b72bc59ae6fa5cd7295455081b27656f597d0b2c0489d41fe7a32502a0f7e362554221e264cf00c74fe6ac6edc8e5466b633f5c0e3f7ef6743ce32f25624eb28eecc6643696cc65bd02712a6b9f72feda16db487b208de4b8217479b2659f791b72dcec5d262af07ea00edbf94f1", "82f22929f396d2372749090ed8b81256e92f76a3beafecb65830228802f95b666286709d9839e7e01302f68ad31e68cda17acac11014d19ac4ccc219c3caaa12b7024b8ed2d28eaa2b4dd99f8d1d2bc364c6b862a9530a3a62266960d8a219c350bd0088683477a6df04a403c51c842c44e1a0704ff8d512a042c6b668f8a4452b232bf6256e28b1b4c722e1590014728cf9759e4eec1a8bfaf27eee252a765b3fa84da62cb1b8b7d475d59ec6fa12ca59b49d33adcb5c019bdbdf24915726b4411f73e2d4a765263ace14953236de73770eee59a0d199b3dcc4417b4cd708f6710e14847cafd4466f3b40f9e4e798f26aed420e431e2653032b8a042a5e17e02d88c15c949014612b75cd43ec8e30388044cf69e18bdf91f219ced5cc0710a5", "a3c6bf35a326d28143e693a7c6e684a4cf1915703a7e07fefa91b126fc204263d08c2b5d59da1171dd9edb2c6305173ea648617b002d67a3c580574d60023468f1c186d7ab5c146832c0cc1a6dab66cdaac32a2f951a51e8962d279afe574c442d61b4dbe91d72060d1024c8affd6ec4e56bf900a69101af49d0e32c14cc5b8a545c72edbbb99a9142e50ab2c3dc8e7c8031f186d4b9ed4dbc059d6d7cb434d530bb1ce29c55dd40fad64d670f3b66dc0fdbc27a8a161258a4b7d11e3f5e87453dbbfa39f88838c048d544f89d4a18e7a9a15f0f3df8e7d18231c38a4d1b03281fdd2c53349eb6e43741e45bdc2423e629b68d6b838884c08176590929757f04", "b55abe67cdfe5b40f9c0580faa107861c8e1c5dc7790996aa6a3834fe4f4b0d889ea54def50fbf02d6dfd62b1456b2398928f86f58cdc8f6c6cada7fbbffd1998f68239c1f48684cd5f343680d49f7e04a947f8773a26d7d78232ed99b3acfec133bc39b51d23103836a23e1916563ab5fe79b0867e7a72fce230a47ad4b5791636ae0820d482c0ad1e313f88cd1e785708dae634a5828ec3b444b20927070d6581111cb49a670bcea45e54964bad5063cf298eb9501d36831b48b8c66c9f7441554a1f594f95229f3d578db045bd07b118f2106831f60352b37266ed2e163b0"];
    let expected_proof_no_header = ["8b5753a151be800cfdabdf0a545419a33dbcf6dd19bbcb5e8ffec9462f4b7b8c8e10e56829491193ba981510a874831bb20e5d47ba0555f7c880802f9751aeb371da22e65d7a6f6924e48c8b82e3cd01f7906e2dac3406e23189418ebaebcfda11bcbad20f8848aebd70a56f286d2f56fc284d10ac2a4d6534e1c4dd034c7993669665538e1293b3f60d47135008db3cf4137dd43f40b73842f162b5464303a02b1ced84ec39fcfe649610cb529e9a942d527939c6939f74d2fee9707baf5a490a6ca6aa1cb50d6dde8d225d352703b777bc3916aaad119c9edbd1213f0c60592ec194e78c50e4575dd6b9a2bb621b4e305a1f9615702c4c9cfc24c6bb9a31666a3fbe174ac28b6c715ba9c4c53767f456d62fbf51851ccca2fc543f1040169951f4b047c19a35fba25a265f11ee2f94a18d8247c8177ca3df9b29983626e83f6989eff7e8df1716e276059c74e92769be7fb53ff1f5bd0cc1660193ab2120534e4aeb911d63396f6fa50d77afd58e24dcdc975f025e373606a6375afd49cc93", "a4425fb28f4e389386a13176f9392d61217e393aa4a53dec85d4aa6b7a49f61388d9ac31c023af5280e753e2c4d6f20d82547c2b741f3fa16576f2a9815ccaa72c0d83d66c86d33fa029467af73c91b5c71c036ab163ba5fcac31eb01c8413ad072950c43bd1796590246bcb980cf4474c2d538c26f606002d7ba6b7877fa5e24486aa7db74a676bb9e0157ec8b78b163c9012ddff3bf3e184e46a2bb7c077974efc79bca61a666bdb5117bf2a9d57a08a6a59a5e1b3c43f8baa1208658547db2565aec7210876c09a49f27158243313c5a7fe2a20141cc6e46a1279e8442a0566a2fbe93b8a3047a5c5aa83dd0125e2ba4dd075dea873b2a5deee3b46ebb82772ad456f5a9f04be3b1f5a047fb044fddefebdd29adedd24b5576739679f92e3062da079b87ce78552131c59dcd1bf7995069547967b460ad762e02321fd3da74dfaa77a34e715025c7f5ae622cd1970edb32a1e41f859e5ab3b319ddf5f4a72", "b2e69df35309469d47dd626cf5aebdeeb5eba9a89a409c3cee376f783574552a530f8c87b405e6733b851ea9b4feb761a6a3a9c480c5e842621e436ad46806a28f8132a6b158b6cf6c32b8c3b271015ad8de1fe985434e09aa44949b836f6ebb4d11471b92581030b3258e0cc2c03822b3c86c38527d2e6757c3d6da3c3307c52533ebce379a6569767bb98dc14cd0db7ee16c5c8137a16b161fe0a43e88c463666deb7b591713324939397c215234c68fc6b228d29c5e0728359349e34ce2a8280cf846162c0e48db044183ff92355ea2266e388725c2b7e4dd062137a45fe627067dbe37cb1bbdda4badafd68dacb604a67e4d68adf6146d02c56f1ad257614117d14a169d4d8233a9fd8b9c2eeabb7af5988b811da72e63172d2c3250b7e81e1bef875e77107f8318ae000a4e497f1403c3eecaa49443482f1564cb929a35", "b8bccd080c403a622d57725eb83527623cffebfef25cd167d3601e158058870ca8e92a89569152e60f4f252009d59222a0782daccfa7a55b823dbbf024c02ee95b5900a53f334133e49bb0fde15e3a30b0af037d87074685583d819791a03aa759b90908720aa9beecbb1e2f8907e2f6a7e6c12ffd14005445c6c6cff2c2fd1d6487aac14b7e6877824cb3f06d93fd85a574aa6d8dd830262926651ad23eff75416627383e65e54a5bfb6a631ed9748b9a6fb03ea12464a504b92656a192a2e31919a040e7bdfa5ba528e0c4df040ce0a4a5439f1f1c3294019fff1cc9b715a22b9898222be71d66bdf64c89d04b9611f3168fd86453ff0fffa9ea434a6c26c1592eab482ff79bb01bb67be682c0d718073fbb51f9527c4275220cfde7850340", "8d2a54c313cc9c5cfc90197dc78d35fe8eda9f498013c8369a1338ee6a00bb14ff9975a56d01508b52627b4f75de3fd1b160ced61cded6b21c0bc707446c438b08f876f822d11a69dc0e199a08b39d4283773411eab790d703ec71b2364e5d840d51a46e72f683b24a6fd96b5f8e929db0378ef6905fc3a9376cfff628a42f8b2c4fbedd14042c5a4175fae9ff2c653a3d230808722962520fc521ffc279cd5260cb227bbef9085d1d7eb2704f74b7bd3616708141ef115cb28dbb42942437c854b00e2e6771529ab925a11049be5f2e3b83dbb4dd2869b6f91164e28b23211805054614ee5fa0fc652e4cb32d013f8bac1ca5681d8d14a2868bf82de2226b15", "a997abfbfbf8adad162430cc903a88f28f958fb0f9265c99ef4b668a38dd367f9faa542791cce5794ae81b6092e089e4845d70f34e0b18309b11cd493b869d21b500afe70eac867c0763b342584e112bce24af47f9c706171454b73aca53210d3f4212d7f97b714c1324bdb228bf17a39d1a931354b17e001ba84c9d18aa362335edb97a9a3427d43836fe3d8e8ece2431c9a1681a083a870134c844673a2cf516d1475a3a0644b7e9638875ba90d2c8e17edabc0ada681406fbef4176bc96420a825cb7d280d00ea396cb6d92af71f79148bb0f207c10e42f679c93ad935b41"];

    let mut proof_messages: Vec<ProofMessage> =
        messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

    let signature_with_header = get_expected_signature(EXPECTED_SIGNATURE);
    assert!(signature_with_header
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            Some(TEST_HEADER),
            &generators,
            &messages
        )
        .unwrap());

    let mut proof_values_with_header: Vec<String> = Vec::new();
    let mut proof_values_no_header: Vec<String> = Vec::new();
    for i in 0..proof_messages.len() {
        let signature_no_header =
            get_expected_signature(EXPECTED_SIGNATURE_NO_HEADER);
        assert!(signature_no_header
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                &generators,
                &messages
            )
            .unwrap());

        let mut revealed_messages = BTreeMap::new();
        for (j, proof_msg) in proof_messages.iter().take(i).enumerate() {
            revealed_messages.insert(j, proof_msg.get_message());
        }

        // Proof with header but no presentation header
        let proof_with_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_with_header,
            Some(TEST_HEADER),
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_with_header.to_octets(),
            hex::decode(expected_proof_with_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_with_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                Some(TEST_HEADER),
                None,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap());

        // Proof with no header and no presentation header
        let proof_no_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_no_header,
            None::<&[u8]>,
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_no_header.to_octets(),
            hex::decode(expected_proof_no_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_no_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                None,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap());

        proof_values_with_header
            .push(hex::encode(proof_with_header.to_octets()));
        proof_values_no_header.push(hex::encode(proof_no_header.to_octets()));

        proof_messages[i] = ProofMessage::Revealed(messages[i]);
    }
    // println!("proof values with header = {:?}", proof_values_with_header);
    // println!("proof values with no header = {:?}", proof_values_no_header);
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for (
        (key_pair, header, ph, mut generators, messages),
        failure_debug_message,
    ) in test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature =
            Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.secret_key,
                &key_pair.public_key,
                header,
                &generators,
                messages.clone(),
            )
            .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = BTreeSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            OsRng,
            failure_debug_message,
        );
        assert!(proof
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap_or_else(|_| panic!(
                "proof verification failed - {failure_debug_message}"
            )));

        for i in 0..messages.len() {
            let revealed_indices = (0..i)
                .collect::<Vec<usize>>()
                .iter()
                .cloned()
                .collect::<BTreeSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                OsRng,
                failure_debug_message,
            );
            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &key_pair.public_key,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages,
                    None
                )
                .unwrap_or_else(|_| panic!(
                    "proof verification failed - {failure_debug_message}, \
                     revealed indices {revealed_indices:#?}"
                )));
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<BTreeSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages;
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<BTreeMap<usize, Message>>();

    assert!(proof_all_revealed_messages
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages_same_but_shuffled_indices,
            None
        )
        .expect("proof-verification should not fail"));
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());
    let indices_all_hidden = BTreeSet::<usize>::new();
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert!(!proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .unwrap_or_else(|_| panic!("proof verification failed ")));

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &PublicKey::default(),
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                ph,
                &mut generators,
                &revealed_messages,
                None
            ),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            MemoryCachedGenerators<Bls12381Shake256CipherSuiteParameter>,
            BTreeMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert!(
            !proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages,
                    None
                )
                .unwrap_or_else(|_| panic!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        c,
        r2_hat,
        z_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_bar.to_affine().to_compressed().as_ref(),
        b_bar.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        z_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        c,
        r2_hat,
        z_hat,
        m_hat_list,
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
