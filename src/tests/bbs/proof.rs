use super::{
    create_generators_helper,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURES,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::bls12_381::{
            Message,
            ProofMessage,
            PublicKey,
            SecretKey,
            Signature,
        },
        core::{
            generator::Generators,
            proof::Proof,
            types::{Challenge, FiatShamirProof},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use core::convert::TryFrom;
use ff::Field;
use group::{Curve, Group};
use hashbrown::{HashMap, HashSet};
use rand::{prelude::SliceRandom, thread_rng};
use rand_core::OsRng;

pub(crate) mod test_helper {
    use super::*;
    use hashbrown::HashMap;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &HashSet<usize>,
    ) -> (Vec<ProofMessage>, HashMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: HashMap<usize, Message> = HashMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    pub(crate) fn proof_gen<T, R>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &Generators,
        messages: &Vec<Message>,
        revealed_indices: &HashSet<usize>,
        mut rng: R,
        failure_debug_message: &str,
    ) -> (Proof, HashMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng(
            pk,
            signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
            &mut rng,
        )
        .expect(&format!(
            "proof generation failed - {failure_debug_message}"
        ));

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let mut proof = Proof::default();
    proof.m_hat_list = vec![
        FiatShamirProof(Scalar::zero()),
        FiatShamirProof(Scalar::one()),
    ];

    assert_eq!(format!("{:?}", proof), "Proof { A_prime: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, D: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), e_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r3_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), s_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A': 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, D: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), e^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r3^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), s^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(&bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        &messages,
    )
    .expect("signing failed");
    assert_eq!(
        signature
            .verify(&key_pair.public_key, header, &generators, &messages)
            .expect("verification failed"),
        true
    );

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        &mut OsRng,
        "proof gen failed",
    );
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("proof verification failed"),
        true
    );

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert_eq!(
        proof_deserialized
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("roundtrip deserialized proof verification failed"),
        true
    );
}

#[test]
fn gen_verify_different_key_pairs() {
    use rand::SeedableRng;
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["8e3d9fc410126ccb56c36bcd83dbb3a824e5737fab19b0dcd722a726a7066eecdb7b1ba32f9a37cf4b99c5cc6c369058a6d07b71e46fbdcdc14a19c54635b5596c459dd2d48b606bd6763e60ccd8daef592bf17a198e7c74fc656a771e3cc840b1777c2474773bbf07807dbeeffadd3838154642b8b546324e92d72c016388fbb73a2c6d54727e774367dfb038fc681335db7cd3ef8508fc7c10e549aa4c0568694f6312a10845757d22db76ba81810e2f1b59741c43be8977cbaea6d5eda3186a10113784b18bb10aab713178649d6631759cae30dac094741011ceeee7d308b23be8f221ec5b703ec95a64ffdb874a3892e7831d67cb884c83e4482e672644ac45a8cd3192cfe168ec53ee0a6035da4448818f2fd0e50c377aa33c24c92ed30a65a85f91dca3db53f57c27ed29b8fd14e117e47962bee0ffb7af58d6a7d56cfa48b524e5e7b4cb74a1c6d0d4a57c862250f806ed5329af08c2f4dd09513f2cec36b2cf04d48d6377dddba88aea5b46607b83f79f3b29bce28ef5e2b7b2cb44c6bb27907016356e0f6c9142fe01f64520b56073e42754fe9f38f8b89f2f396902cad94719eae56dd231e6d1f2d1e2d235c5ed87de760dbd28b0cc51e349c33c0674c614c5741f860125c8bc0c3b94f1063f02380d9c5b0ace23108e8f74462ce1d1ed082154b2fb2ecb28213acca13f", "954a96e797209ef41c050a8edc6fa69ec5d1864a54bda099ab32a65785e1a8a7b6c553103b3e7cd236a2a47ff6b2b1adb4a889892c84fedf00653f0750a7abf54ff00ff7544793935fd859c7bef4faa50e715f0416511369b47c368567179e2694f39ce0abb2127fe1be46bcdf9df0d2c470bfc37693fde2b41a80e0258865697c110a0f1f76448a380832c763e6ae3c3410dba10adc4f52bb742287ad4e7786f77cc6cb011a2c0795921ab23cf15a47427647d22cf01abb45743e5adda35296ce095a60196f8f6e9c37e55eccabe8173c7d66deb8452d893c5730c058fbb9afd574f32d6d473b4060db0d3481cc5170112504d1dfc5c1fb2afabe16e3c6e3fa78418644a2b2b83626094efd14fe95dc0ad1b335a9f967bb03d46c9bb930a73ebd689ca236305e5998f642129c1e99df0aa0ade434a6e949293f3f17e092638deebd448baa7fdd9d21ce47783e710f89416899879b0ddb1da1dd7b90cb22d03af6830de7de1662ca3cd741579bd7282f53d188a36041315f62ca05b1e0028a81972208207d2d932ab8a7a1ef9b2ed54c001ae5966c990cee4a5bef02153c6ecdc1577ffbb3d0fad0a8b69e76f702908d5017b4ee00050d11069c8f5e73de0834a3db70b31926036e835fe8e30ebad539", "b62426f0ce04ef906a78f9f25b0f9d17a8e20e54b453753e54a5ec3a0b0874fa3ebb5192764b66937a8dc4ea15c399c6b9c65e1042106258b4e019946d9bf0343e37edb1ad70abfae62e131043e0f0f12988b0b2b11441637897fce3dc9aa422b076f374ea7e970e472a2b31b75a6664a16b9b76f8511563d0aa8a1b174eedda7ccbcb0fbd02a1fc74b43d795902a30800dda9c755415efda42167adc97847db3001a192881b45a3f94faea7e5a45a445f6ac2cbffe612be253fbc2c9309ac2e5175083d64d17d8c0ace2c963d7870696b6ce0e7f49248c56c3c9ac8971abea2c5f63e89f4faff7e8cbac9793aa486b613ebf1795977dbe9721f07f0e371fc975af1a5da8055bb83233f4168abba2571484db90f7abedf7e1983680851b6585a829564c42e946801208541f906596a75385c9f033f47a30ac9218272b5cf136fbcef84bcc5aaa40a03c1859197009f826326ff9bc8a8621ae16858db871849606297ad88e549b472f80c81737c415f003b09c939cb90bb1711445c1026166f87c235fad502377ec67ecd3e9b9993ea5602d591e639680eb9e43777eb8063d11686a6ed78facaaaf34d612e8edac40e01", "a68db492406f8ea71fbfa7c13ac267fe57169f5c52123b24e3fabd78a463218a857c512f32fafa853f5f1703c2de73c98428cad8fa0eaa0fce0cbd48886790f249b5828e66bea787b33a68ed243c3488beaf4e2224c27cae166028f2230d9a4b8ba0c6bda9c224fad3de9e709b191c8d3d457b0ad00bcd023fbaaaae1f925fdd280fe290835e2fb3f5362c38b246bc1c6b314f11faf0e5f4ccbcb7725f63077f27ca62b53430036182bd81c3f8ae9f6904ccfa1045db465a0b2d3b9e63ac8a3b62b80310942ae11c5602fcc83569436d5c3bc7dbdf5d64a0f61976ff148cb0e3a2a69ab1baf04f97d3711ce5256e0cfe0128f78e4cc9452eccf00900f7be8a4dee3ef4b31852d275255f0e40548f607007f54b15e62597042d28e3a1620c37b827850d1e396495d697339eb75863150e0000ea5c28c66eedd0cecb8b0658ab280178f4a4cd3a05aa4dab81eff47965684d7446b4649324eeaa5709f5c289ece0dead0c85f0c3fa97a826a362e535947c33ff51d9af2bdc0a11238c6b9fc93a5c5746a6a58fb1f63e413bfe17655e0774", "a7b04a28014e8c7ba8a7cf6e6e5440e728cd3b0a2195bc410a9a4b6ef6af593887f922a8991da8073a93292f9c87969da479290559bbafcb715f41b124bc37a1f250d45612506c9d28a0f01ff91f4ab030820736e8facf45fb0f2ca2fd4ca1d2a00aa32bd26bb0ad659c381b277b0f73d390eb75da6e2ea2172a3c2c9e7c608eb5936b836eb75a0de92ee92f7825ecbc6c87727c03ee5aa0d8a9c49480dbd7fbc6e61fd739f9825c1253fd5b11b3ead744f6398afb496e638cef12026090a098f150c9dc0581e97ccb0d43b569fddfd434bc4056dff6f5a89b15a6c4f0ef0ade33821ce93b4a9bf0250638e98af9f5cd485a43c47ddfc50f7dc857760f579b5460526a41378d9a841f7ba336403775750f6cbcfbb02bb21bef07388c8a0940bd8f0c898bb722ee2d7a5d01c2a26d6d5b3db25659f444c618924f1a11fac4cce002064793b36a21b7716963be99ed8b3b6585b06751c0862fb66dc726f71144121f301db0a7ab5fc2b05f4d5e620bc95d", "92d4eb0252d93d3ac21c6825b3894ae71aa23a4ca521f35993c68f4303cd30ca3a3f455c77eb47c714321b105051e89ab65bde139bdf73f5ce25278d489927671963049a35af5d2767c347c92489355ae77401b258af0394d750b53fec19fa90b4ea1d4f6d2360fa21ed3b1baa8e98272379a1d7d99b503ba45cbbd575b640887b9db3194abbd7f06032863af227c1616614c103a52a13f6a7ea4676fcf0cf9dd2e6ef5cc115056e91ca2741d64bf15370a6be83906a1b32110845e1e99174f77ba7d179ca5f0e5b13effd43cd9dbade52e570274f50e0675f4887acee5d66c643c8ce64fc4240392c6fda0490a0b16549c7cee7ad8ac41b0fe37a1b6eabe4a3660b0d538d0b803db0b63bd7f3fa836840c8748817e858630f9140375bec34ace57db795240c0263b44037d986eee1cc120e1800a7f639262f348fc8837ecddb1375d5907c89075ebac39500b304712f"],
        ["8b7052f6a564a59da5f8709bffd07507b3878efdaed3ba42916426ac8310b82f4c588c339423a95a9905d3cc3c3594a3b49d66ec09a0ec133ebd0036253a14c761a3cbddb741667067849fa70b08c32f19982ec947cd97bc8aaca37624592189b8e175c05d3ecc15cc7bfe4365ab98c39d7028547ab6687622e41d4c6e2065dca33c9dbffb7cbc2b97e9ff5d42b0471f1a27ca143790f57f91664b696e148b41d41449e5d7366753d98abcbc7a8df74413b476d7e0809f79ab0c31d3ab6e5f252b4609c718ddee3dd37446983e16efa44b41873b5a5aa1712f5fbb93e8bd4012cde70bdb60959a5fc9a27964be71324415c2c66f7458f7deb747a6347673b12b61339a85769e442ec9c0d06b90818b502cadef05a510845b562c31a23fe5b2d4574b5a7bbefc82204cae400622964a18375d99094277d34c7d9ac2753ba15dab4c1c5ed252470002b7979edf11042972162be3e4340c52bf8ac5574bca4ae9725670a26a74996325dbfd1a17ec7fcbc5494049f40552d127748012b1edf13f9dc744905fad6f29194b5ac544ff1b05e772234b8f699d61a5672216f61fa94a0c186c2feb199971785e210b84039f9be72d0b2272d134a30010cfcb23624106dc3a261306dd210334c5c4920d2ea200f50bdddbf54b9dad53178a57f138e890d1c9554f0834f3aaf6f3fd1b5193b52842", "9333d3cad608b808e29bb13993722729e27232c679bade51a7d4117d46eca0762a947d6c6547f0001f9e661910eb9d19ae162f68cc04190e89bc6b9d5f2e20dde984608a8308cc7bb0bf9e22960777e9827a6b404c21e8711fae28f44f2989b5a096836bc325d0e8782f7c0d9665f353a6e704f8fd10b0adda558be4502c64e69707114445a9a312477e8b7a3d9117a715cfd2a21e82fd8fcd99ec8092da916e32a260e111ebaed51b45be46fdda21696108140850463c4fa84cac13121bd1e8da3eb5a9cf1b43ecc22ca7e3ca1107ff033f7f9751b4c8fd119fc82c0425d96ddd353b2e6f9088d22a79124ad43e22bd587ab02998d932edc40f2e38171857721a1222c676f5a00c1dfa68305116e83b011007fbce9252fb47cf9daa4e371e8c1edfeebee3e1b55695f6cbc408f54cc459b1e0f404c66488e96fcaf3a219e5c191a3f042140c16984e9794941e669e2b3fc3906aadeb5a6ba499cda01324f935c9ac20154407c746251274fa57af6640380d7749ba66f557c30f2cb84b3cc223935f72e6fe83dc5120da45cf508c22cb23f3cfee17dd1083390f5f524286b6334b95ac57a84c52c0ba338f5b94acf99240fe73cbbb7acaca24cbb705e5713dd09a7ee6a83405adf770f9d1bcb81abb0d", "8b643590ef55dfcf4112a6c15a811408c90f55fe12618907e393abf9f74e31415af8cf74c4a91da972874cc3dea674ca944067df534e04e0e10a83794aa91c7d44e353941be71c72d4fda15be81ca55c785b3e2bad063fad9034c5270350b16587390f7028b0aae757388ada95d8529b68d44d37873fad376a3cc2789167df8133b243a740ab9749be7c77676e7c269d2fc410cae5acb1f29106eeb4dd3b6053b6f6e99e736e10349ee6c98013507cfb00cb0198f878d64d6e85e4b08347087bb4df5ac6b7f0a781660d84224b7d7e236a8ba37bc41d72519293b9e3400ef023ce04a6907e67aa2c1b6b18add990f1123844411289b1044176e05e21f80855d6b98093ca11c489f824c09fe08e5d0ae00a2f0680a93b485a7a59bbbfecd9ba8909d60d05375e68bcf098cb5563961d33215c8efefd25ab14430ae94cba5d9f8e2b7390d40ae6b1ddbebfc2fb6ed2b4023d5f7342b531c835845f9317723354322f7494ad9d06333249afcf8df081fac036a059d6edb2b882c9380ed44c640f685edaa6034405a3b54afc787690fc38256047a5948a8b5eb887a78303990696ec5924fe31a2096a4c544ecb07abf89325", "8456a8f88bfd006f3ea43defeac27b9a1d8ce3e9823eb80b53b2d24feaac8f9a0b37a603d98b5090d2edf69241cdf1d695c4813a1b09837693cd244db712c0c08b95a50fafb562f7cfeac7b5b9ce7397bcdba9e5de26c96c8dfcd9f8be89071c84ea4c63276df69cf00d69404c581d9cb1e522c2956442dd133e641aec7c76c7efa0ffa27995711502f6aa96b5a52d09053d0c2fd494a474d04656ea850a40a6d23b0728a51f45f0fd0f46a7d2f75518628c063938b7dc81b5407b5e770a7cf949258ae35cea329d53bec888a0d24be972cfc32373942f78d0f2f0bc2e96fab41af75a7d3fbe72df7fe51ceb7433f2f768ba0651eef3fdc75307d570febd6fde9d9595b96ec7e85c15a81da38b932b61480e2d0d404c757180ecddd050cf717bb38645bce00ae4dcf6808baf019e678732195a24aacdb9cfa453e241c0451d095f33e00d5a2fdc40240a7fc4910ca70505efdc0af4e3edc835983586e8bff8958b1cc9504d1e731186ea257f1d2facdb30d3a814dbb4ac2830963f0e6fe3da540c238687c70f2efa2e7d345c75d6ba86", "89e6f3d46d167bacb937c92bdca9e66cf0e83d77c34eda10b188266a5a1c471b054f133ca7e9f644eeb08d285a07d1eab24e7a18c676116d658fb6964cc3f792a616bd5147d5b2840e3944a6ac73f5804b153206516e8d18bfe2970a4b8dd38e905291d043c6756d275942f5a71849895dfdfd5de4c0f5971c036894d233a61bc18c94b78a728604d65c38d391e7e37a24e2bb6e4d7d520e66bd08ce36724d80c70861783ecf62be9d488a85cc90fa954f897627e6c58a465b4139a3f100a56037f972c85bf950e59b5bf0deeddd792f57b7c8ed2e607438018ce75816cbba7c562576caecc00257fed7d77dbf389ef237261d800efc5ef17955166cdc5f31ea2a145a519ab2812687a40aeb046aa91b61f86e05bdc2204f60905fa0e2423fe548c592c6750ec979e0c80331111f66e942eadc82a928ec4932b65661d1f7e4b08597af539ac44c0d79a6a7166ea38c8a07147c2f70d4d86b609ef4d225b23ac49ae57cdddd979a79784b02f0dab9e971", "84b52ac39e160b43abd785661df937ab545c90d6c8256ed8c204a3ba02ce520875f433d9ad115b76bcda58398c9d8ef7b0237ff23f93c4c29c23c93320d9cd1353c23a2abee92b0b9f1f20ce7f21c09e32905f5aa9764b8068dddb27ba82712da46be7f2e609482c60c5e76bd4520e5398beb5f4a2f4b8191c5b5ed2b0a5ade4d52dd3f208902ffa077e6bf523ffa34d0c0fe16cc837471a12b656046995261529d5c1026bee2015b90bdd0a6c78fd0849614f14ae4cc2a33afc4d6cc714de134af7269507ed912211b50c63edcd727c56c84a75bbdbd407d0ea3be8e59e2f3e8ad7cebb699501e38daecbe03b388ba441e7991980906df77ed32e4d8343f62977c420a8f53f5b766a0384ce56aba69d5ea00776780d1c8fd355c05881e3403c97b4a74209559cfc8e3043b664f44cf12fe1c2226678bd9ba481e8e4a87729a0b6a1fa284b80609f98b16c81533009dd"],
        ["b58bdbf4cbb17c4cef07d55815d473ff652cea71c2235ce4480f072127ecc0757707f169578941f08ac1689cadfb11a4886b8132ef3a19f2854aedc50d0413a1b5e9c87ede87781670d6c7432677c849db6d2a6958ab578f612264b5e8670fb69850d49a26e68331e4b5bbd0f2ded7161c6d315e516182e8f0f0cc83d71eadd373014d76d734db4aa92e6c46220ea66e4f6b7e2c20cda31f9277b4f89d168bef09f4a735228550b90b24221808cd05a11ecf980a22a8a2cfc14b4a839ccd9374150be9cdd1b7ec4e7cc9c6f4aca1e309506e4d4c674a43fc3825871198fe0359a15b4329aba46d83d4abe9115014e21744f81932953385bad1be8d506789975327cd326625b6595597511e39e866af7c6324829c3cdc0fe04a2e4007c643872d07938a2f99e726f9216a170700f5d2a0246961bb143f4ee6cc46af3c284ff54bbb10000dcfabd12d3370be00f94bbe101f0da8020790d44fa6451c2f6c66c70deb9413b269e37b6596acdc7b0e2994171e8494a6aa3b8b3ddcce6e3bf5a62ebb1f1daf3243d1b937835c659e520e8b1500a20f2970adcb100bb15e076c517c4c4e7eab6f19157c8a5e9c1634f73b824137c5635b236d8afccff2491d96d5ed5851c4c652c8d81a05bf00aa5b1199b58031e4813473d1c0251a761010c3f7b5e6de6d79d9e85c79c6db63a8bf37b91169", "907733874a68d98aba6d4dfdd9b250528c9569359a9087b6ed97b2e7a776418256f79d1f466e86bfefbb4bb0091b00b8b09237fa549f985d26ee0298087e35c56f05ea30262c6f176634e295204a9c173e56a3f1b31a616052879f0b25067600b85417678e268920841ac0dd9f1955a5d0bf2ef838efd11e896c417b0fa4f347a7697ca7de7266b65506d31cf0de216811e2eaf7da6bcaa530c922f28eeef811361781f5cdf38f38df798e8017fb3392728b0c0dc4cfe5582c84c595f133459a8f1b93abffc03c3634909ef5e0cf81fc3c4f6fc8ef30f73f5069f4415b1a93851ad361ee19c0b8a25e8200a70cb72d4144851c68e0a81141c2de20d5a4bcd64694d63958854909d0417b0c141798b8aa50f3009cde7f510e2a1874923cc879a82f8a0cac02ed6a29b18a913b0e53736f696b293b5d251ced2f36a526201a3606014d369028207617a62190c5c7549bb25703b08c9b1f08ad4c7b5c19142da583856cec5650e935bc018a61c3804cb14537a397ec6ecaf37fa53b6d94b2742b9033170dbf0a083f6cb4afec6adb0dc3f2621fa01cd1c3beb5167888d576d780ad2b205c1ce8234bc9b5ba4e55b65f98e5299aaef5832d648cee9b68df8385b09dab7e6356aeb9d2d179725826cfd50ae1", "90e4c74743acc3594623ba8d820bb9a89bee3b0f7e17ffc899dbbcd030e2afef1095dd2a52e844ace055e25252fb6afea319c2fa2406e22c2267ab3c418ef8642fb6ea7f82e9743c947f1da1153fae32d0af1d565d242970d14f96ce1272d4b6b955b1f7cba1ae05709d3b3c03f443ce53b02f59ff6b62cb9a75ec6f8bc1869d2a6c63158f8dfb0a7fdcabd9d19718c2285a818afa1317196e65f7904851cf37e75da802143a47e289ba41a3f7c3a9032b14bdec754c7515cbc6f000880bef5886a5b68a323ee8fb20c83e97c460bdaf00f76dde0f448cbaab618bd8ba9a78a5fc50868c6b7b00336f17f0c0c69633f95854dda3433e92d4fc14518fab9e3b08c608b5c3fbaf600d5491b797b4fb081e47306a261f0a1ec9b8b84553ac39c65b963e48cfa426b3921dfd19bbae445d624b78045d516103691ca7325f2edf5dc05506217418238130f966b652676a4d2a030fb5e14b303284f06464f7facb9e99acb72993f1b4ffbe071b2841fd32ad920e314355d0868422f26245a593a769f130a8fd82abbfae323b7fce9e2c1bf46e37d2be9c1707d77207ffc60e424a4c3b1c51acdbfd1fd8826eb129eca050f76f", "831bf5986158748275fe74adfc2f160fd922f326d4a821e20437a4ba39ba218daae939987a937f1db16fe9d2748f6a8f89d2c1335a444645816777e3e43c4d244b564b7bea578092683a3430d64b9268040aff984c0de26e52037e577a915d31b9d2dded68e8b493c6c48ababa13d35de82c6ad702d804629abac67e6f7b9c2d737290e4315dc757a6fec45c9c2dc5485ff74164522313ad2bb41d0b44c8937a679221f5f756edd20e3230ac2e9b97652a789ac0b082e3624de2f71809402a3deb350efd5f1867b21b164616527f9d2126bccfe0b5459e972834e28539254c910791c91441f50b99e45e1a9207197023287f63bef2efb7ed4380fe8bab12fa4440a9fa21cde9ad8dff633b8f169d47180fa933a9af04c92128e519ca185a48bee9ae449f6f9852120497bda0ba023cff4f4113f1d92dd1fd50393d5e2cbd9ab1cbb5b89f35141b2804f780f80f87df461ed676835957e2158c2e85e153aec3938aa22cdd8ba49512fd7e37ff5806f42c0588bb5368eddff2c1bd2b4a5cf9f54cc44e6e623337327b2d8d55dfa2d19e24", "8091297b69c62dd7256d9c7f1c0aba58c410cf989847475501a50271bb820193319c3a4771d6bd3125a854448efd1bb584083193114fee28e8a60990aa5789a99ce968b288229b673064d6729af91918669583ba7d02791146813c5b30d59cdea01f93febccb2cee05e9a2ddce9d7d68b11ed49071e7da98f56809896e234c8c97a2d2f18ab2cff10bbc24770cf004a66d814d58554d25d25c090e25b70ebd387ced9ce3a0a9d51791a64d158ef5ef35292f52dffb7202a838deeaa5dc4b3395096f40869b653b17c02206a98d594d0d3aa7c338a11c0dee9b8335bc180f4585404e0d292d9c20811e1a0e9500087e041e96476fe0de49b63fb42f84d0241d3590fb048314061c46364de8a9a9b3a5dc56e59e6f2506e6c0eb8bf149874a16b9e098c64f5fe85bcdaad131e2fce2418b6bb9295f79b50b33afb144669248d7a24b793276d720e92633330ca5ed5d44642beeee8d2ba1ebde5e931c778b728b6a3d49cb8360f09f4a47f8d842f5e4bf70", "abf2c96fc77b78172c5fcad073c213d3b59c336584911d3d6a969be2dde1d5fee4068d552c1d90a093b68b982dbc2e55b71de2361efd038fd4f764dd41a1b61f05c84439eb14382ae35fab19d208209c6dd38bec498ad4eb007c1018babe486f82a19b90be584fc388485eb8aedb741e09d9ce7e20a734fcbc0650f38c178a072a36a66075b7ba95d325e7dfbe0087175477d6dff36185343ab024702e1b78b96a15df9ee33c21546d43bebfaded105610240bbf66ba17e2627a5d3b6d9da24e5cea62aa015a25f8ca6733ca60c00ca636efb2e6c3c251b707a66b25f37848d1d1250f00c36bdf2c797b30d01a36997d3d07a213a6dd3dd06bb3577236daa4d632f493410ee8f15c3cf01db05ca0df745f745357e4ffc87defa6f972b989ce7d9049e4525276bcbce38d4ba79598c0c6382acc5b1e4c94bcd4d8050682a12731e481f62fae940929a358fbe07e73abe6"],
        ["b2ae1be1ef084c1775a55bd483f2305135040f44b79be28f01d4a182d0703867d29a043fecce59fd36d893b8ba0746cfb688d5386b949b8f31d21c99e414d071883866fc529aa2c5c853b433bc522775376552b2500e1d03e5c6a61cb7b999ccae2544cb0f21c5e83f48c21be8821f00b0bb7996aa69db6380fcd1c6993898558baa3e2108d8fba9a69f2129d13be5970a84c95d99d04286f932325532f20a5647aec806f7f425f2cd31db2417ce23f5519d69ed2199246168daba7f81fa2b52c4e26f3f49cb74f86fefbc6f046fc3426535bd406cd475890171eb630c537eb3c1dfc29ae006311afe9526004ab297cb5201911c6ec3a744b247082157f109704b493a748b7b2b82d33fd826d826f4b36be1716cd704bcd789611e638fedd68c45ce9eecd7fba3b2c2d26f4e6de218ec0f624cc1f63d0bbd3bf3912e11b8aedc2bed85ff5807f2c9177ef96369de1af915385629b770b9ce72ae6a6f38bb40a64ab9ca1091be0b0566c58b70115b98e75c867973e2ec2367f4c8bfae5de04e98eb4c8d1dd46b14ea7d2b30d8ba750ec737db39ff161f219147d32fb8edbc45f8bb781add5a094752e38162fe7da6bab41da575d9a6e80194a3c6fc94138806040a7774085a2062ecd163c2d5a4f9758c50fb5f62ad25fcec807fbc270481979dcfe1e3dbc6e8dc53202143b94f62f651", "ae5ca21cc26f31d8bf9cb2dac8d84e2a3625f0c317d3a950edbfab60aa188b61aa4fbc3bd582f65fe7154c778cc2c7088ff12d48d989a359595023af41f76f9fbd4b5fc50ed6594bf667bef9331823c7ee7e856ee7c6550785d7503659986f038ba678e6c5ad4d3890cbd3c06208bf16dc31b9db57d3b14a765bd0444032ed5b5d587e57a6361f9ea632d0f65ad0d8cc09d37af6d1526aea85543479a88df930ba3e44d2f419581294ce72f7cea29c57121bdcc1dfdd27286dc265ea1da9b01e0f365668e89a550d6870e94d68cdbd3a671b837cbd09b2dd404e98fea2f85134c65c35c4b184aba936b0e12f96d718d16b3cca902c7b0f0975b5a8dcffc1f38e9f449978844257b1a7893c04755b4fc54f1621864e1f9d94fba96896b3aec279dc6cc0bd6c704ac88e5dd157367e0a06732ab27e2fc2babe161f8228d4e025d8f1bd85c0a0523876f4df26af7cc2a055648ba21cf49f478310dbc498df237833a704196fa2b3a3d05bc6ca2a7b98e82f46a459d41ffafc4798bf7de2506546622e1b8cf207b7160c81f5f8257fde058f2d2a496f20849a607bd5be84d7458ae71e43b83744eacb4039523ab17f9d5d421b775eed87f16712c44c64b2c0b0eaf0724355382a873f67b9dae0515985ee03", "8e2795fd903aa992abd4c7d2b2f63d7ed6626f681cd5de1edb25f70bb7582a9a1045eb401c599d729357ef65f4bf9a9caf5eacb7b1be0beecc6af841de9154558cd9414e257868245bd2e089a7402b32fefe2944eca6514dbc0e583aea7e8df4963e5515092fb648c4ca6800ddbe9597cad6fabe971912faac7529379b9c61b3e4b0b73283d617fe703acdf676917c0f58fb10d3a3711055dd3f9397c5477fc3c383b900f1416d108143348b7bc9f4bf270c776c90a4a4555921d2851bcd0d3c292804d3c02b6d1b4af582214346c7492c3287a7a74d771c9de109a880a896ec4a14a1106d8269050dbfe066424980a15100f13be90d808cacba9d9f2905e11d915df8b405d595dcefa932f091ad38a726c57115ba5a0b26ffc068773e623b5fd813fdb315076b2f7f541b13eb89cc316042665378aec5c81d821e0729301e411ee384a4f797232c1670ff059281ac8820c7a8849c4a802ef023328e903dbbb28786e7e9d9242db66ac598ef329bc2c813a196d946429dfbe312ba6ff6af9705c447a7a7005abff6f8e09c039bd0c92f6be3a8475a3344e9d920819db6ca60a155b4ddfdc4657221b6ea11d18b569208", "90756c426f99f7d1c8a6065947957150ebdd4703118b11ca1965ee789338d4a78ee119b800026b84493cd50c70b22449a106ad0b97a24cc46ee64cd7797d416b224950c44e702140496bd95d46169a2e5dc35d696586e124fd936f6ac9651d12a1ed4a0d5d9f2afc7ffd681706567c4384d853e776932869d25f1c756f9334dfafe62f06c747a7a49e97588dd4dc6f61552cd96302da9594b3e45adb09e4862121e0a1aaa66d4221590b674de42e6c8e48b6ba1925fe55d25f0ff408bd7ad530bda1b189124f650c31e9dae1d3a8e89318615b266043a58964d8477983b5ce9d9a3e3fe031e68d2ccc5b00a1a5823ea046fe40246064c80755022eae846f71458ecd295b0b2175600b52c8fe2f33036c44c5ad81603b09417907dd7cf0cb13b89316ca2b4d0e4dff32ff6bb1a538e8216ec34eeba4bd1b7b7e8564e957bd8eb0955b6eb44900c1e687b90db1bdeb5e413c77a27011ce1ac142e37fae0637aa3ac4455c066b6e08a3911a749c86d2b4652857bdf542fe84bf78ce86ced0f00a7cf1ca6ad738aceaf8406541e6471ac332", "94afe929f551315bc58657be96f505af6a37cee4f6f47f0f49ee5aaf174ec7b1a739d7a51b03122e4462031a6eac281b8d88898b3eebf8ec9efad632741bcde1de4631c4e34a4e915940902805972ae5ba9fa718a6d4040203da2fb40442dbacb07808a2bad33868671d42af47dfac365bffc5567925efdfe4e7fa0596ac53c3739e78c2b8697d8700bc065f2a1f68b0286141f1e6178b60815b003d050e16c0de3d0755faca759d3ce53672a67e687b1f9be6aeb132f817cc52eb5bb2e500cb7b2eb646aabfb87dbfb385921892b0856a5630b848dc6513ae6230a934e09209f8d002bc4eebd1e25a9cbc39e0b83d2043a4a58f62de4c4a12aca7a1ca6cc1808a67fa1667cdd929d1b2c998c06dcae9422bcd1cd1cf7b4012511a3c68a321db1c72f1cef98678342d678230ad95e1394504d05b9d5f3dfc2c42319919401007a91b25ae29c8136797e22697ac4669781052ded9b0ee87cc82ff0eeec72d9d157eb47abc572f0069e14499c7de17a82b", "996428b5c3eca793cf32809e35f23666252e5c924e1f7b3c8979bb9dc2f77bc3ed9b85c3f55cef2fae17f3531958fba186b58817e591b821a63058fdf44fc9dca7233cde633abd1ccb5d09a8a8fbc0dce410623c9d846dbdacf6366faccbf555890a462457223ce156c8c6072090c10a7a230fa0bfad7c4d6b3363bee091219299c28320bb48f6d74669dd2129f8f75e061fd8c5cc31f0f72cbaaeb146e84c6285074e0091700a81e178ade4e272207f3ab7374edf0ff5b7e1f74fb51447f23b6934b0a8d00a714e3d5f5891b5e92efb47cfd5b53b2f9c565c5312e0c120f6cba43399b6739ba4c111cc264fc18b14e7135bebd62305de4838172e19ec7874e88132c01404ac203b253f88357e40328c6c4110dc23edf1fe19614567307736f4352ee8c6ca04c3f4f2afe439162bc40962614c654cf51b1681d62533294f6eb5059040103f94fd12dcb944fc7a16a713"],
        ["9598e7c5d9c50d3ff5fb3740d947c6ee53188cf481778f6e4d432af52aabc428db15dd847175fed8f190f85a03356892824c50dec975134ec2553119e566f6514245fa6a7e9aac7739da4de09f9b822f57cca8cb441552f3233acb231249b21ab39a0a4661155728f81b639a875ad1544ce6a441e73024f5f48e259ff706831264554cb97d4850bbc915cfd3cec02141134518796067e06d665a02a56342e8b570a8476d2cc8998620bd855305a068d569ed1a0f61a1fa0713bad899292fd64771c237a698da16316b26ac78f3a688472dfea63728c59663e8173f7449b88b8e1be0ed86b8ed454e479b63e7dc51ba4630af6af7942220cd56013a7aaae53386e202fad03c507165a583a9230e39aecf4a87b8cf7f1cc136fc10a9abe3cf9b4f2f020798675c162f20145baf9a5cee8819b79864b8f40a244a2f7cc67a508493b6e468a6c549f379df16ebbb916eb2610ff8eeb1c034faef07f8469441eb36df6116dd7b958f3fefe273180beab5e49f619ba304c931545eb85a4f54df25360b5ae443ad8480ebf3e9924931fdacbd970031a20dab283fa3b1d0c2a9d99e79e452a4b731c19655389b0d7fe8553d38715d23732558a983a2d2ddff627e7aa073e222baad745555a98ca8b2ef46c8ace64be1b9320efb1f9f43591d1e1b6c2fc04df110529d899d3d6b0108371afbcf67", "b25e786cf212972996e50bca7e7526651dce2a3264ed80437907998c2458c165843b46f63ed2de397f7aacb24723c4f796403e1a55bbc87c2373692e24b25379a031e4ef0ec4f4a277ad02a7f494b9cc3d71067e594eee7c4dd1a251fc5c1c258b831719f460d68231ad2704cf551593d76f17e5605421809550743bea3d7c40c02a9410af1d4ee8bcf922b85fbbefb740a777508bb57194638bd5f168306c84ba1ade591ec9bdd4b1750505e05192ae56467febd1e8cd5d054b09a130cdf0989704f82edd2af61ee7a1e4a60ecb2e9e1687fe879d6fef03e534792478825cae18e20c6d8176b59e8e8f33bdcfc37c213e85b53e92fe82dbb6d1ccf07357b0f61907e05714a10f5ef1450dd2938b5f9a354fdd6895bcf2df9327095f2b2629db1f4df1fdea32565d3d297d9c43504cd1376c992400f28106c2c01f1bf95e232f0d4317567d1e520a92f7d333006a6acc170da366c9943f7d9fe639834fccd46f78f3f5171df71a624178760b8f3409860da7921128736ca26975052bf1e30ca819891957f37efdb9e9af354448815c7f4816383545c228b2888de16a70df0fece0efbab9d0f96b2002dc63acb7a328f348bb03f364c35a4bf8172437e8e76986b5b069de1b48c088d8d60b09279366a2", "b84a9c4cb51a839fd89c0ea6589e368aa82dd7f35bf1f519e84679c0f3a6576c01898b4e1cd0032bd727b6265ff32d87b137acda70b953e016445194ab3f701d857e9207e1a2a8925c8bbfb259b360e5157caf6884a26abd46c9a8f80101eb348c7ecaab4045bb8726ff7582fcb505b1c3b0f71916709e5a2b37b691049d97bc52c7e34acd5bfdebb605f2f52f58e58d1f0e4aa4eda400b6f343d45a8ad392ff7281fa794517192a2ff1d198379406795e7c6398b78ff6e8e45a59a4806a33b2dffd5e9e109d8db6627b8e060bcdae7b121c410ba4afbe5f65753b5187a125da7e9a115d5d832cedf61b9d080f66cff644e9fad0179ca962a519d85d7bff0c8077197555464cf85272dbb002523144671a652cfdd252f827ee77ab30fd5e0b00da52e575993609cc89e1ea6ff529638540db5a8d097c6a0bc6a6afa5a4864e6fae667b07d0337264904fb466c939cb6a3b7390070b55e7764398c674fdecd2075932784f740024f2b7fa7d7c99147b3f051d176acda9a742ee089b3cbf7dd27834fb11f75417f8a18ca9be9744ea33e14cc407d7c80793e048d4ebac4289b6b1f25997788e10bae9682b7717997f7bcd", "8482f4fdb355ade9c651dc533f5ca0c7ad57a3ae7eb98c980616f22ccf56a26baa352a97d9b59519cdbbd3abec319644b72b5445cf29202b7ddc2e4779079ba2336ec979db95b2c9592984548351d99460c5cb9c8477f2341d6830e99dbc04b2aac5055c6501c69d300d7dd9903a161e5a8dedb93dbedd62f37005fdaf26d0a9fa69edebfe7e2bc226cc24e3855bb0696ec86efdf99cd5d2371e4a6b67c6a3b58055b3cd1d9373f1436760af91d394af64c89ea63fa22b31e1cd615f5b096300a6d8ed8ca0868214d25f99a2011dd6240f979790700646711d4af8e991837f46bcc50fb053c2982c7ad344e9277149472f8e65d0c0f7e99f9ef34c416cb5c818bd73742525dc5207419e820bea5224895aaf0fa2d9eb392c101ddbdd37f2a1ebe5e69ca81109115bca89b5d64470e21b01e3ad9d371b2e55631353536c1f758dc719caf1aaffefb1ce16aaee224ab96909d83084ad2e2a6451c49e0c6a47881e7c096db986b17c1c4780e93b70d466f30f002d0faf7d3226d9a4ae40f9beee920a4b857b872d56d4a5c2e0c967278538", "a48d7f71f4c4f86046892e0998acc5fba837ee4db1819a2448a3e6e22fd63c16ead169acb73a0d9330015307a7a5f6e589b0922c234452c8492eb71650aef128b2fa264083323f8d575c2611b8b065ae18742ce636db40a9b13490a36fed3f01814e1b08ce376c9d211c460ff6555e6f0828518547f7be36173c90f7da3bd0241383ef73128e1c703d7a95d586fafff91672e5859ae835a94e77a96b10c97f605a9bcf3fbcc42be9fb38b57f5ea468091b3f4005a17342b8a9676fc11482856b032005b112cfeb2672507b25d28052e55e5cb02de66e55e6445d46a638d372bcefe62f8c1ae0d1db3fff41ff765ae51f5e0ebf55fee644c1db505034d69756e628c75ee26acaf46cdc7897b417fe4c9218f436ca78b4fd54f0a505fa4277d60284884c81d619b4bfcf31d00662de05e84f0b008b66b134e52f87cf5cf633148452c6c0a767015c88c6e99139c658797a2dac2b334a4615154f25baee5146b580fe69256903dc03822c250a0fd2067aac", "a69966cfd1bbd9ff42d3bf0bbcebeb5c23063d0d59b75ba9bce1a1a6eae7403607abedb9549a824dcdf7412d81a520619035ec82ef5f05b912ec70e7f041ef4c4ac13cd9d9af8603b98d1315cac6c994d4d5f5eb00eb42ea766d78df8875ffbd8eee25774e9001c3157c8be8f70ce9e94a36128c5e60f873e5c1052c1dca37a76341055b34ad8700681dd48c06b904a539220fc995f76d8542eb66ed8ec1b44414d709015991d9ae65ebc46ac51bc2e15cf1bf2d09d99f9071f942cd4f3ccd6160408e75160a8cf889c05682ec82a7c01063a3d78665d0908216f93a58b166e8187c42358e338edc339ff22fef37aa8448bdc4a0d4730b5a623cd053330f1b7102c69d3bff4bd7f9ea64b6131a51150918d19319f6bbd3062d5e7126d44c7e623e9279931b99524a426d1a215a6161640b0b3253ab0961c61a2de8707b9e454f4cc727920f705fd07c19d42c6e792b3c"],
        ["86978b0486907df3ceb6b16f3bb27a189f18aa66940caede5b088ad2e659cf23dbe0efc13d0c2f3a356226775408c34391e0a08d77dddd81077506da24fdeee3bccbe02ab25c4edbc8d3fc033ea6d2d7b29a46f00fa5415c01b0fb19217bffb8831ff1039765405244fe0a714a5494f6ed5916ff57965998cd5b30956dac3d61dd724b438b425d14a53ccd79eeb646a76e58a49c65f71a69f462a96675370ec91601491e18dd30ceb40c130aaaaa55790ef6338dc8e48d4495851e9e600829102a00cfc5166c09a79476a919dbe5183944e637fc49c8786c59014328f1b2127766c03fedbaf7231bc058250f9074287b19d055935a6f480de7fef9bcee5193dbe432b634b9a0f1b980ed23d60de519a001dc292fab292508fca39a4e5165ce5a9b61fcc4e05ca66a1c44acfec676098a334b9c7619072d308987919feb2f0e4aeda7e922ed4cd05f1b10654486af7c854ca27b7b36b8ce8ddb04b3c5febe94d534ca2ec87d67bc764d8c2f0bf54456d60742213cec4611afb3fc547603f4f5f03a44f12b73a5b8f243d2af8cd92438966bcc8ae54164f34c69fc476b95036d630dc9e5315324300277153be3118ebe9514ff27bad363c8d8df01082b8d3aae8e40650c1f1620bf82ddf11e42df6a8bd62b47628c80bd33a3c6f982e54f5988876eb6d81801f1b78d9d2bd908f5bb02ad", "96cd4c878fa1cb0561e5a58abd52e503351ad37cd0171d367587768d06539b9f58e0d008c65a2f78280d6a8fb2d98dfcb1a6081f07da70868fe9d38e17a304182be53577e1a1cf461e6d909f38b41178c096754b52a52c2c829383e8982c227296d23aeaded061c5ec26b75ddfa6e7741d15df22056f2e8530e0e87632b93f1fbb98087a68f5666ce7df8e3016a328b072aec154b77f0b2c3961c9e4e744d4f229c33208c2c3f9c59406b208527ee5ed71feed25be806ab6d03f50ea2ef5c6c7ba56aac88ce50bde6fc86952195ec3541aabd93ba22e21e93f03bcaaa956487e9b42cef075eb2d7b948e570d5514d7ed697ee10e7788ee6db2b6d7d55db506bc22c3ebe7fce5d9d60e6662a55cd88b1c0233b475229382bcdfc54a359c4c7588c6df3da04466bb345553d25fd87e4dc335917c6182400fccf4e8941a09df261ce704ac2f5595c0d5f339ed72f13ddc1b2a0cf3a608b35f2fee90e5be739b24186ca2589975ea8e261bb9945ab761abf52c3426fedffd7b96cb611a3f0050ee8b15c53d74429bea1d9ae809fe76c6c00d0d3ffce517229713895a86d67b67f509101196ceb822f2cc149a6588c57f1ef7661fd95fff8dddb37a6ea92e784783c3b3ed8b1b1b66b753c8d99aa0d7f47f9e", "93481f2c6934f76ba8282cb6a4ddbfeefb59ddf58088f253629bd62cd97ed167797c6d03a99b4fad4ad1bac51bbe0f4e8ddf1a0315c093711f71a02d84fe494420b1a0afe94b3b40db2f6a438d46c1496d6dc2ba9eca1bd6f05cfe412c42470eb69678289ec83b32f94e054c7436559fac8a8b7d86b2566bad998cca86eccd414e87bc99d4844efbec47d3ed8c414ed70636e9871623c75526e274e536b8c4c83d15eee7b9cbca28c5cdc96deae642901ec991b23d6f9e05786dcf91e3697cf14beb1f1b5b2c8a0868cb029b596d243a5629b7e476e2a1cb77370277206289d1e31a18d7dd45634a44908004721d68361709a4a86aff98abccd417eb146e2f84e9ab4573bc09529ac710df5aea102b7f0c158d1b15410e3e76d6354a6543665f8d2414fe605867debd787c10a8587da645754f37b50a5f6e3e9db5ead851810c354a1db6b48f9638ae43d45316f926d74877d9e5b79ae2a77d450aada63a8ab1265be6ef983110a7bd64327b44bed6676d71b6c8cba0abaf7479887db2e7d2f9d2cde7e0eaced3b517bfcd60189704c10b5f763db4efb55804fa2e9e551833a8b1c60603260f64feb87fdf40395dd38f", "801a616a262bf01afebe3eec4d8ca3c27ae8e4f140145d43e936147f0ea5437ca2f6db278e336eb47271e40c4dc3f7be85cb2618288de4a99d31f7db7535c6280e5cc93a0bb287e8b53dc428e0cca420de4c2eb73a1f4314a97427141c56ec108b62522a285f80625bff7a18eb63aa08033c0b4f3ab22853b9da6fc415cae4bd5a2e3aa407010e4d6a958d18e572df6a3d1911e3294d6418443a0c151d8f524afd122293eb28458ec61148ca1687cf761429879a0efae17617334a460f7ab5b38765ee5323fbf5a779bda63d8d3ec93172751e20470b2afd9232f8cb3d1d536742e4e3cc9f76310b719aa3fcfca2d84148fa887739c20fd6914ada62b87a158d5edb5746495ea8865753722b51902e23065c827ce813fb6760ccd21f8035658494a85bcfa705fa9f8506cd91b2611db05039c3abae87edc71743f50bdb78f8fbe9cafc2855782d99f73f8dcf9c9ca6e433f6fbb5a568437fa51356d05ec3de6e5d290088c0d00a63aadcf091cc65def7147b54dafb2bf0f9510f5a30548a96fc4c27b0691e2c77b804c6322c9f7848d0", "b7920b115a4b31e5ebb41fead014393d1feeed78b48b93480240042b17adab0862c70f5cca4922917a186b96c3ef872289c610bbc2fe8df2e3ea9462b333a4337a9208827e9246238c84cac2b17afc2e4352d9efab3eafb871e581b4dca3f4c19533612d3d03cd717ff8cfc78cf38cd3f3e61249da28e9237207842f146eb51ef31bd26277ebd7af183a633d1ac021535c17e25c030e7681a6e0e96f2c5e3df8f5e42c7dd05edc09d18f1816e33529284fc7f20825ae2a36edf1f26f95094e8543ee5f9d79a156365a7219c41d0283d0325447f36e7055e6bcd4e5920f12c78c94d84482046515b0b005981fb377457f4580d347c0dff2035b4b3727d1dd2423e45c0eb3ef0bffc417b80aa301808cff05b98bdab261a629a95f6d3cb15c3a92d03f14769032560f8408bd51917d4e886c6cfdb0ed3ed2a2debf2ec3ece1909868d2df6865097aeaeab3eacd2d8d999371f8e042ccdba1446f0d559180c43a1224fccc2bc2c74fff1534d8b1a9e37305", "95dbab10bce9326038b9a8fb9586bbac067671f6935fa6fa10e66dbe446ce2433b1694e4621d6c6464ff4020d098491a8eeb6fbd5d7f0eb76e88c93b1339dc9e4a83720ded0f4e848c29411b7af293de1ceb7cf09728974013dd2c1bf4abdfd3af0a15fb78c9003412d8128783c94c01b7542d1cb6c499fb3341c59aa1460fa8f504c1698518505f5743e0921ba5be09072a033f548c05c0cda180363abd1d44592469e058e85ae9441c363bc34b85f66d7c88f3989d1f5affd1bbed8be6179a58dbd7804b39f348388940799d407066378598861eb98f3ee83f91696a50e4bb95cf52ad4c7e62cdd12ee498e53c52575ca254702bc054db8fb6def7d527fc329783b9a6030f401187094660ba0d771d566d41a028bf1ea2f416a85b8c02831b2d2164d13d3d53d087e10727f25c5964737d21910102d5251ba896193f850f41c2fba09fce1150ae6df993c2e1b8b673"],
        ["a54a301cc24e7fc6a8a96f72712df9f7b1b862db8602aa133004c4d88bc0f6a8bc769602570c9738f9195737095a6a88a259c27e7b631cf99ce498a3263a66d1290c3ab0878733cfa31b34c52666e586606f4c6ead79387842e32e3fab36fe4b96b5f3101fe93871792c857db7429f714c02942b4a7c694604cec1db16ed171f7f0bf1c37436bb97f42fd20b48df71ce5038a3672d9f80d7a1c277d28ad20fe761b3b6118a2294f391ff6fa58b05c9c03ee530727a12bb16cfaa63ab0acdfb04b65b06371e43c5000a2a39beb28ac9912df899883bb135f2b14a6330b4877abe9a247dfcf4d9c69e7245612769d15bb0714423b6b79a72fb23f70809f7e4cdb4e6ceea384487fd8907592213ec4a0e286c133256eb5d6fa803186f5ec8923aa037cfb0ef67668b54c7580aa6f7fe4352366030db4595839e3032203021c7e59b606e036f375ad634a2f438f46ca1de6c06b43cff1cb93b36ce26b0879bf5f296d3af6df30bb747db9362331e44ae5e0472844d8b3456c88b5f1fbcc85de168814b57124987111c738d68252204b2a5833f364c9a538a2a263580e5aa3fd0e58f6c2b8b599967e1cec0dca0409d7f469b6ca3a5b3a811f7f2027d8270c172638269e8782514a1cb6c95b5c294a895853a3b16fd608e3910469bd38c9130f67cc89161a8fff408c18e7ed6773a78a7d6b5", "a89fa0683fd1091f7d5a0f2ad9f9f2790817b408f911843350135cd3c335877cacc400bfc9e780adda6a13b3ca38b2c08d91eab672902fad4c65a87b73e5b8ed1b5d9c60ca41e0259bfc7ce1d57245921bc7f5a89f916ac1fd46b96d41324f71909e58da6ce27fa6d9c99caf99a4cfe311e1c81cab41527e206f0e31d5d66cab85ed4afe6bd1227d82ec0fb3eaa1db652dd6b033969ae5080f9d6cc55f1360ae90d21d00d2ce558f4af6efd879edc24a4f9b5952248a56e6fb7a74e3cf563bd199e34ffe7f63da061161b901cc4d4946123d6b5f71c791d46a89e0cdfc3bc78e8b62641e5602e48e2cb1c8d789e7a238671cb740482d5c0b4b405090df45d2ff1ea51533f0ce92faaf180e3770b2186b3c1db1d5a51acc40931338d055fc1028c46a159229312f5c5fe78135cd047fc455ee404923b94505fb8380e247cb9d2b89e7170fd77df73ce5962bf98524bf3b2a5fc71da8f40c2a97cf591a8aaf547fa19cd286ee91b1c2834afb8f541b732e388e9a55547a7cefc25fbc4e181e3ba52131e3b16d0134784236621d150cad4a3d5ec9657f9ce5d5d1b5bc5cae96f1e6fbda3141c7595767de7431027cff99541bf8c3d6222132e4aec0ce0ead3eae9976d9341e4790063f9a87c022af83f606", "b83a05a357c7db4de2adc79912a1ab135f1f6b5e1f292caede59488712c8011243611d2b6a7dc3c0f4c057af2339b1c89327bc17f86799659e78d67e52dc6043682d8c83c13860f68455f3b68866d9f4425b144da09a1532f80fe28c4c17ef288266036cc2bfc3bd76c5aa86d735a045608c517f2329d546cb6deb477f252882fdf0c6dffecb5aa3ecd67272f02eaaec2dd593aaaf74097c33893d170afa4a1b8ce239fbf510f7c2d40ac462eb3f71b801025f077b113a9c502fd513765642a9304ebda68a9d14fb98d9c04f2df12ddf2a0d237c03ff837181f26edc229b81fa14fa72d0460aa8f312738622eed60e97384811eaee3ad9f0fd3be72d8ffc6e0e774575e1a9ab3a0e8b4dbaab1e691631423b2f762863f799b797d7568043f30bfaa238015b7e377c00766919bf5ef7102b1203c1e81874f4f8ca07ba984e88075b380fb6fc1ce8ca0a2d43edb9b6c69648a3cf5dc2d9e60acaa355eeefc3501405f564bc768b5fd34801f076c0de88833f1736a6c4bd70fdd3b73cbd6c845bd46bc3f9c3ae6db77ed72e065acdab39c36451f0e888e251a9189ddc2f13c2cc27db8140da96e66dd38884362d09d7654b", "ac1efac10fd128bbcbf6b30e6af3163ea5331e1450bffaac782e6a83e17356fa3226ba12744b14dba37d9f5fdca3a575a9916479e9ba1a787c659e260e549cbbf2586e4de6f9ff8bd828310c7fe86fbc75e82c540ba25df1108acbc64bf44110b1eb215c4801523e56a136546a1b9584c70435f3dcc9e459dfce417813a48a4f7edb0ed6ec0d517587303f101ada35732d9b68f2760a1efda04b238d03e66dc994378cd79219150c17c44e4b8fb0549246b758fb7604fc6ad5b02921dacb814343ef723209cd07df9ec16e7c2ad41f145e3b94f25bdf50a5e75b268053a9bcfe9c4b19095c30c75f95343d13409c326113690d86cc032d829b29b4050147a88b98539955a4492244e565aefaacc7c50f348b6df393d0bdff6ff2223513226e7abef735543d1fa5b3941e1577b8e486fb12db0e6d73bb648e879d16d955abdbdf189660ed3eabf8600fdb0ac776defa3730dfc911fe532fb3210629dcd4f6b1a028d72feb36304180d9ba100edc14c37f14e6a251551a7239f29f51e49b334d5237ec917821238df7404ec6402aebda8a", "98be82a470009e9665313e275398584ee0d60f2dfe78d0c289a8d24d36c72e1a53b037174dd5dff4c44e1e1eaae794baa41795afb452bf887d5c824c7cb4bac26fd9c3e4ee48891be8621c3b60a212e9368e80bbe4a5a38f4eff80224deda28b9668b74653e171d9d3eeb05ed985a28c68ac1c4bf8fc9dc0f946b42b30d66037e5ad108953471a6708f01c163a749fa440ce793ff963bf8b594691e07f6f38795aa550712ae92fd6c14b0111e01677dc62e9ace28185362e3649620f7e33bc49dc5bf392e2377ee335d02e83a805487a43fddb74e83769b2bc3d35c504c49042106b26b7c4b328b7167e1030d18d3ca8051fc3dab6cbaafe431bbcb0b563200790eef769a3939ddf443250bce5bad1e2041cdde1464ed788d69abd95ba9667b488a605e1862852e1d2bf70427173923822832c09e10eceec88503849be9586fb9d67abb07ed1bc36e0537f3ce041e5305f59bcfea1aa46c4908f51e3fbd02ae9639360b5e3420a2e6198ebb29c08d7ce", "8d1cc48dcb76ef41eaedd62c9455561d900f5433f86ff276b0c229a96392377227e94abc3913b19a353364dd63e6fdd789364d008de541af874511db6d6437405828d245a56fbd9c8232c04751410ea483aee90676b0caf3272f8e8a26313e42b8769625b21745cba4bd612a46c35773059d7fc025d40bb0c6a180ceff8abb4c94bf800ce07197db4fa6cc867bf4c4f723549778cbb595975527f8dff9db23fe9b2d69fb4eae041c6612d1876de29baf465636f589f0d831d7f010dadba4e9570154738c6c090f72f36f75f7aa18784e074a8cbf4c87293e4da23c867aae93b5ceb43c7a1680f1170b4dfd0742cfa0d86ae10cf85652bfc63e600d2dba3e73580b2ae12a0511309c2a490958beaf173e4651ee34bd921ff337a9f0a699e095b48d8b0784926aa4ea20f2e3c675210c3a1f417f63bfc16e27a31e292904ee354742f12536eabea9b99ba0512c5e251804"],
];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(
                TEST_KEY_GEN_IKM.as_ref(),
                TEST_KEY_INFOS[i].as_ref(),
            )
            .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = Signature::from_octets(
            &<[u8; Signature::SIZE_BYTES]>::try_from(
                hex::decode(EXPECTED_SIGNATURES[i])
                    .expect("hex decoding failed"),
            )
            .expect("data conversion failed"),
        )
        .expect("signature deserialization failed");
        assert_eq!(
            signature
                .verify(&pk, header, &generators, &messages)
                .unwrap(),
            true
        );

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = HashMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert_eq!(
                proof
                    .verify(&pk, header, ph, &generators, &revealed_msgs)
                    .expect("proof verification failed"),
                true
            );
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            &mut OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            &mut OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for ((key_pair, header, ph, generators, messages), failure_debug_message) in
        test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature = Signature::new(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = HashSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            &mut OsRng,
            failure_debug_message,
        );
        assert_eq!(
            proof
                .verify(
                    &key_pair.public_key,
                    header,
                    ph,
                    &generators,
                    &revealed_messages
                )
                .expect(&format!(
                    "proof verification failed - {failure_debug_message}"
                )),
            true
        );

        for i in 0..messages.len() {
            let revealed_indices =
                [0, i].iter().cloned().collect::<HashSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                &mut OsRng,
                failure_debug_message,
            );
            assert_eq!(
                proof
                    .verify(
                        &key_pair.public_key,
                        header,
                        ph,
                        &generators,
                        &revealed_messages
                    )
                    .expect(&format!(
                        "proof verification failed - {failure_debug_message}, \
                         revealed indices {revealed_indices:#?}"
                    )),
                true
            );
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<HashSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        &mut OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages.clone();
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<HashMap<usize, Message>>();

    assert_eq!(
        proof_all_revealed_messages
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages_same_but_shuffled_indices
            )
            .expect("proof-verification should not fail"),
        true
    );
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());
    let indices_all_hidden = HashSet::<usize>::new();
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        &mut OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect(&format!("proof verification failed ")),
        false
    );

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify(
            &PublicKey::default(),
            header,
            ph,
            &generators,
            &revealed_messages
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify(&pk, header, ph, &generators, &revealed_messages),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            Generators,
            HashMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert_eq!(
            proof
                .verify(&pk, header, ph, &generators, &revealed_messages)
                .expect(&format!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            false,
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_prime.to_affine().to_compressed().as_ref(),
        a_bar.to_affine().to_compressed().as_ref(),
        d.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        e_hat.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        r3_hat.0.to_bytes_be().as_ref(),
        s_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
