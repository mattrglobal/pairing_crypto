use super::{
    create_generators_helper,
    get_expected_signature,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURE,
    EXPECTED_SIGNATURES,
    EXPECTED_SIGNATURE_NO_HEADER,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFO,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::{
            bls12_381::{get_proof_size, PublicKey, SecretKey},
            bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        },
        core::{
            generator::memory_cached_generator::MemoryCachedGenerators,
            proof::Proof,
            signature::Signature,
            types::{Challenge, FiatShamirProof, Message, ProofMessage},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use ff::Field;
use group::{Curve, Group};
use rand::{prelude::SliceRandom, thread_rng, SeedableRng};
use rand_core::OsRng;
use std::collections::{BTreeMap, BTreeSet};

pub(crate) mod test_helper {
    use crate::bbs::{
        ciphersuites::bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        core::{
            generator::Generators,
            types::{Message, ProofMessage},
        },
    };

    use super::*;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
    ) -> (Vec<ProofMessage>, BTreeMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: BTreeMap<usize, Message> = BTreeMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn proof_gen<T, R, G>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &G,
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
        rng: R,
        failure_debug_message: &str,
    ) -> (Proof, BTreeMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
        G: Generators,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng::<
            T,
            R,
            G,
            Bls12381Shake256CipherSuiteParameter,
        >(
            pk,
            signature,
            header,
            ph,
            generators,
            proof_messages.as_slice(),
            rng,
        )
        .unwrap_or_else(|_| {
            panic!("proof generation failed - {failure_debug_message}")
        });

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let proof = Proof {
        m_hat_list: vec![
            FiatShamirProof(Scalar::zero()),
            FiatShamirProof(Scalar::one()),
        ],
        ..Default::default()
    };

    assert_eq!(format!("{:?}", proof), "Proof { A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, B_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), z_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))], c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)) }");
    assert_eq!(format!("{}", proof), "Proof(A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, B_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), z^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ], c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000))");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let mut generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("signing failed");
    assert!(signature
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("verification failed"));

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        OsRng,
        "proof gen failed",
    );
    assert!(proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages
        )
        .expect("proof verification failed"));

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert!(proof_deserialized
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages
        )
        .expect("roundtrip deserialized proof verification failed"));
}

#[test]
fn proof_size() {
    assert_eq!(192, get_proof_size(0));
    assert_eq!(224, get_proof_size(1));
    assert_eq!(256, get_proof_size(2));
    assert_eq!(288, get_proof_size(3));
}

#[test]
fn gen_verify_different_key_pairs() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["9954ad83cb9cea6a67d0dfcfdbc13e355f9870fb84dbfefb406f962b252f0acddad2681093f76938529e6e54765b093f93641109086f58df704d62a160a21a09b9934ba4ffe7a38c148d211242a4670b0f642296bc04422e330519830412f0702328476dc3b1fbc58d4ae4abc4acd040506629bb02dfe8e2f96ba9a3d1b306612e930c744583377cdd8d218565cdee89ec102be9dd17ab5002bce9f95f948aa91abd37d14a13da0dbc6490060de98e38a4acd03a2795d78b097eb9e247421da1582ea8ac31d36b3da46f09d6716118712cd0fa38d88104e6e84242761a3a34f73abc4f84b648c068bf1e1fd387500220c1363975af4856b5b5d73a90e62e6b7c5bab61b2d9e749fddb6cc0a933bf54b2d1c001ff458a5443e199134ebd41cbe245bf37c3b12a586ee15693f9bea45e5e7d98656748df99e1b8ed2ced0d47bb276dab30c9f3b8913b34757baf600c5303dae4a7de4b0a1bec07da5fd3b577540213f317c0fb2b64e810a51f531b73fa8555c2d735fbd5c10a78ddf4464822918b", "ac9379e8cd2966c0fa65555c1c3c51f22c5b9e88fc279944ad392ade6e1142c56c57115e3e33ce63716874fe85ff27bc936f9b053244fa08e7bea34d127206e2f80d10ba4e24ed925bfd9de8a88d1e7d9bb895029247dbd785469027b3993259116d5c05083a0470c4541956cf494a1a9fdc12a389a3347a53bc05411c41413766f4614e6260e496039ae4766086be5ee04feec922acc11a64208f32914892234c86911562e8d2212777c28c55553be37cfe77e92bc2529db28e621e1f6a84b41afdef674b61954e0cce23a81aec36b2dce9f9c30029c5c84db8ca2dae64b310343d7fd14a456a1ddd8440d0fea07c73aea3d0bc8faf24a1b96581ece1fbd9342bd2d5098a79e43e2b8451b14d735c1ee3949f06f77caac4a0c8368f557d88214a75e2c7327cbf1b2bbcc40acf9bdb46dcaa8224923d5e3f85a252b41e9884646010a5949e3a9879da06e6270ea5e1d240b30316fca7f3d94d757477c7237a85", "843e3c0a488ba88e8553d218346d1efa7423d6dcd9d1216ef63f77a810a9938f694782f47712ccdc00136057bf25e78290e3b7988d247a20293946b3be28db49cb44c90ebfaffb7aeadef289dc7fdc390144b8e1d1d99474014375972d01a90f3f70b1d0347209ac9a50073b570bd383959a48126cb2c1cdcaab127d20fd88aa2345b73aba726219ceb68d211189165351728c6a07cad19af105847b9b88c80f4d7611ba5811ee716e2bc2e643c12990966f6107f5403f010826e24c218beea14f79a04d0df3d1137bda91f98700a14875525d9fb086c48e5528747dc183241c39051ea56ba34f5c6da98e07b60b2e8d2f00374236fb8c339f5f71a9cdf76bfc20bfb672cd8951b7642691bbfa51bc415c98e376e61056385ab43810e8dbfc9c21fac2c133179cf971891a1469e20a3b821e6e11d6225b753310e0949497d68a", "95693a822b0f3105f253c1278fee8d60322037bae9bce4598a8e1c318beda8bda7e6c46ddeeaa27d1e63490da2a065fa86bd555e78e1589379c4d5b8bb484d46caaa22ba0d3c1ffb756633e1be78022ac9516dbff9231a18b651fd4e536db1285cb50a8ab74a34d695519d4ba1040f95a03f2aa6ce00e31af7a7a7b72bc2f78963de3cdc43d050fb8a50f92c3d4fc816c8c3ef515beec8921bc554e03712c69902b63549885cd202de947b4d2d977479cfc5b2eea6b417f99c32f2bab83995681b52146361644626f131dbcf4362dffad3d4145737b7ad442f52022a9885c5e663c23689693018f0a0f5f399763b60db4f950be3fd9aabee08fd0c6ad34b57aa06b668aa21f52dc9dd01ad6b69038ee6fc59451395f40ae823ee5107a695fec6", "af0a61716fca78ae26d022b6e369b2fefaf9b4d92133687d27c52d3c58e00bd32d848556669dcd28140be4de27aa2b59b612636decbd549a17a3c8187a1e1ff8212769035a1fcd83a006196a50db6b8dfd278fb543802022f60413fde96044f52b4490b7c70759e4fc7e7a633881df2ed638d0500efcf29c57d36fd805362a392a46ad96963442a28a02cddcb7d993e4a2a8e9620ccffc52b8105a9f0da8e8e565e0244f97e7100fef68f2745e3e30010d26c162e1dab9a8743224fca31f412209e8cde39e295c52b34513096389ee0dca08fa1fda12381dd24061e6ae6f939d45a4bb224f31d183264ebab67cf50b7f9a2328008b64271b5313498803f7e93e", "b0ea6b5c83bd7da2de70968142e7df182d115b860513004aadb7b951bdc3417d26a43291f79159fd40cae9717d23eb54ac5252dbf59bbad98b5261ba55a00830d48212d4658c121659a2e0eb6bb2d6326a864c7f0215bf9b72a52508c59c6a7e4a96a74fc9b7860df562854ee9765b71e6bc8d7e17b74954a3edfea16ffd9f626465991e2ed2701b99e4e8d943dd105edf967bf83ab71cf5059de94d7b3db2d85d817fa98f30887a36c42a96af47299b107ede334807606c6e817591668293966748da48274e02c1f6d8e69915f3291cb9a68e8a7bbb773a374b6f28af5e81e9"],
        ["b76529ad2701f095cef4ffcec6ab329a620dda7be04697f864214480151f3a0c36180a5c4dab695b67dd2e37ea09412782f6bd32d796199e27a3460ea3933603d9ae4465b4818b70272a5acce2696509caed073320ad35665f293affcc5ff9916f490cd51d14014d0b6ccd54dd81063b0c07cd10732fda16c970fd9b8c1a746412f94e4a5cd51b6dee46a4e1151c9f6caa617b41778d60c9f4952a299313ebc83b5a3f6b37e295e6800ce5080a36a5e6e98862b8f85b4d246c04c26928e1c7f5092ac64c30f703d63ddc950e5003ce9c0ff7eb3c2fa83ad3ee65b1cc800f3d9e143ac6fb8c4ef0272e80a2731810a731c425ac051b2c28040246fde72491a049724eef90ab39928db7d3aa965205be9f80b3d903c88d85da6420b4db8f74a7350cf26b9ec50abc8994ba209e99f5f8daa42d4ec83ced64d6c51716def38420973bdc38c404729daee0f2ca3e18261e59e63edae388e263b3da1294a2415fd09a1bc0aca501558dbe6b40077836fc9570eea9ad1e2dce42e3b718e1ffea6f1c75", "83b4e3d189c8824a952670429d2569b63c0ecd18e855fe3652139a21833ecf791b8e03f8e4f89abe99b8522a14179b03b2c9dfaf51567e591066b210b5cea65d53f5230ed4b8fba887f0c82315bcdfb5fe20e0d73984e8f22cc5cfe130909d5027ae20ec62bd438e25b06b4d4d34c7ac2a22b986a44da095cea9fdbf7f507ec159194a16640be9c0bcbf87c8c2dc163686558da002aec637c825222f035a82c324e2287a8142b8c39c189f4fa8527daa1d0029af10ef0aa6eaf598b61c53324d6b1a69373e7cf6adefc18a70c630f4685b1626e57d0ec8ebe41adafda8e9582d1357b5651242f5ee86c2787a83d06097cf93f399ea944f4993b73b07561dd15f70daea9103e4674ff51e348aea82547563fb79c183e8f68db8a80bc1a67c34cd486da15d16b17a5e2a4932b28a0318d1714d9f195b7e30d7af8834eb0d75f6c65c38d2806760aa8ba6c5f9a2ae01ed0f867262c195227545c66440cc55d7192a", "a0b03114b842809bc5c709ddf5ca76046b0d35bdfb3a9d4b4ef9e9b68f6af955f3477b68f25cf5c656ef522d1e39a99b9998da95e8b251ce9a9b8d013dce15c3c50c3cef4faf8688fae1ac581a7a151b1bf8d2438356e37cd75422ca8aefa3ca34f357148fe2743dae9526bf0ccfe1e23f14ab269f29beec7c7fb27a89faf48471e940d952978d92ac863caed5b6cec84bc3ce6c31a1538a65285d364b576da549abb90f161ca03252ee038ab5a48965f5f0a06cfc0c76479fbbdc887be62cb91a773dfcd3dfef7b099af709aed2d3209ef8eaf9ed409c23cab07cd64c70db17276b46483b782c3448a64c4799b45d0a659cdb43d8667b150fe657a6aabe7614000debac9911f55d317dc96173f0fd5f75b8c07d2671e782195ef8268a65aa3f0d0685384ab4d9f1018ddf61c108f8ffd2a34107ab4e88ec394e18e61a727ad0", "8ea2300bcf91315c34517829173883fb541323b4b9ce6db17f21852cf8af3b7168a199c2ddf6983eb94c782dc14bb06e9088cb18ca7f85c40f61f4cb9b91a6ed171e980330ea1599899281d4844d5f7087c8f6f1fa7258d8558c35a759efb4c010aecdfba0d2d321d5760225a6e6845fe77ab4cd630083a77cfa2e590c08f0f66cb69ae68b1ac2861c071bd57be786c256c710c6a1863ea11234e5ba9e2c231027ac7f85d91572b7192400f2c1c1f0d7d6a00cba84024b10815f7cd6904ac6b2178db5a260117defc8f23580119c61fd3f7e833eac1e31d964050c1424560901126ad12c82b2a2a15a2d27b21d09b4f4b5eb7e4a5d97e8bf594764902e162e4d258cba30f7e6751a8fa4510c3bfbccb7da3608474e30b8f3c5ce6ebed81fb609", "a6c0ac2da321ee74882a27ffd2d746569c8c542a62d76abe544c6b2378d5e07f53d0f22e5367cbaa00c35fbf3f74e98aaa7173d8e88b8aab311d0419cba82080e0778159742eab4877c2b83989575bd2d77205bfed68cb04849e3f7dcf57615124799a6e4baa067a9cb89e4452d39f8dc1632fa54b7baaf7aedc70bb41ee8f88661f37839631282df7182af4c28642cd43120feea6cb065828ed00c9a47149be3b72ef8cbfad3bf32ca5597121081101b0d93ae5f0d4396ac9917cd14bbf72191b47ad300802b6c79b4764fa885d2b77bf1b81d3253ca85bbdbc4b61737ebeaf45e7c65f043fc7e69c7fafc4616ca2949c518de694bfeea5a973c19b70d852e5", "87bd718d7fb590f137824829666e464c0797d3a79b55415760c07b65db5b9085b1af07a3768e2aea1bd09ed27395a6e6b678cb99389bb75267af1110248ff4bd713054e05bfdceded5116744c0f0019145797206271ffab11bc8ff520861ca250962a366e4dc21cb2a051ee5ea4150d70ee17140a656f149ec31d0e5ec5066cc5cb3aa7212c7779225c43cc62ca84294199d6021ff24a715d7ac0ff45f09f2bf582af2e2086b02b59da7b445dbdd0bdbd83548e051f7affdd908dcd21a59b82d0b52593d24539370a0e22aef5abf0010e71b8303e85dd217ee3ab0ff43c74137"],
        ["b96c6833ef8d30fae5922d53e40447722967f62cf482701ff444f0e79a03beaf15b2013618c0e4505df2910a3e7bc44584caaa5980f811b1a746928c69d64da53be4d31cfcf0eb1dc3e04a9a06fab72e6678abb7dbe96ddf4a1dcfb32cb25d215b1c68039bdbc69044f9b82c68c377d80d190edb44aead3ac96d0a1b3fb8b6b16b96d4b8376adc57cb1b2c4c64116d034a66995836618a046fc10c4c50f416ea69fa4bb3249db777215fd6e8a02517c3b62f4b17ba3b83c85adff4d9344f8a4634ede26147b1bf6ac74735e57ce7f8579f90b7592093b36bb8e1d890b9bc00761ebef5561cfc625cadd915e075692ba3a2553f644f64ccc8eb11db0650d5f52b429afcd92ef86937844c785df456fd8dae9a2b6f278e461f00272b3764226d0f214a4103c9a24469a905776c7a1a230aba0ff5b4380c85a2bf03b7d03ac5fff912319f4a38f1b1c190ba6c82ddf3d1c36f2eede14167be16980bdc1971bd324e6803157824be273ec51e665375a37dc3460aa0ed332282c6bf0a1ee00eb8fdef", "99e5d6238e61318dda5ca1b422e5e4bd36f11a24af5bcbc1742647f2e898074a582b2a9eb61da608821af60b91222e35914fd4acca9a8b1587da2ef6d728531fcbd3518ce52ce0df90dfb109ae4b0806b515d21df650efe0886335ee605f4b5e221e2b79eea4f381045776cf5caf97cafe678d2d80c0cd3018223ccb5b0fe9a42232d2f0c3b35e036d2c8c0f32c86396a75075b83021858c42bd1c0eb64218186135c55fac3327adc5f8cf355cab5c6251b08b1406df32a97c3eaa4abca058d73ae52c6b9cc37611963944e90bf2225a01d253b4a379d450e353df8d83a1bc6038d99333fa0c8ee2c70a2033f5c72773fa3374eb47cf90f2b3919412f3a6aa8621c23206a4d053334ced6ccd61bac600d1c594bc3438c140bd62a379b17738df2e5243f3232ad96aac465e7dd8f259346c3a7bee0df3b173080a6701efc5a67316d4a0fb1ffc69469a1f2c6274bc912fa413cf02f18373ac42e35b3756b80122", "9896900a1b5b60a360089fbf4c8999d3901412083fdafbe3d80fb61c87409c70c8384b0587839d339bf5a8b52a3f1f46a10b49c74b45dd2dadca61444b478bdf65027ac22dcd0e670f79e4f6a8cc2ba24f72513dd914372dc9dada00798987b025e894734aa68cb942cce580fe9f091376fd6eeca70dd7fd987b575d529abe466abd1deeef65a6aeb92475772d139c3a4481f76a2e347f7471d842106057592651f27b89a8c186c323ff92f5b487f7bc061cacb93ca8be4cbb8aaa59c709996f66d55e583e59e015f994cd5ab90073766e23d9b3853aaabb84cde9f025333fff4f81723fe73290b9604c19f49947db0f0fc6f7358915e5392788b7e2bf7ab06330b1240869572b1cc99e3ba1c94f64ad0c08fe780b3c3a677f9c433d067b76073fe44e0752ae47ab5565c7012f6449e7bcabd120b0712ce4ea7230a43621b91a", "8389e70cde5d02a94848a701c4e54892d82eb704d46baac7953d77903182a132163120730e753476f7c7ee6da139528f99cf73abbfed0f50932286deae4858f229bfceadfd4ca2de8c08b52debd44304c4afd9d027f1fea0843708895951266f4f35bcdc7d9b2668663e2993a40fda010573134c0bfbbbf3310dffebb6aa26b5598c6211bd7cbe85359ff56fd66098f5f0e519aee07dc4cc6eab1d37add54dd051839e4898b54cf0ed2830a6b5d9a3c06b4f9170b2daa2781400b9bcbfcbb2e5580aa343a1784eb053962c9763cd91455609348087295ba300a5bc96ff8ca61315b00df18dfd85d4836a6ea3c88f162dfbf5240b0e738030b38d876f863f07823a8703964a24c32d94e7d239762946a9d889d7bb7dc0eee1e3378a1ff9c16fc5", "8148c3d1d32f167feba9c71a22cfed435f48c113456a852b62298b7557875047fee16bd75c6707e406522778af6a3f90a9601b03f639a66f6b8639be02a4c2832b358c1577849e1c31badcff2fae005f5efeb6e9bfdf5d84eab3a903ead2af0907633b35f5e84fed1a512a9befc30e0fa2ba9b983d616297d3c78d7f2a14a85a4eb96572adfae239361856ddf9e392545b59f60b44961cb9cba7b7b3977f1c596668acb22ac7f40ebcd2d2f7d52f2de451b23433d2b69dd3566535837ff784a005d1fa134d0171a10be43c348034e736518bd670969b29e17459883031ba70353864289d609553af653c41a58128a808d5bf5eb878cff04341deb36e1ad618a1", "906097ddd9d8dd8b0d8fdf6aeea7cf3b51d1e932524428fc801f5c7376db005116741a0668fabb249e6a2ccd4906345ab5c0d9d71334874e086108cd2e99be81967a8159094f8e9ca57100efe7786921f1d06b4b8b120298dd1a7d97b545fc7524fd5d58044c0344be01cc57e85a3e41feb0ed280301118cca1fac01c378652711ef40dcd622da4cc12b5cb37aba26a6d417b299d5d77fc55330327c375b2db86924863c69b0284b30c7f4ebce4ebf28436df7746993b3ff78f56984de775feb49c33e9eb06a0341da87b4d625bf659fd9470912fe8803cc6aa6ac7be534d539"],
        ["8c729b13d4aa40ad6affbd46fb1c606556e3b27ddb91def0e2a4f955f7e434c3038a25aac4a3a7b9b605bfa92b9e2ff789cefa11e138190658b8d039d0659d0f57641808b081cd9b86adacaeb2c6ebbc55a9ed3519e02894925e18a6105d665c71c7a96deff3954e33c832c18416b28c5edabb2719b3c5108c3f530239ac72ca6edfd92b709c599d0a2b7f832dbeb3eb0c73413b29acaaa35852d10c319fdf2d1c08a495a0ce2ec0e5fb9367402121823ecdaf4eba41089663045d0cf637a94355e09fa4f831af9ef07d63fbf7043dfcba27e1d5a2f1fa12eeef750ef054a5ac26355f4cffafa6254ba2d57f58f13c8d51575e9a31da708b1455a93f3ca7ec0f23a3daddf80c4b8ac0434759707c19834a38e16fbd02ab352d86abddbcc58d852c3bafabe8126c57d3ac2045dd33a51cc9b1c8d2372792003c083a77500ae1f8056883f5f73dcb158d7f3a5521082bcf90acdaab687dbde42a513c262c13410f66a021cf2f800c74fd72f482386ae75ccbb669b9d4b69a2e74abe766c8a6f377", "b96600792bfbceb99e3aababa80ec5912a4e48021edcb4d91f4b7b4565ea584f9c4200f4adceab2e2a0ceda16321178b8374d30db26cc39cc39701b62971374cad219c7aabc59d9899d5839c589e0509917da77a4751de0fc3046750ccb2376005e7e3643fa4fc89dac7bd5d330a53e8b2c05fc4d8e842458c007213a464e27f418f3099788edf92f813a4303e540dd45b07f3c2c2015190b500b6bfcb496ea80dcf076680894987c34683593ab727b07f1ede0ab652ae14b4c35acff3002fbe518d3844d4aa7698d37bb5b9584550c293d754d1a878c5c5576999ba71aa01d0092f210a4b48e42c2693c48009e7cf2d861de7f3df5c38b1456e7c02afa96a474f70406842bf350c57f778526a1d36f7738d5fa4ee5b1c821f9b72e26e0c8c8e36e94cebd91a5a9259f68ab347195c3127c326b838d920e374373ebf559dfe1e1b54ec0cf699ce263902ba6a3bd085a71d8e377c66661e7b8911060f1c99f5f7", "8d418283de3c3384b881a829cc5229690f34556d6a3f261c622a3062e9e047dcd75cebf58102d42efc50917eb06b4d30a780c64d312c854fce69b958170f8f5ea5a46eae688b300bd0ae3169e310471cbacf38e7b408d0441b4dae4a448cb3721aa15f591bc036cd200464c6192e85a9441c14bd562ac4d48b018cfbf11f92a858e7aa4ba87d04c3856946c574221854641eafc66129d0c0a05bc2a544c063cd63911887cddefbbadf14b1e0147dd41dbc6a17a07231a32fc5d40ae12528cb8d596950b95727c6382821bd6fc70f7619764fd23bfabe9b6d5fddb9e5d5c997e90f31633248d6df4f543e620ff73c99986e677ecc2df9457a29cd8dc1defebf49469437b9160cc1149085872ae10f93b5e8a0293ede193e0359084e080b8c069e70cc4fd5f27c093595bef06555cd92e047591320ce3d6b73e7f34bf19c4ac3a0", "908664b8cca5b33dbdf5592dc3cfef659c01052d429c0db5b686949643c795d46c89e7b3b84cac6fb838ef26f288c3bdb4812a798f8e0225a7f5c5144d3643e811e05fa99414fdbbe811561de1b45e5cb1c474c36ad1f5df00d5aa9a7fcff0005e41737aff5e35e36b3d2759f40de3f9f317e0eba3ceb786782dc5d4947cbf322df65d221e88e8ade1a90d60614cb83954e5fe92316f9fdab22069945a92fe471aeb9e8e239eedf78a736654e6125a12a793ad3754eda5edc6a25456370159b81a549e54c96ce176ecec1b98cd5b6317164d831be8e05b14624910cebab321546a0cd28b49236670ae10a2b7a8620cb291570021394c1b15755e306c11be004603549c5b222d328ea1b62d9bc6973d4762b0336d0d64e27cb4232ac0840e4af2", "97425f979bb2fde77ba61e4636cbba2d4546a47fc778c2dc94d4906e3c7bfa10453fdc97b256f74c830dfc60bb64e499a4636876f91a67821c9c9a2032a5728ef6af1e1de7837c5d90d9af092ac3f444beb8af0533c4823030e1c3bfe8ae7ba120e9b5a9c52ae60eee57db1374a6c54095dcc442fdce549f439b1540999e5a704fe3d5e2354e0bfc19427c4e61d9b1b2bb282e5ed9198215a4a3bfd23d9bba79580b7e690179ff7dac18132f7cedd000bd489d88640962735efdb70d77158bb05e771ac52fdebeca0e59bc47a1667432ad16cce22d11d34663df6aa07618d4bf354648756b69d7f026cb237937defae89d948d45594611aec1fe2cae548745b1", "816a5e99bd933612e7fab01d94f0fdd3df9c76a1068aedd6e89be72ee16265f3ad3d84a9587f8b3d05c29c4372750d48a02c0fb801f5f5fac77760dc9461660024f5285f0026141d68b5bb2b24393dfce009ddaa751059f3310daffb7aef7a580c0f3b352095baa8c61523e80cf935431465407f972f6f1953a1be8fb66696d31c3b10c73b15b55cf8abff80e6b45405e93ca4773f9f90745d28541ffadffd8738d0a0beb2e6ae2bbc1ab3d21d9d58896458626b15617900b1b57e300ae62f2f1de289a108794f7914364f614ea31240dbfcbce1bb49d76850be0661c3c17b06"],
        ["93b8205783bf9c5ae49375279f5097c9ce2d25fbc7cdb25fce469bc3026309f4581e67d2cf644788008c8403ebb9c3349204c8809b3de1d706b956411b25a5bd190e63c50f18811c13260d2f68c8dfa12d839d1510692feff976e75b50c560a00934441ec2cdab1edf6111bc44a05f165f43cf86707fa7b4deab1f35989f5ed364dbafca70716aad245a1a29d23bc5eaefcd2c5de3bf6189d4d037ddb5c7441452719aa2a6a925a1395589a8b1f9a3dd3b8915e1de9c754084927afc5c7807a30197dc3e55fad001fe343466f64e78042f13080872c22af442b0bd4fe8b899e31bffec450cbf6738d9e05d672f53548e288a817c44aa3a60e6258f6877afcb07552437156ff3679fdadcd868330f2df7f5f0318a43649501aa0be515a79a2c7d640d2b5145a9a998f9ee22b4018faee7720d664f7c5d4f84362c1405bbaa31ab204caf5a298f9543585dddd28bd7b6f6d80cf8eeb9d207351ef8eda3b255c1b84594252721b1d86624fde5be0ec4d18f703982ae8ef27db5c4eb02c92469364b", "a5ada51c5016103b62b4ab51c17af4deaa8e913e627814517a95a35ae2691b14693fe73e84b3c952572a306d7f0ab2b88598c7f613ff315cecae5136614df35016d1c95e753a191d3789497d2828c98fa5fe2b3955813295eff2e4f603a75a6d3a09d76d031e0eee5957f250eb72a4bb56d0509cf5a3200027d5391cc217f551240834fe5e06c1ec2aa09a78572e24ff4631bf566af4b44d1bc23bd151b8db1c37ee52219e3cdaa1706897cf05e41390b963dc7d6d50d7afd4dcbc82273db7b019854208f1bb0cbd81826162964640248b799c4f8778191e92b45ea78b9747570b116403813867237a027b07aea0e1fb0d84c09cb39c4b39a47caff8c74d5136504d7267eb1160777fb139d4fcd49d213308f5f280da8e04349bc3bfe90c8ac32a946f27a04cdbbcb53587bd03f9fb0e0f6e431e2cfff4f36becbe4556a366b5073ba2551c10d20eabd2f9da1dd5aa5d749db30484c5dd7a267f2a3eea9fa79a", "a9566d942c2d226c5b25456d949962b5e43bcc6c4d414b012aab167927554b807af690c8954651ebbad34d34f90ab4d38e155f0cdc08a362105b43bf69635b88bacb39ff48fc3db19cd2154968c0d52047896b32e3732fcc80fba89cf266a64a5d8aa7822734ae578f1ba7a44c97cf2a824944df5f3289a015fe64636e8fee985bddb36804b264a64cfb1e6eef4b0fa89a4838fabe5a16be17307aa3512acd5a64f91c46c9972b1059e4fae21254e7be8c8072224cdebdf781200d468a3988102813c3aa16525208137a9dfdb06fe96f9611da614bb1d79e0b24e1bb7c4a8b18177c979f8be64638a1a269f3a044b4438e8337f0c403acb7b0291658c1ebf724146ae3815401745d99d79e230ea9edb261c9e8ebcea1b24c7b4f90e37964a590207ed43a31868036ead586b32b99b9a26f33ef4c65ee8e6a7b6a2ab328106937", "b7a7fb3e133a68e223eee67b520f7071ef3abe9aada3fdba70e0c11ef6e70e535b93279c4ea246445204bdafd3bec81ea01b509c1fb26e785efae8b96358e2240cf74674169e740e8472fc372708a7f3ca0b7667f1cfd28345930e5d610a78b519d7f02ee0a77caf9dc6ec4167234dd0f1f1261481b315810f41074471e794ff05696affdb097a461dab9e77bffbd4f751b195d8e70005f357adfeedea6931856a5cb68f9210a534725d4c35470f777188b68301cbfbfd198066058ffb1223eb1903dbd94628edda9e8887783a139f064472120706477274efe4cb2d0c20dce92e4ed84f1a293d872a38266c0287b25d502d5cf370073a08eb9947c9781c572572aa70ca7ec0a02f4e3fdeb16fd2d7fba2f06ce77dfb2960fd50d63bc47b8924", "9225354605570efaf6cec325c736517ca07b254178510e431e81e69971b4c2ddb54aae413fd6835e9f820aea5f970e98957142a5b5ab655fcb47ee64e03f08fefb91d1ef577d4a728f0fec967e142a897ae34af26536dda139a34e607ff1b8761e6d80fe661c076f126054d9794dad636bd55143b088edd5cae3914b6ef6cbc00a46922264fd73fb59c7dacc6568376afeedb5370288d40afb08896dfb59bc8f35ec206a00a57845950da11e66be0b28fe9de6f96ca6c18b90eac71532510d8e1a50687409cadc4ffcc5202d5318339a3055c016ce022a7a64eb735767f5d1985120afba013d46c946425ce52befc2e330c7dea8122acb241ab565615bf0efa9", "90a3ea40c54dc5280a56008d7d4e41a9bd7eae5c4cb02fe58d699a6d684359a8bb37b63fdde6b9191b59a2d544c56203af1f954873caa4e4315451a84b89b55d6f2a7e3aadb064b85f0681731cb7505c732fd6ef35817193cfe3544d63ded6351f76aa0a53e355ba96d8a355ee0552faa5c3adb2acd29233d02ff8d6684e18a22462c7313a684f04dbba3fafa66c8a796d799b6ccbc54111a34011f4311c112158a59e94ef900678e4f2188c1ded91345693d0a44de8b79a1e70f50cfc069d4a08da707bd030c7d26ed51db10b3ef33489442505d5d7bac81dcd23e259308c5b"],
        ["9537cd9de5c3881c2fe45832ed22998849bd1154d72a8d5ae8dc8315d00b3bb4153803edf73c08ef229c26fff36cd445937495419dc7891714580dec6d407e58ae0ef2959db50a6a4b3dc781c2ab31aeb2a628e1fd4de9ba964dab6ab93e2c5552b47263616f11c1bd4769688bd67f812834f6f2f34cc427f458cb2dcc89b7f75d7e1b1e0a01e6677f97b749eb547d2e9d6ed2f0e57e77417bcce8d0114c8e85368433e177274a70718cf4da7490c08ca343be58a5f3ff700531915bf9e1c2d13001a9a482afe9cb684e3aeb29975812033d8117e44838caac51f2d73beb796b4ae21df587936edc524f912785ce03e2336b883b65595b4c8c48264d0161c80d1386bb3c2a04d7e2bc089f289833770ae20b060956f3eeea72672d51e9f02a82244a81260e9623b00c01e9914f4db170265615815fdfdb34911018fa9db129a414e2d0f1cb6aa4c608cc075958c6d662119ccf90ca3b82d4c658875e442f30540f54eb64ee7170d28e5854b115033f47771613d582230fa9ed109fdde98a1158", "93cf1d7a8ee41208d7b0acfbac149a2978ae76475c1b82400f41331e3571c274f0f3ed05071921dc4451ce536c1794d8905088b5b683869ed1c4ef1cacb6c215d0e4a7c04c86a48b28432c3782174125e44978dfc7d7b0e57e4cf9be6f89da4471174944904a1113da3c9f4e28b23f861ae10ea8032d47dbde13b2de0f3b1f4c5e8feb1ad1ddb2b44de8c9163acd14947a14dfce1136588a031d340ede321ff846a2b40966169c7c11bce3a67b1dcb17e3f69ab4a0af95be60245de76eadf46c283acbefcd2fb8827185eb8434d78563946875d2a4bf34d07bd23add46a6c4c83875d3c8c9da0cb20a161ac1fbdfa742a883f281967767c0080448eeee1ae8402849c0a974a96d2162e1bcfd01f00cbeaaafc9d7bd446f9edd2a9d0bcf1e1ffb6f6cd974a47a9e9ef373ad3ff228a6ca7675389952c38abdc42e83e8a970efd10f8043a5b1827404162e973a3b5af466f11ed907931c5419419d9f1e355cbe2a", "aab0be085f13c9ef6e53250d0d958e55f1e5b0563864ba7c03796e36f85d87f7f363611fa08c927145353e323c8478f199c7d9a31571395c25fd62a38faba1302125f41e7cb9f527404f56913c92f3fa196086455733d14154b4624a10c5c4511faadfac72f54cddbd3435b7b245f477c781dee823b7d27550c4bd7ba316a08d2c84219eedcc46c3aa2d24d03f11ff17850314d708dc2ec2c7808d2be15d5c651d47147af93f03733a585a7edfbc5e432633430618b7a1fcc96382c0c0cfa6f14d05f9649b515e01546cfba7d6785eea9a6a7cc1878128885e1936448f6099742aa86509978c8761ff62aa600285026fe7ebd3e2f1fc6a9a355b483341a2ce42479d59c08cb3852a75140e6e9c2b1f497b53340b5ebe406b0e7855a912371ddd0b0e20eb29d1285bcb062cdfaa8e048200a088af349f01d8eeab6ae7b575045d", "8465fab388847fb59477bd71ebb0cdefbf7164743539e1d60ce886dde70649b18775fe17af14ac5ac156e6be65a1015ca5426701bb071b7ae533609d652262a46b5ec1ebc3b355c4fdf1a159a17bff358e1ff7af383c6797846a5a2339ad368213c73c861a66e4b1c060963e2044facebd96eae6d293d5cd7024dba1f195de111fddb54efda611e878ce1ba57172a1614cfb7140c7cd89cb7a3c22d3b8908b3e6430f9b21e33f1ffa85d2f304bbe02da1ab6b2c4423eb4f3c50907cd51490aa94a419bde3190cb474c31fcfe2eef584ccbaa9d6cefb5c72fd43187763c0cd6bd1c5f5bcba37b0ea39f94eb0c35b1becabdc3fe954e7d0efd153b32295ee4627c29aaa04eb64acda003d92cc3bee3663a0077d51db8e96d779c518bd0ef25ece7", "988532ca11dce408e0b124c8afbea2633e342add03f13de4908adb1928b0f9ce35efe92f968cf20643eca2472d180fc0a8c25118fa1589a0fb8649ce17ed978efab6f21929ade89947629e5fc4e1108eaf2aaadcab2febf6bb2501f38d60de113199576817a95d4908e799d934dedc2bf16d2a55f92aac1847f4ab2e540de213563c92f857173189c8a39c635576fc515b75a0e68873bed4db9e4be3ab47c69e34248731c6e420b39906c1132ee025773b700f01dca28fc22694cd84050166452f9da81fb08b8b9164b3dd8ccf4d8bf0e56c91af6733b9a0d9e349f2e539199d0ba180d11342f35a157b95afbd924d67a4482564b57d964c06572aae83dba039", "82c9b0428acfc8a3e4d33c1a7c5f8565334b6c573daadaf39bbe413bde06fa3d96367f9d344e2d021583d142b8a948eba83b886a640a15209a9ac8838ce6492f87fbe5d1fac69f26dadb139a71f5bfa0de399726bbbf3c001676e95663c19540401d016b84e2af62a27067fccdeaae5dd71b6cee5232033d1e17112d3e8b6cb363fc27bff3ed0f92c4232aaac522158d0e983a6e8e61ccac92abb2e15665b45b36410548808a4aab38a86a394a28328c2ab33c29c1f5295ca3f426182ae3c40f0378fc33b17443b4e8f28a6f1dde7a566d857a5f34cf85b2b76a543de9a05e18"],
        ["8a45d3ee762de0816248b90a93f7b0071f8799d1203ffaac4137d9884de7141117881399ba00c836b2561ed0ab637590994ef8087a0ef71b8857d8699b8393a794e73ea9ab12fe2a7ff437cccf02b2a2e7124bd2c6f296ac855b57aa7d4f2ec3683d65f9d765d68481c13c25d276d7e08572220caa79113afb85366eaafa733b3e5fc27f9929d0c6655ac68b0c212c7a4cb3cc7e1c4cc0f4db1b8408fa5a700911ebcfe314361c8d0534e7ce6f3696fe04ab25069d664b45bcefb0e3e5703b2b0e12bdb25d2ddb525b0dd6a681fc3108f9918a85db35d6a2f05a3fb1881ee5946e92797910bd95530ff3d76105cff0a45953f4487a2fb3893e2fd6ac4a68fe5b16d0a10f9aa73cc4c1a3f95f18e66661b643097e4ee9ec1760075f4c7b9647956a6d830e24f1ab71cc43f492392fcb90d4e2d4f2df08e24f38e654fb5fae57693097fe8bdca371f07ed4ca36fb08feb61bdfeaa15600ff60030de39aed3562581f64d8cf9b57c482725ac25fb35b1986e1c534652fe9fa57ff92414bf23602e6", "862b601e38e8c788bc82c20224d761eb94c36c3de9ffd1b32ea22c63e70421c99d55c3aee66c4f220ff3500839339fcbb3f863220558dc9a15fbd535cb2c3c0dbb5ecc4499a6fc3b9143cc94517c856d4a191b35dcc28780cd968c652e99831027a17d8a46ebb362a5f3652706b6ca67eb1d7c05b9fd7756280a213d2bab38de25b46acab1ce9c2cf5da759266abf69805f5a94a3f43e63802d89cb61663e28d19fdca084b7ae69545b6791ebdc92c7d2ed92603598071d68c89c4e7b32b10e9444b93a6ba771c94c1a224e7e9a4573b55c96f204eb00c6570a340239210e76339c1fda44073e47409dabda275c8b0074902f121be2867ef2806be86eb25a8f120ecfe45035e1dd6a3d78b11c1c137ee0b5637cdf06aadeda4931febea51b04f493affb8b2fe709bde3d6079d219dd12e4a6486156d649010961c465d80148e9390e25c2bf5ccd4135f9b60b1e82cfd47886a8b9eeac93a636e7e80f80ec2775", "b37dee311df776093860891b5226c714bad521e2243a5b0fab09a66e20dd0ec292c1161ea6b9b13f2bb9acd3c6b16e5fab17ae0145b0ad001dca0d4ec66b23a0d8a8b3b78202fcf87a0059da34194521205e585f21f36a91c28e8c2c6e62de564c82403774e477dda74081bb8bc647a9a2cc03380c0b0ed8b357c163eb656686632ca3dbec0ead751a8dcb13ce16b427dc2195d6bb3e8c529bd76681b1e7689e6cd67a8849eeccf09544d9740a546deacc6977235906ebe03c0b60ea08076f092bdd73f6c1a6d24f0bbb7cbebcbaec92f3f465f21267540f2472d861336c7de2131af03473bdfae781fa0d89011987d76bc663474102831ff1f2867bb3f600d94d0155454d7960ec26b1db28ab6a6e4515d580c5d087ce6dc9e10cd45f0baa2b19b196baae6dca5470e5aa6c72a42ff85ab4e160e8c096c3de293674e2a6a590", "a9d2ff9cd1a5e0729a88d08ca6491d53831a3e332e4e0f1a229dc2de14807667fe0a9d4f9b1c974b46649c66034c879889da95e7e6e7f54e23001b998c7a3fd51e4cf0708661e47f3d09b4e885df60a9cde058bde9c8c0dfdc17c5c3541c924d512a5ed7b1b4c9ffbfebe6c7b529d23013b5fdbd27191b767a4398f59e1542b26b480a90e4bc494a40215a1fe19fe6f383621f94ea11499a8061a1d02887e2401bff3d1e2828be362b5973931bacfdb3ac9fcc52247c220110efc6ab0279edcb23cc2a339372fad21e99e9d05f671f8b49599a8aa85af5ff60895e76b03f5a683402882fdd895d5bbbafccab2338b3402fd8625ef06a886b3200d18c561ebbc8530b7a106f9b511428a47374c383bba3cb301995461f284749440f53ee9811f9", "b7b8d9ba73a09a7f3bad41157c11aadb94d25d84798cf1548446f7dd156b29718ca38d335396ca008b0d51c1b264570db395a9ff5a2ad01ae4c0e2e4660d16d14b45209ccf3a09825662cd9bde71c6e37777ff842b558c1e790d908e5c33b09a3561320954049d4d580d37932c4778183c548ca71fd9b9e9a4ede0fc2c938df42bc8116cc3d4c936b88dc5363c2fe18a57e5e0e9bfbe7d986dc52b0e8fd688d6071c161a9568264b0ee3224062b5fbce6cc902240ffdee73a372577290b11e9d286fa116acaee943223d0a9bcd45831781f6f15a1cffd98f1084ef6202dd89f3033b29695bc636ab86845f8a4f46eec20621c6d3830bacbee8982546ead9ac00", "a05dbbeb11a2178fc7e0e572500233ae6122fc49e62990d482d04fa9ef0d9109dfbd535851fa0d11fafba53953bfa18cabaf9f329390e9fe569f5d1ef9cce9c51cb251a4d6a7d691b5fbe6c27b7ed8ddfd41b3c33e4e977439eb821c748ff3f230c2b62a6008adad46a176b76a8facfe37ba637916d636130ef8183b918160a04571f8b58c5dea3d0c79ca6ff8dea640bcf89bdc2b73cdbceab2d6999f1f624f3a6bf98c8db3154756bf44c227014eabcbf1c5f7c9050cce6738f9e2b6f9e5a410a1ff13d6955aa54b8c8e777c1b106a9b91a14acf29d350567bf79d197b3fa5"],
    ];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFOS[i])
                .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = get_expected_signature(EXPECTED_SIGNATURES[i]);
        assert!(signature
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                &generators,
                &messages
            )
            .unwrap());

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng::<
                _,
                _,
                _,
                Bls12381Shake256CipherSuiteParameter,
            >(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = BTreeMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_msgs
                )
                .expect("proof verification failed"));
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test no header and no presentation header proof
#[test]
fn no_presentation_header_proof() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let pk = PublicKey::from(
        &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFO)
            .expect("secret key generation failed"),
    );

    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proof_with_header =  ["a3779ba1642e5f67170ceb5adea51fa8acfd027f3dcd2a7fc9e605b598decb88759d763b92d9c46a94d526f2225946f9aefdf4b998386ecfd4a8e28d05a505198d95b88e4826ba74d431ddfc78ea4dfae2abc54f2635e4839a948aef20119b4e583702ec71b8f03884098410e1e6da8d809952f249a33055be1d9cf1c8bbc5a4571f07889d3e71d1328d8f9f24132d17b92d2cf0c38256099e812808c9eea9933d2cc4739cea3db27e905b26526e9a5535d525a1e9231a5ca07909d37fdf52fe272eff368f7b499462d209f0e1b1fb2654e8dc0ff83ada2c7c941198c209d7196212dd9f63dd752930d651709b8a3088d5c65a06c7e0e5178b3e500b91f950901bc5ad99b55f1165ea236c78f62eb1eb5ab2a24f48532fca252355a85c22a47444cd7d4f4d1376769b83de1c379c54a53fe94494d70d3e25e1bb72aae46431d6333467819b2f4b0cf9589c38f18f1a82036bef0fe59c6a90e71ad41c46f2a35d40571f1aa0eea0620e1bd0356dbe000596cdb5ec9ddc7536c6fd7474de69ebe5", "99a4776dd73ccf50498de7cc7e695a256cc6c5fb21a20420c916456d307388a83e88bcb1b484a9f0ecf77023945a37f58bde543c9a7d0397638a4d4b1b17374758cfba86c3931fbfc64ff78182abd3fad0050e924871d8b2b4630023459b7fa10ad3762ef090df8219aee2274c20e736a09348309126ea3f42b8d08c708a948b304e21b478b84d8ffd656b535977ff97ecc01b5d903b2e4853d481c9b0469711021927be5aa54e00e76f080231d7964b4198363a78174a8b7cf6efd9a2c7587e569c46d5eca5326ee0c29e485a59f957eeeffe2141bb453f54cd877d427fe6835d28ffe58967b9294b8f4e8e95c7ff9649784543c774067f4d3cee9c47bb420e494eb27e7941833474421677e8b0e293547d2d36c4f063f3c2b25d0d93571c465ead3b48d45a8a7ba212a1e1232e34edb547de9177c11334177d41f417dda48921e8e49713a68bd23a81f1666db3e95a10acafad73496e7653c127dee122c53a", "ad8877e9fd7ea4be44fe35bdef4ed58041fd27fae587ef057d698f858e6988f1cac02c06307cfd217d5f27e48a15a8f0b0d8de97e7bc0496e50fd44ee8543dc21f3842cf95ed41faf8a6e20dcef3637cd12be9b38b90249000275aaf448ca3f507bbc9be3f3c2c99d2fb1158b71e8f0a33fe93ac1a426026c214b430a8ca9ef54faa84dd513a0bd4aca944edf60e6612d23188a32d2add17fa72d640648bb8473cdc839b5d7e160aa88bbf1f3ba90f506bd72aa8007ce89301f075c91d5025f86a65a559b6d3ce8c03b2a9c094f470af06a226f7ea9058fb6d3f4cd2d4bc93cd4f12dcda73f5b17535c2259f7198d8c1cebce38f37377d896bb8e56398c1a24915966b9c766950853bfa5ac479e55f1e602605667657a3407ac19c2e5a2eaded04bceaeefa8fdcb02813103a59aa8003959b5b4de59f106134dd6e1afc2b4b37", "8ed8da66c526a7938ebbbc67ec4daae9770fc8779caa898c94db8b77e64f15070585e3470007cd81cdf355b8bcf0f7daa1cd4b9bc13245dd0d1cf5de1636cb12b54cec2bc14c2208613fee2af71abb74c0a32a23f9834fe02e4dc178eb47dbcc1cb89a6ba3998b8b26f03227a87ed5c165b5f03b488fb05a289cbf1c809c27136d5408f152527211a551f0d08c72598ea0cf6c0e1d237a3252e9a5ebfb5b872c6a301f5db2c0807ce00809aa6fdddbd4d5af7f5f567172f4989430936627e0df6d06ef00779574ba608c2400726403b7d05fb697df3602e8ad13925b6f96637e102000b6189f17f8717863ebb8faf0346c097e817b717ee7af5c5883fe0d9a764a9dede5eb1c67f725363d8b037fc4ac12006a170f96a53bec46908c269d73ae", "b41f5ef4b36ff8eec817af2fc357ee0a5078950a5ce14f71c40ea59e296a61c47b1f46ee5dca68b46abf2c0598bca41f852742dd10bd2a089d7c896dd2664a1fd2e083d9707735bb32d7d9bcece666e429b3912e9ecfb0acab6ce8832457e2160749185cd638e47ba09d51e2082832abc8f96b17425a34f12a5617faf6d823034646c6eb95b8363fabfab01f8aac3d173c37bcb340d1ed304905a706051c3a9345ef56d4a0c26da9f9481c3e6a370663a510d1fb5610da43215bd3600755f50f378be17f9f3d46f1a8301547c61b1acd1dedd8f8359a5f920923bdb85cb266c82263e50730725d4ba654319de0addf7172c63fac526109a1d8683b520109ef83", "b26f7323843258e16b7d9aba34a0438b059fe384d83da5c8f0c41ad65080cffae1585abb87d6bbc4751f04fe89f78f9695c5ac69b0b3a7a9658a72d902a19668d5646eaede9552ffefbaf5f863df25ce90f885f8f586d583a7c64b8f35d6c6a16b099ed40bc53981670bfdae699f8c4f5e20908f1380e628c739ca78cb453403688596ea65fa7269a793867b06d370e8395e8ff127a96765a476ea436c426a3e4279948023764170b82c5ac8b325dddb31de89e3582a619f3b4c95d1e2576b3424555930d32f7e5454ce3be49544d953e96966d6148a1937311498fe4d9e82ee"];
    let expected_proof_no_header = ["a9ae12f3ab5270f49305e39cfc3d905cf0e78463c26369ba58699af8badda2c504f0e3778bc8d8b290cad6c0de8b94b081ac7b62ea07f9d970728686de639243f3d08abb6ddc12f1ce6e29b6d8888deac97b155d2a33deb7d3b3bbdf6cff85de247513c8d51cfba6f32c4033ffc1dc73383b1698a3044a205fbd8e45511578ca5591c973e1ebee0c9c914aab71f5911df9c94aa9f3b5d330d503c2bb6dbb2070681c56c1f7c96239c18b08606082a8cc33807a21e39558fd69036f49db9b089170b65b36d66a2d5aaef6a943416e90020d83c4a5226320e54b20bd574aca544c48e99ec5b2402dc147c37d27498e68bd5fd53a227e0ad8e0bd673ad02ad461df6a2fab31573270f0bbb896495f20c89bc5b4b4936772eb62f8d69c59cd35159013db6277bd9103bd1edd21faa379f0c3f7ce36f02ab1a6cdb1c4d2d277e3ce0e2238a077cbb7b463369cf244270210b5cd0e7c510abeedbfa0696adcdda613914a20f2c8962cfa2f70b6e1a8b9daea57c0f4917038bc767382225a316a1dcf37", "870248548f656859bc02f640b842b98d8ac4881f4914da6826fc9c131853dd27d96c1d3e419f62cd855146e2a472f0f1856c8d79293803dccde1dd29a28c27d0c3e72d50e9dcafb0931f421b00e72412e6dea7a6490e7779b931e4523b17c7af62e58db44af4e554759e19051c0d2034e9eca97ea14f9542111574813c32d0875eb18cf9258932844ba18c1ac49f06c663aa0b298e9908b1c88011bd80723ff41044372921c472e747dc6e8308d5f9d769de99895bf7c1b92419d1bf173542c92756bc267a63af2e9245de973a920bc9e74e3451f07070bad764490ae750ba9c033a3dd84a94f079f4d4746a6048c39e6106a1de8c5ec97c56dd52edcfe4152b59d84f4688c64242f1e749ddd67d677fcff952c92fb7fc267ce855a59d73d7b4464e4cd650277976addeb6563fd0cac4eabbe04d347de92c40d0679f8167924b4bbf4f9be124c36ad426daefe986d0168ee30ac3d8c6d5938907e5374cdccf76", "a1cc5aba2eb49302dbfc82a11c6ef56355eb0f156e9ebc96d7d03a4b84b65405df53e4f7da35edcefb706b57f9e151aea48433fa6a69d87e49742c4450beb7c9c0731a2793f99c698272bc9d3bf1ebe480fe35a930b34e42d88b8d41822b462e5046d7c632cb34b5760b2097a7c13f794355879fe153ad86b33d3b6d5576bd8e1c95728345f0d9ed7da21717e2ed64ba957b434801e50c309f78c93d8eb47e5763f9d3183aad67b13f3cc2d59a5c2aeb7e7466ecf17fa3791567f49ae0238b1b39163b4f9b261edaeec57d7b48facba3bd04ea8fd5bc66cc6b9eb6eef1025f29246e59fe0624b959c492a4d63f57612a52d22f8cf4956050a521f53e42782e8663eb2b034284f47f6d84c8b62faaf40f9ecb1c9506f72d23cc2f0358821954eb73c8d36cff71d44a1b798899428f5d44da996b75ebf5e12e2af8a56ddab5b808", "a1be14a70212c60e079e821eedfe3bd6b9c29c850fa5b9dc3b722defc458f42c32ff43a2d4f53724106ec2cc8083f86a94ebee35a678ab5ad1406edc4235e2c007ab9a96036c3055b7a0334b0b43eb079e487b0f3045bcb05ad53945cda0f3cd06764f07f3cadfd265956b2eeae6f02a9e733135ccad89941c586bbdc00a3b3041559de14907f1c04daeb3e95bf74f9941fd64e7555f55f59bb49965bfc3d63d3a1820afae36bf058094d3b5e449bbb0e10700072e096eab3ddcaa558c51edf27191d2c6eb2379f06694b5ba6925c2bce5f66919228ab9608e9f1aa87669250b6df2080b26a7e3ce5c700195a57e77ef896f8cb633976edbf42284df5e1fdf7f51d5369603f05bb1a33adad38194162e5a891419c8116bbcf28ae9713583b7a8", "a285d16dae4ccc80b1490146f724314fd3d82e4d29d033e77ad61276ec0f51e727d27ae95f862afdc5a9ae26c28b394391fd36d4b2844fd6a2d4bb198ea9ba4c7e37a94316505fab43d97d6a688025c18e654d3f1b5152dd92971b57235dc5071f512d67c56792d7fa7917f4a38c4c0cdbe39258d037b0679f1c60d43751d4d94f40fcc6df8c9831d03a8312a07aeffa9ff2f740cd7add7e3c07c90a9433bfdc2e3faf69e2de5a3405a3c7e51c03f42c611a9dcaad787e101e1df7b84e4007022071f9b43c1adfabf9e4a943b9a6e772cfe221298b217045500d79bdb36da7df6e34be5a4d720d20a2e9ef6d7faf8be29b58aa4c3b10998f7862dfd32bc26f2e", "8436f9e717626a0619f46d76167cc8adff8d2fe40b8e79a80a4a1cf2be0645b13ff055eec651bad2904fe52bf05dd5f1a0c79a3c3c826468e904ffdbced0618e14839a04dc98f4ca00a3d5a8460fe0ada8e193628dd2fc0761d3e5492b40284a314449492ff30244191bed4f2e526bb3258efa164d43cb683a27d10b6f2ae041035811a813d2a1962a7bf6c69f69eaebd184d0a74a057cb6f16795a731c220d92838461b79bbb18e527e94b163af25f8737208df7d3a9ed8477cbaae742d8bd5087ceb1c2aeb93d383401b736ef9606fa45dab3ba5aab9216c8e293afe707c6f"];

    let mut proof_messages: Vec<ProofMessage> =
        messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

    let signature_with_header = get_expected_signature(EXPECTED_SIGNATURE);
    assert!(signature_with_header
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            Some(TEST_HEADER),
            &generators,
            &messages
        )
        .unwrap());

    let mut proof_values_with_header: Vec<String> = Vec::new();
    let mut proof_values_no_header: Vec<String> = Vec::new();
    for i in 0..proof_messages.len() {
        let signature_no_header =
            get_expected_signature(EXPECTED_SIGNATURE_NO_HEADER);
        assert!(signature_no_header
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                &generators,
                &messages
            )
            .unwrap());

        let mut revealed_messages = BTreeMap::new();
        for (j, proof_msg) in proof_messages.iter().take(i).enumerate() {
            revealed_messages.insert(j, proof_msg.get_message());
        }

        // Proof with header but no presentation header
        let proof_with_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_with_header,
            Some(TEST_HEADER),
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_with_header.to_octets(),
            hex::decode(expected_proof_with_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_with_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                Some(TEST_HEADER),
                None,
                &mut generators,
                &revealed_messages
            )
            .unwrap());

        // Proof with no header and no presentation header
        let proof_no_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_no_header,
            None::<&[u8]>,
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_no_header.to_octets(),
            hex::decode(expected_proof_no_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_no_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                None,
                &mut generators,
                &revealed_messages
            )
            .unwrap());

        proof_values_with_header
            .push(hex::encode(proof_with_header.to_octets()));
        proof_values_no_header.push(hex::encode(proof_no_header.to_octets()));

        proof_messages[i] = ProofMessage::Revealed(messages[i]);
    }
    // println!("proof values with header = {:?}", proof_values_with_header);
    // println!("proof values with no header = {:?}", proof_values_no_header);
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for (
        (key_pair, header, ph, mut generators, messages),
        failure_debug_message,
    ) in test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature =
            Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.secret_key,
                &key_pair.public_key,
                header,
                &generators,
                messages.clone(),
            )
            .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = BTreeSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            OsRng,
            failure_debug_message,
        );
        assert!(proof
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages
            )
            .unwrap_or_else(|_| panic!(
                "proof verification failed - {failure_debug_message}"
            )));

        for i in 0..messages.len() {
            let revealed_indices = (0..i)
                .collect::<Vec<usize>>()
                .iter()
                .cloned()
                .collect::<BTreeSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                OsRng,
                failure_debug_message,
            );
            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &key_pair.public_key,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages
                )
                .unwrap_or_else(|_| panic!(
                    "proof verification failed - {failure_debug_message}, \
                     revealed indices {revealed_indices:#?}"
                )));
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<BTreeSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages;
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<BTreeMap<usize, Message>>();

    assert!(proof_all_revealed_messages
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages_same_but_shuffled_indices
        )
        .expect("proof-verification should not fail"));
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());
    let indices_all_hidden = BTreeSet::<usize>::new();
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert!(!proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages
        )
        .unwrap_or_else(|_| panic!("proof verification failed ")));

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &PublicKey::default(),
            header,
            ph,
            &mut generators,
            &revealed_messages
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                ph,
                &mut generators,
                &revealed_messages
            ),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            MemoryCachedGenerators<Bls12381Shake256CipherSuiteParameter>,
            BTreeMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert!(
            !proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages
                )
                .unwrap_or_else(|_| panic!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        r2_hat,
        z_hat,
        m_hat_list: m_hat_list.clone(),
        c,
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_bar.to_affine().to_compressed().as_ref(),
        b_bar.to_affine().to_compressed().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        z_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
        c.0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        r2_hat,
        z_hat,
        m_hat_list,
        c,
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
