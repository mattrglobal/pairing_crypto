use super::{
    create_generators_helper,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURES,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::bls12_381::{
            Message,
            ProofMessage,
            PublicKey,
            SecretKey,
            Signature,
        },
        core::{
            generator::Generators,
            proof::Proof,
            types::{Challenge, FiatShamirProof},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use core::convert::TryFrom;
use ff::Field;
use group::{Curve, Group};
use hashbrown::{HashMap, HashSet};
use rand::{prelude::SliceRandom, thread_rng};
use rand_core::OsRng;

pub(crate) mod test_helper {
    use super::*;
    use hashbrown::HashMap;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &HashSet<usize>,
    ) -> (Vec<ProofMessage>, HashMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: HashMap<usize, Message> = HashMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    pub(crate) fn proof_gen<T, R>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &Generators,
        messages: &Vec<Message>,
        revealed_indices: &HashSet<usize>,
        mut rng: R,
        failure_debug_message: &str,
    ) -> (Proof, HashMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng(
            pk,
            signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
            &mut rng,
        )
        .expect(&format!(
            "proof generation failed - {failure_debug_message}"
        ));

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let mut proof = Proof::default();
    proof.m_hat_list = vec![
        FiatShamirProof(Scalar::zero()),
        FiatShamirProof(Scalar::one()),
    ];

    assert_eq!(format!("{:?}", proof), "Proof { A_prime: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, D: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), e_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r3_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), s_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A': 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, D: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), e^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r3^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), s^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(&bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        &messages,
    )
    .expect("signing failed");
    assert_eq!(
        signature
            .verify(&key_pair.public_key, header, &generators, &messages)
            .expect("verification failed"),
        true
    );

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        &mut OsRng,
        "proof gen failed",
    );
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("proof verification failed"),
        true
    );

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert_eq!(
        proof_deserialized
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("roundtrip deserialized proof verification failed"),
        true
    );
}

#[test]
fn gen_verify_different_key_pairs() {
    use rand::SeedableRng;
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["aacf078893ae79dc794e766b8db9bfed7c4ad6bbff0c092fec0e703f05bc39e1ca71c364ed1daff29b37a3210cf56b0d992fa0e34fa4394bdd6d6fc2888b60603d5f5cb9d668e44bf34662cc6ba9e712e8d96c9e6972775a4ae16bc863209387a4c3f738bf4ab5185cdc1f1f13e931d7a7c5a4d5506c75e0c0d70fbe9dd342b79af3a2c7508926032048bd196cdba6e943c36643fc407f45d79e8c140632f3cae58c259915417fefa5e3f7baab3d16c671dbe7c9d768098da28f62bd7dac3023ac6ea7948525ec8445e46dc7a05ab68042d5bc66bb220cb69d5c7c839d17bf23768b8df427c1b3499e3f08304c6cfaa0002855058bdb45526810045a56e0c98d8451846fe297c386ce9cc574d276aa5627a155db151ef05f051144ab5ce8b5950f3209cfb5a98fac1bafda95326e83d95651f5aeea12119166aa0d4e5ecc3fd014357acbaa6701e8980414a21755ebdd4fb76ead5218d5326980dde5527c1b3a2602f9eab043d907b423a6224c0e9abc45e0e68c509c0a3a689eda62ffffe138228aa0f3bbf583876005af3d5a6ec888467dcd711c53d34c6386afa34bcb7b125863aef685928e03719ed4ea2494d65b2722f84ceb356466326d29e96d545915b9b3c197c5a9b23fc2c626b7204559d622891cdfad7414bffbce9e1a79dc6db1c366666030f529a129473d15ca107d74", "b1de1054493b9b28a40c4b83ed46d08ddbbf128117188eacfe6de3943ce51545a4b3f5393cff971df16055f4ae414d10ac9f6d1a4a702cd0354ea49a1b32a18e97cb0f93e18f54a7c223a8a5d22f06dc5728ad18ed62152a117ee8ad35aab8adac03b35e33bddbd0392381281c1f17eef1ff15d2638698c12060924226824ec01e6d0b9cff56aeffdc83eb9a6e30f3760761e3c3db8c98ee55f0b5ae3ed605dc05fc04f5f8f14fb2c76fbc902d11d72d591cd523b7afe65903b2987aee491edd9fa719c5059a32d491b6a9de35180936052129fec840ced6261829dcd3e5a726b46a830f717fef6b277dc1f27381ab4e5301fd31c629b696350c727bc64fbef58fab84d57a135f9a4f4fa1a2f0214e224c34210f830f75d3774de3833ff9e115561dd7ccce8ddb0e175fd3e5d74f58591c3b8a104b5c9c3d252016601a8832350b5a68b8937076f1c24dd20fc751d31905a03ddf3e7f9713675ba9e7f700b73a08d046b9856472a253881d6cd3bdcb0e0fe2e8d6f2ea438f500f28af33e630d2d5e6ad86c8ad1d5d6a064b6babfa69e3659c12ecbe3dc23f13aa5761304a38ecbccfd06460169d6e9fb850dfecdbd33c51e7e2c9ae9c845046191b43e6608dd06f1da950d8c96f625beb0c9103c24165", "a580b85408b0bc770f093d7ba0bb44eff07270a2e2f61159ea051811c0aed76fcc996e321357b1c708b6863c37038e34a117ae9502165d657ee3f3de7df439f8bf63ef6b4328ebcf50121e3883722e2fcde6ecb8f564204ea08b83af4be6d949a6f771328b44d77d249558df16fb2636b0fd4146c4303042c48d772f2bb121af740566aff789aa4cc04e7a9eff5995272b8a69c2c7c619f58b7f0ac8077fe516d8123209ae963028d1e8fe89d52acb003e48b7b6d73d36728ba826020edb22caedb554c2b139c607ef639387995168a25b35d55a5d79fb5d596a2a68d60fbbb9762986c9f82ec9f955b20390a299a9c61384f153b5b777748b990932d79d99d282aa2e51380f039e8ed78e93257c4b032a15ddf9d845bde8439446c2f05cb28f6cc337cfc7665c859d7cd71cf41ce60d2063d3e8923610b50b7f97ab9aa84db7be3efbd3b90035e68ed1584765c8875a1cc3af0f2ba76c8d1d758f2a97da989f43c97c4fc5b6063ca8d6039692c134be53a52c772c9c58ee39d6bfcc33535e79785d43794e45813dbf6f57304a7a70f76d35085818ae33fe767ed9af3a7b8fa86cd186908ce6dd39fac40641aa66b954", "a7b91e53efa3032698aa6326fbc00304a735e42b322d6f67a5d1a694ae0cdf4dcd10c47a1f6656d4fd2cd79029b263c3a1cf8fcc16cb78929b7c5735b27f4e21fcdf55f796ed3a6f45674b9c1214f3a9fcc208f527d3d079d1bf60f46df55879a9df210da13f075b102afd06816a37bb2d7d77e13378b8e77d0bfe613a5f8199fea7e5e020af669b015adea12b4876970cd260bbb1c97ec6b82449845e50ab5dc012dc99d16b275705101d8e0490b6e70813cf43dfd03bb4c026e8c5c2371935ccca2c60c91b7716af504a8d4b173f3e0bef2abfa30d5363d528b30a9889260f475cded84b2e9c7f844b63d2553267ab631fdc5ea5648f013ed4b1909613e4b77cb9a018d8a50f1ca4df7b0316fdb2a458ad7bb40e1820ece144809658eab0db98626316b1e84dbf888802bd2a552b3b6b1fc5a64f8c137e628feeef5b6cc731ad364e35e258e2bf5aba6463485845d154b1aefe7182aa1a438b8fce56b4ac93fba5e90d7d842294306baf79f425521c2678b303c2cd0add56cfdd6790b9f674b0e0b30a3d230d4a4e5cffe95eaa47cb", "84cc4a51d420ba2f8a3b3d843f3e3999d82213ee6ee5b5b495be1ea4fab105b673f2feae0780650f07e8bd149556750289b7c2c3d5193ff3fa89223072c9482df4a4002c0d13b4b749113fda65f5de23a28a622b9fe651b6fd2b742aade29fbf969e8ba203613bb2b3330c7f4c161e115ca5c95125d939b755ea2e0dfa1036c47687440f83a3c38f5aa876d6d1031e1f2f3cc8471dec10222ea4d2ca6949d5732708cc84808fc4c7a740f1f859504ffc66b73668f8b424a1586c130637b725f790dbc4c9a9a8c49d6e096756f8bbe11f3acf12bac07f69bc26b935a9f9bc43b21d26fb62b8ab50c528a6c5d04d06ad2d4359e1433f630cbb040a3d3dcc5963ab7979dffbc75cc5c22045fb3f177e70b85436025259afc2c2008412c16f27419af2c3bc4c8dd978577cdc4b1928d6058c5211c176bcafb8b683fcdd87036114e3e79991d732fb274e3689a78ee5f1a6ad57f46f736d2a5493bb1cd2a9974caa4ca467edbdf71aedb9d9eb5a2732695e72", "9565b47ed14324e0a6b926722e26fe595742eaee031b70068e30acb90d7364bc49c1e8dedc09891c791be7648afe495bb8184b0186b0f78fb3ee22d4655d236b59993d0d90054a27d11050d5a79772af48e93574753e57b7994743b0a3f5e79584f9e900e93444b7ac7d4b1e6ad035cc77e946790b804c4983d8030074c56c008e72c19a97f7652594e7291da68d89e42d349d88e039d4ce58c43bf5b21b618a5fc72c45b60f704186a7c60f729b31bf270f0140a5700f7e0604696edcbc822c53607e77892a4a322baed37eabdfb1c06eaf662f21fd4cf6b2d1362104f767fdb7f5e64a394488a444fbbafc8f1bd517492ac199225a724c9661450a2dad688b89cd5b63364a7864fe8d61a3865689d0491723cb30fe4dbf3b2c4dc29fd0c169f5adf2fbb9d74aa6ef264af88c230d1a39f364ad538d2ff6939b9a12e13e763f1fcd17532c315eb01e1cd0f29f99a12d"],
        ["99b6784c7e438736364d30feffe5a2f499df1775bafae1200ce39414377384f5cc5f529323f6eca74edae535232b0591945e7975f68575847894a536daf1d6d520c0e3fbec05670fc2686eb879c38f66dc9710b4824aea9bfef4027eb43fb2a3aa6b62128a7a900bfb1340950332fbd1c8576cc8817108eba94194167b0701def6bb5fb4029113630d07785d39f6fc7b54ac0c87b298f9e90da1021fb4b57d10726e56ace26537dacc102e5a9bf0abf71def2e0c8fad19010c8328741d8fff1a0a9a5cddf4bee45ca4152124bf6f51b3477ec6f4c750bc5a6836f9ff13ebf1452d1e0f9744155ae9f5cef5062aee0920053dcef6035de29782c1a6b737289cd54be13178103c68659791fc1b9620e5684966766a8a6c4fec1576d72ce8d3fde19ca3cee0cbb198f2f0ba3f69fff2c6e122138570063737ce6a3d1511f4e69307f766cb69bf0225990cac542aac1407706190d523cbc623271e71f28254c9a1e4c4a82463ecd47e1ab8fd046cfb03c9b56ede9d5026e20cf92fe07916760922dc9243b275ea5ced91d3b87dea1301cb9b4c550d38bd3763afd60529ced0ef571a70c898b533e0c6f423a97e9e50916a5a71ff6d6b0cddaefa724186f5147efda8dd32791372969c402d368a130ee50ad13a151d3604627325c316d60a844043534c8d5286bbd0fe195e75506e6ef38f5c", "b29d201287d6e19d6911a499406e1a6553ce159c9ff9506d795358899d2d9ef990f3515b485df89e654eb2c3ba23e244b53e72043d16746de95f10356dec64873f18337d8b7093418631de5624a877f5cc3366ad79746c2cc53e325cd689cac983a7dc57d36b70b28e4bd6f25eb0e18817abb3ef01c987bc69c20814546f1dbd6337f0043f88195981f4fe321dff900b4f71f675ee2f921d63c6578fb0fff9d7726d3c191243b93b97919e33293079c52db19850d4fbcdfd70b876839bc5748f8a2455c8f1d0707d904c3dcb7346936c3e9794aeb76a9c018cd61cfc71a0f0f27ae5527eac4e447108831622c446cfd322162c689d8b11e7e8c7dba3f88322df22bdf512eb60c23973e15f2bedaf2373341e9a98860a62bec21337062cbe2f59c54c5448397579d95b26bd939167cf20434e88250ee6d07481372ba37e292d751b8533f426d7065b27eb2e2a2ec6073a072dcdb290450ae9e40b7e88ffbac40af41ef9e432c806f90d0b1584bd12bc6321b122364f5a666952d64fdbaadcfee58f38c709abc16e731bd3aea9cd18f68c2cc7ef2aa45a5a8609c36b7f038d6335183bd740690d3a3b46eae7d167bd851a729534de239fa5d4faae1992f0c081a63265002e3bf24416df69d6151f2d67d8", "8dd1ff608f18900396edd04b99ae7b80c1a6db4d02aeb0afffc52110487f3273f8b9eef2eeb66327a8eed71a4ed5362dae6d077987888e3685f7765a16584e3a9df064f7f65050cae4a5bacc8ee738ce71315f3ed495891775658ce925aa018897540e3d13d1e0e13e6b9c88db4a8f61eb9a68bbb09e261d043dd88636c2abb42c4af7fc7e99623eae04f0f287122c9d6fb908ae1c273bfd204a59ef84cacdd15b91a9cf278dcded16636c68be270ac410b6dbb20b7ebe4a20aad229050d3bd4262713958a587ca81f5399d4414027c729c5a802821e302a940b770dca2061c2cb1952aea4d75db09990afd058698ebd3278ff67589288be759a71a3104c7809c9f710e6d0ddd123801fb772699eeac802130f8d54ade055d6cd4846c92eb2cd67c979d15c09a157d1faa986545ae7e2298e0eee653e4e1c14ef43ca48f1a1208c9ad845c2bebe1d13e3a76f8dac4ab6529fcffda4aef55b9429fc7e8364e2624c0b5f85d66bf830cf85d5c5ba7a4d2042d808f006abb09d71343ef512d340b9588ace0c3299a8062d35547a7a9e26363e9246aaee6dd1bcaf8c1a206edde5b9809e8f107c26004a57efbf8c1ec25194", "94dca0257e2626bdc1d2a4ea6192476f174cb3e671aa0b906f34175054c7b870a6c2fca994efe6cce3cb60ca71104f38a63dbf17e11f2c0b8d58311758111f8dcbe9a677694fcf9d751c2dfc6737248915a46c399c09786dec8c2639db449cb2b69a47a667bb8efe8a7c4d05b68d0bf5d6209031bbd3e36e284567b1a6054dd06a0e0c04aef0d8aee42f532d5c292c6753473d8067c5bc6635b971aa51100d0d92468ae68846cf67460afb6c5487e8a272d362add890d1b70a49dca1b538cc386039767a5f24db789c01386b5a4e896c2cf5652ea2a38ccabc25b76a1ec6daaffa61b5ae97f94960d064507d3ab946ae6fd44bbbd199616dc4b254e8283272bc85645d7e81a847ddc0a77bb2db53b5d522205e26084a4718b554be70b3dc64a559de655db6a07a1b4ff85b1be8a8374437efafffec0e0cbb726a1610543a3919120a803e7a241f3034538d928de9f6e25367ffd5584ac6473cd6038b627ceb6a44e865cf460e7beec78be58cf5250fb7087bea68b1cebd4af5501eecf605157b8f2d58d45640d649ca07b0660b9b9b08", "b3972e7571cb5572a04d6261080390786a9ddbc7bf0913b8f465b245f5b124858f9b14aec44ca845ba1407b0b8705ff1b92fc90a036408281f52f9bdee423d0d5de57e50c9b1f07cdbdb437808a662b6174798497ec6f34d3563a00f2c5ba05eb47b6850e1ae9851cdbbc92b6432316daa776dad956f2e2e04de7a3d0ed00a4554a63b724d7421e63f5292133d42017611302fb2e0ca670cd891c1fda3d9210086167e6d228e240db88a06fcb35de7df1d43cbf08822a4af0cad02c5e18dec56a8265b6123d6b325cc26a359aad114256b36b6633ce154dda5ffec9b7de6126dcf6162a3750cc24f907ca8222d1c8803197de156f7ea45b66b961f539be27537066030aacb08d39aba9a5eda38a79843089654e0dc2481c123226636d8f2c16c6c1642917cd1d7933369b52aa583c3e41468c72f9b111de40d2271e96920cb4624d3209abd1cd3628ec93d498877d04c25b815bad7db163fd51e4461a343067190b3fa0d4f3a391849c83a94216e81ad", "821a273c431673ece9c29e9875215c1849a756e1dbf34e89c250db9f7434933ab31fd670b839376bcac19d14fa536a61a21eb003bad4a17357964143b9ebb044292f240b521135b3d816236516f6ef7f758460b231928db4366b58e46be32426af705613830495c84106d90e81ac96c212daa10fca2d4e182e33c478f76c0ecffdbfdaadfc8bc864e26d6f375d5e7318114b0a440c48064095eca2f96652a848fcdd04f751854c73f2407aff3a9641105754270a5c75ec6279f470504b8071e669842e879548cc8d559bf858c0a5cc8367229cdeaeda32124eafe3ed1f863c654ed268e7c59de7b98d63283aeec9e6e30726463704540b1c8eb51a72a59025135a8c045d7db55bb531ba0d61506b6c60393dcc1afb30b81339364a25f4747b1c957de71d6259cdfa1f50243d5e9451c35ceafd234fb4cdd952a6e08890c31132fd2cf671a5fa7076f74e2daf6f7569dc"],
        ["a69cace3ccfab303d94cb172249068b8e46bc3ac2ec72c480a99651d50241055126d29531ef75ab1c0e9a44f3559a6938b63f0b049435666d7c15279873fd80d1064327b2161385c6f7540b8e91a4d0bfa204edd79e3e4996f864a2c03103983ab36c770405c3e9bc11820217f1dd019c35e076c25265870b35e2a592f72ed76d7d72c370ee8225e7318729cf68dc4ef4de29a659dc452884acde555abbf9723c15ecda916fba24c5c9cd700f699350d1fb3729d7378c05f9b850a566b068c9966d54baef7091a302a1faedcf79afc9d1dfe61aadea5735e470c1fa3bba79e8f0d9530bfdc7bc338b5c0426d58052b8f4dfc46dcda2bcbdfd1653eb29baffa4b86ea1767f1338942beb4a9b56fb653777386316050d25bf8364148d069eb5472ed75e50d23580d8901023f1f2148b5d934f30ca7625076039ae975a2976ee3d427cf098a18383a95a04c87e6866d6fbf658bdd89e3d0800a2caa2d686998b355aad0302a0ac0dd2442863b64033c1b180d517aa0e001e405a729c38efa4abc87d7a6cc46dfc2145bf656cb7275689dbc3088751f0fff263fee3d22e71a8e8291905bcc8b6c39c45c9256d352549434161cd7a8ea15d6b5173a8ad7c4f510f9d34e6eca53e515e7c972960b4a1bfbdf145d509e2bad222b285bc496b96dd407705e76913681546a9822259764908e0525", "a7e957daddf78b18d17aa552920558f555a07789befa52870b76bb9007b1873936d0bddfae69d5ec7918a4c414618bcf971094d36f478562609d4709cfa29395b643f1c6fc972b0fc512ed143a889d77d4c0b2a64a4a10196706331ac449e609a2f698375ad9b63b4bdf81fc19287f7485daa8bf4488aa59d51c899eebbe276ae45429f3b9c4d4128a45c05f6682d5c4699ffa0af24dd345fa5329d4e9667d65694b8e6208224e0e1f3587169222b56940b430918998a5b862e3d213cf6dbb3403b1ef5faba7de40a42ae48116c1c7cf252775458ec64ba12abe50377115cc1705731c8bcd90726e472bc46b32b634940a7f7c6d27ad39866cfdbd9e5272f843f4febed1b83212004b7f6c575675edd8713b1a98832977c933438e4a6f1ae3df96887d9f2c423032aed5f0345b75f7b3714f65420ce2c0e531f66a51996ccb993fba3d7915a6aa5796339296a87e2ea44d51076250dffbae45d6073f345f0b63bf69fc607df257bce009abd7dc7bb8b619fa3282d93b4df02665143e15a4cbe2ffb6009fd65be6a7ecb187c7de6de56e01bfe0e4c4644a76b2cbfa986fd4bc81a438aeedfcb773b6061ba2c298cb91b3419bf9405b9536fea7e9ac54a1437c3fefd91823c9e197deb726359d2692ac5c", "99c7444f70fdded323acf1e9627b4e0ee886a83db01c851b9093c85af36728c1590b90564a0db617f87bc27c8df0bff1a0facb20cb32c17e7ce862c9d69ff3427822c18c4ceff5e82f51a0efae064416ece80b24e2187167964ddf52235739fa8fcab578db98cfb8b8cb338604a4660fbf7561ba580bfe6d26fdd89443da11805e320e12309ea72ccebc5e809688574a1f96b0e70953b70571d458691b00c35ba12784124a4585552c50851cf4c858e54aa343b588571446ed3fc7415eb6f532b2cb08e87d47ee53d997125020aec53d4dbc2fedcf8e6555e112a9809cb93cf3312a92d760662aabf37c61e8832c7c946beaee1db17c473e7e784ee3a2239cca2ce86db22c53c1c4f3eb4954b976d2844cb846fe096606cef5fae1fd5d0f2831bd2f77d99cc0ebe7b92db22e18d9b0e17114193ef2950e140994c909fbd99f8ef10882734d98c8ff5b938ccd7352c65d4e49fa27f6d785cefac125d83c2793f3490c7758988bc40b1e7aba564465f0ee569b91625cd2b0205274f9c1a9680c7e1f0051c4c609400ecbc5da2f0b2003d134d5e6a74e8f7c4425be83d49e24cd89594b27987e82c0e1dc12357c5ecb3b6f", "856a412da19d583d9b4f43cfe623d6389d97aacddcd10670e0bc0ced02cf96bf4171e8dfa1972ab555760ebdd8768af7966aba266a4dcd205788605ce0fcb55474dcf425f488d69b0009b7181da650ec76570530551f0596791afcf5afc9f9d8880130a412d2c8bd507a2a91f18abfdb58c6cd42e49e4f74c69c04be5787a9b99c9380f0ec16b87948546d9a122d404c287c9b916997e0230c82821ebeae136f79a917f8bac6a8bff29a254819c4583a4e5ab86e42f3b0be7cb248a850dea997708f390a83e308968b96030296f7eb9d5bd581cbd562ff7ad6fdc254c8519a7c5abaa69343255751d8c7b41e3dbffbe452cca82fdad54e0bab669db1175100e2695104ecafa54526810a76e93b14280349d63f9130d5b5cb5a616e6e0911d7074e376450fb51dfc353fa7dc72496837f4e44125b04be045ffce16499886eeb6c8dfbdb604425253df11709788e1fe70b1f0ab7728cd5f0bb0150eca341c5f6b7a4ee36a5bca0d4dd8168a2c6171e3d430abb971ab7f4b6dc343ab56b0da637330c39ac37c2097975188f9d3c20d73405", "a171010a58d71cff224050bec131cade33971a350f3f963039983e41b36620fab8cfd7d8a35d90ca08a09b1738fa351786a7ceb4cc13500216efda1f58218b34c5862313680c1731b665435700ed63d9e7bb1b1a5fde7b65a913cd240af8392cb902ecb46caa194a248ce2533fad682cd94e30ef24819fc7414c8ae89437d9be2ae7c6ae3c934939eca5b5920bd390502c0e450903d5b6f84c19ec41960519fe21c40eed9435cc6f11dfc18efbd6a2363bb3b9f28dfe9c9c7b30751e6d29e6f38d2a45a4f531d4b3f5f40615cf02996e2fb01114254227213ee797f81fa61d869e486e8eb6d27c2a71331217b51605665bd5e0ac344cb90495dc697a40bb9a99fd48b7c810ede16a8ef7322abdb014b44723651955e1e07fa80cb5603a5c410a729894e12c5056fcfe612b62ab2578c34efa6c5cd4487fe9348c0742e30b8da627e695a9f15a0d8a70a4a050dead80a4664a8bcb97d4d30f3b6dbeb4056b91bf89b50e511ff82cffb8c285c6b5b5d083", "b110afa775c3a1b44866c1363866c7ccc40ebbe85ca68e9b0964b0ee950c406db7bfe4bf2420783117d7733d892e96d2807201f4d24f96306fe4463103c4aba3614fee5bd70dcf6b38455ae95a73a97d9aba5841968a14a92124dede543242f59819af3c8ab618ec14839f096db1028cb3e948f427a70b2d4f87adc8d1b2efe16ed80e8109ef6ab7fdc6742ff258e4b44e823337f1cb4bf54254ea8a2abe48b7c507c020a387211864dba07ca1a95ebd6e74800e53e66b6aee8c1fc54e21531dc6ed3967f2b91f208ea1518d21ee91ed6f5a1628db229a4476e434be4ff2518d571bc69be98dc2c5e8e6004d7724380f4ee32ce217a680619ca8dc360403df55a59021b210c69105e031ab1660fa84c2700b9bc0302f5175afc1d7e0f87ab9891baabbdc38f8de36c7e45c97557af850563b00011efb17195c02a578047271874874282f701ae0198839a2df38759a8e"],
        ["ae75660a0eb92c0d9e9efff99c3eb8de60bba80e3eb599239e6b654d3328b7bcf1130c8fae339d2d8f85a8e0f5cc807691e82a7308cbd2820b8a161b961eab829f12ba7fe9f0dad290d99ceba6bf3e0a93894f9f9534b00cc3e41ff8feafcd7688645825b6e9a453f64b01cf714545ef531ef3cc0c7431686f587564a9cda512e4ce9eada18094c3b6ab8e08e320551e2f249d0a301120d632676c3325f5c7841f02663362c30b41ec57ef6fc9bfbfe44518fdbeac9777ab0dbe168835ea63871d59fa53d308775013db7890933b8f1a680d757a92f306b5fb8d85b81ec5c2de38b83db8916ae3b257ead1bad4eae9435c48849bb1fdc4d7744d43b585615a93b4323636d11c23cea76a29dd607f55746412dfb99157f5c958b866c48ab3cb591f18865e1c144d3487271273fc30bd9f6a000236934655cf930a7c2409ffb9a70e54e420cd1d423b88dacd5da49dbb8e533c9bf2fd27df50bdb6790f835ab6b623dfcd3194fdead55ca984665fefed5b15c610dfeb83b458c558e8d371c6f45f72d05000c80377aabff47747140e97ab47ac605ed1ee6ce7563479b78b18cace016439b303e42b0b46aaa6bfd6127da86c49c43d7de9853cc0440d2492dff2039d347cb5446f25c83f8f5f1a89361b343d6421115b2bfd8089d20e3b94f6a96f9706e03a84a1eb4d391d5ef87f87e4f0", "94275170dfa8c763ffa60d6a794f2385702baa175b4b8ca9b68713ac741c750a5caa4d908162605ae0027f2fe887b024a295bac7bb3c63e6602865aa7b217433ecef7bc2651ec0e721ae7e565f747e5b7c2e6a796553f6be3847d997c4d529dbb3b6acc1ccef2141a99f991430755eb7d581b10d671f4f7e7393457ffcf172600c527d912c2069462cbc3a5c4202053320e37e5997a1dda654c8321b15d2024cc65e9de947b8144328bbe6ca62b763a9243c36010e59efc2b289c224f1cdc35b77f13608117d741235b3c9f65b7235bd3c4f85b86a1cd4e1d613e13b1018585721ef1f111b531f6300304c8666c744320f22a21820270a01f9bd94e1888b8984d973cc3559a466d9227ad68c7dd4e13b2285f702e0e38e086c4a663704a78576c1a52a40785d15a40af0ef15739d0fc63cf0443788b2e5e5ed7ea02d1a491536a6803a0128d99e13279b613b8e602f7a0c8a2468ac6914aa0b2dcc3021b1da5c40f1682fa86890807ce2e68ba1bf5059170feb1ec0164063f3b98fd14f33740109a29b37afc5c426062a84c4de6bec9a518ce229b3642b3c25d8ded8b31e51780b33ff443077b5cdc7af079fe3a2742a6db3973cba3f105c2dd2918fb87ac930715fcc9ca6b6b39c0f0ce072b3f42404", "a128867fefb5f524d2214128e156cd9580096539443a19bc4d9a7f2fe8ad33be7b9e437dc8f90e1f8587bfdd41de7341a8d4b9e6d32632c9cc72f927edd4c8129e4af5402c5ca25ef5b9572d1e29bd97c530545fd1f0b1fbc54641ca54c618eaa67b73801b862d054cba7d240b10faca4621cb14f87a99ddc25ac400a6755a16ba3bf275f822a87afc1c617bc01fec445b8b219a6ccfadd9af5097c7f3c56304e2d5506ba2e45547a61a73f4d9f0e5120995bc8a268464d47d21e36912ae10dbd05941d3c08f44b2a3aca7ecd3113512339a7955ddd945fcbe6b3cee8fce95ed9944816e99b8ce4f85b78c40d6ed2be9240a739f5543785011d74a7caa8b141065d5b689c8c39c9164d5e374fe99e7ba5050f183d333d4932d3b416b1f1b1cdb27eb7db19959a4b506a452e19cef3fe91a5e45a0982e517967302dc85e941a1d8fc73df5c9cfc90e958c1af5b66a84365255df03ad4c51e93ecf100984afc48100f0685cd96b2d06bbbe4112add676f2602d8498d7d86a6c4edc8864d7cea33c71801e48fbfb76549402dc006d9f829824bc58ae31ba8ac96c4d269bec76f6511f6bb6a968a89dc0a647f7d77ed3e9bc", "a87be748534784d4dbef90874ceee93ecc14bb353c399534accc030ba3a7c35b3a97138d64f730630a52f6a759a73ceeabd3e05e6ff31bac20e15d85c50a9689085b27eea1e7190843055f23b96f11e15841a6bcb304bd899f352ed971dded31b263642aa472133539abc4b1479402fbd447da7ddeb3901f7a6832fa5c1617a4b98861d042a1f41672a22f765cff95cb4dcb71dfe0beebc4d34fd5f3baf9417573045ac1f7dc3a2356c2cc788e1f7da2079c94cdf71a1d7e4a6386d352429788d60ef6c66434b471e9eaa2b470b1ff65439a912eeb18f4e5eee16acd4251ba13685826a61bdaa573c54d508e343e375c0779e5719aed8c82151f1b44e4554ff2bf7b81a0efa9276160207214cfbc59310c9155929ba9f33da2a5b16358c77d9c039eaa49dc0fabd3f3c48b333dcd0b7c2f80ded0f3af548fb05fed553b156c5bc98e62b4832ecfd8f7b1f474073daa552ae6a36a666148f15561ecde8a67f4dc2ad2436414e53af5a2803c2f7808b82146bae1dad80a78d79a7382a108c124eef6449e3c6d3264f84eef5ea09f2057e0", "8a6bc1d7e97815e968514cfd8f6e166a2065646b1adca2af58a3739e9d615462ca94ecc39949d07191dd6a732a3fba51812f7050b37b0cbc773ee095ee68b6fbe5479e15420dd03b3a758a81c1bf14b9f44958e91d9bd379b2658a0b784a8109a6d8fc1abced1d524405c46844ac48aa9b2562e3fa65527afbdb9e0076dca67a890921cf95b373ff216178a8df780364488f45409006ff11371c7037055b4436d778179502580c73d92fb1eb2053fa694a67f93ec4ab1632c6948dd38a3131d52ce5cde3d752e7ce6edb621950062236169e21cb3b61cebace5e5dc9e78a77e74621a9131c6e9da0a1c890b3e4a8d64d1aefc6d7a7c1b23d5b85003c22da36f85020f9b8c19ae0f58369438993ca009e58a2bbd04f5e055445e94c6505597f2d5d72c3d0184ae1a270ae64f8e27705ee4c1925ac56ab67ce69908ca16ffe4a9276cf2e5fbaf7a38c0ee6b4c2cc5b0518199a3675762f1fefa00e06f14371c09634630b84568ef117c5bf694d6222545c", "a9772b532e447cc5ab6c881d204950f5feb1a0aab0810abd7626d9794da500b0818052d3a35ed506f8ace72c67bc12288c0ec2bcd5e9d2aaef514106790e94f50abb37cbfaad59ed4d7ddb91833fa5fb111e0ced1f8f5f1be5338990588fe4e8b0ce929bd0b634e27146db6168170abe9ee23f1ba8ed5e64f2c5e4a8f5a52bb5e0c139127402a06c34688e25f99701d32c9894ce7d921e63937fb307bf014355d0013cfa29d23aeb38e5704a322194736dbe5ded59502bc363b8d16e40afbe548a277a8d13fef66ca81b53f7df5b951c32dec995139047bba5d268e602d3ac6aa82d6292f2555e112e39ce7b6b75ffbc0854d8246610972143f80c5a7885325007be61110099f004b7960027fd3a07d7409746aea8db2258c426cc5b3a61274064aab0306084ca443d1aca2a87c8927c00306848b9b24b40da06b6693bbfc50ff79f63d5b101016581428da466bea1ae"],
        ["879552a849dd5dbf97df2a746c2b0ebf9351100a75417a1afba8a9840210f6045c2eb9da225f0907385fc50565209d71abaee3084995db8c28a20d38001b9136b085483d42f2c7ac4023d450c23856af38e7c5723332c098e92bef99bd25a8beaae8390eaa528a52560fe56bc10023ad87a386a60cefbf4df9ebc6fb332e15af27213507545e30263ebb4a070c2bc35f070a1c342beaffcb75a870ee80f7bf1670b92f164842a8d82bf9a15c2e899c8a532dcd7d53a829e754b3fd9d2c6b6e07e8b5ce61413b91eb9760c6a748b925472f565b2bd6f8439e4ef155609f6c29e9b6a82eec006e6b00dfa52fd40e4b802d35fbbee69e6a8292d2c41b3e88b2bd3e22126e4cdb1715a8b63f82525aee7eac2c8b54db4b8820ac94f6a2900f8bf07274bef5edc5759615a30b2aa0ca60e1eb3b6bd6166e894550bdcc804622396b6a24b8a9a18e5bae668ad99c9ca96dcda014be941a73c7824015901a30196e72ddfee3db51319f12ce1dd39a63f19ff27820a26efd5dc575fe4841bb47125f125ba0a7aa406b1cea289695b5830818ec935978895f109bb3e69fa12c0facdc8dd5293dc03fb65a0d587ddc2dace655f2584aea7477d8603d9c11e8bf75704abfb9312d50581ec02865a83753d22999667c3be648db422aa1179364220d462af3029fa279e2bc129c34ed6b5767d3157829", "8e1ce1b59f9e5bf60ab943154e3d67a1134cc26a970c1c4bb0adc242d7529c25b73ca1b28de2beea399feccb1c0650bd8fd2b50ca1ba7921ec08d0424938f78e5e84cc5bccdcb95c73c598ea323eaa618e06835bb7ee2ee06d20be4ab2f9c6ef803c0349e7c3c7244c6069a4e673b08d78d248a1a8d1b7092864d051e8da59ce71066a4ecda55e78b98e1b624faed10609093acccb91813312bd2acca42b01941857bb8e936ea6c5aa04637df6fee2412d46be291126bcc4fa767217bfa3f41918e8ac3ebb5ca654b1fc7d8bcc4efe8072a7767bf9aea7f96068fb9dbf959aa29bccadada961573d11c3281a78e3fe94722fe9d132530bf5ea586e6e533b16c2dd3c7a1145c0ba2c2237ec9abe4d95ee55c2d682c593dcb0eb5874a41552a2f26fcc9c7ca9172eb1a865f980626b70f80476c05dc89e05f0764f3a0f0a3eca969ec40c7991642577364db9c9efff2ae45c190c4a41623bb8b02cc67c912014904d654a16935990225a0ee982f744b55303b07c70dc9ede8edfbe7ff9fadcb2bd440c95d7286fecaa59f6e495fbd6efa562d83189b8757ed2370cefce3825dcc772a34829b0f202d5bd4a8bdd664007e060c4ee49238d645dd45e4b64f3ce1b875b771bd4e74db68ed72dcfd14fda8e28", "a30f66ed4bcef18d4e5b00b022c0e1673795cd677eeb0e99933c2d8cab929a493fa4bf0793488a50dc17f6a1522969f78f1c9a559bfb49b0583e355166599a2111167ff6199e9727001208a6cca9ab08502c70552510a4507b7f9145860a25c6ab3aba9db09ca51177eca2322957106b8e8461cdf668ffd1d2a97280cb07fba0a6afad2e74aa5f05f5f79032509da3342f037640b807057cedc471f39defa5779aeb03ab71d062c60879251dab0828795a1195ab4e7359b3624103183eff0429a399f01c9b6b52e77d877b5163e1a5802837fdebdc67f84765d685672c9331f2633fa1c7d038ce6b1278fc7cea98f61b3c58310e0a2e847371dc00239e3e24d75dd89635bfd0dd134b1dd8195d06db9970cc557324276994722375d6518f750b1fcf262d3d60d30fce16f6d52b3735ba70c4a675efee3d25d3fc15600bed64bccc341c202b1b4934f336fa1d31c9315831d9dc4579227c453791c130b61466217f61d24f66f65eb02abda7caab7f95be1d2c3dfb25b40e1a070f0ad83974e4a3e214637bdc8fa5b99b70610e36f2704d5fd136e418e4e78f9f4dd4cdf495f947eb60cf38b44393b7c6fcd257b1af0fb6", "a227c9a863aa86b5b82714c07038e85aef3fdd938db102e7147fd123ac83e260b80d7d9cdb57272a6d6930691eb9ced1b9eb79f714e879f25e3a75d17fd1c6f4d97cc6e9cb1e39089b091a358c0bb95a61d0e868f3489f46a2918b49b0ba980285d4caf093646e50d5b6b8b3b9b1324fe4c67c3b66e49882608bf79803ac4e67c7898bc0f4aad493abb035e2f9a9d64c066f385e123ae6b32a1a50643e265815615532d4c2f8ef782d63b550c4e5b4c55230d7114be8f04b3e368b5009d01325103b78441fd24f8741112520b455c6f906d1f978e44b114fa34d41a2b726bef617bea2b715a66cf86b09646f2b86e87562b097ce69b38b39c51fc1e19eee4e50987bc92339d5175d2f625f25eea373cd05c782938543ecd90185b1ea635805aa8db1372f360ef1c382a56ffa7f3acd8858f7071f2a65b52661abc6493d48106e0c83b33727815b58e63a3a03b0f530a33bb016aa2559cbb4a5aff24cecc328c7a4c3d1ad1e6764ed0841e78da27a6aae2dde8213604d309a4b69c1f35d55d385b5aa8ab56979eb4769ec25b313fcec8e", "b73a8db2dfc6d0d0de292c0fb95d72c87ec9315d5ac71507ab80d3983046b300642d0422beddd3ed3884cb584588825e92a313d5e36e337ff9a90cdc154edfb3b05dad7582414ea98425df8b93b516a8d35824ee3f5978235b2d81297bea27cd9350139c9538bd85857849a5c809387ec3f7a82082c5a8f631b59b143414b4fdfed4abb10ac5be6735d384f2ef6735ec3c41df6e9aa1e071e0ae80f3afc5ae720e6b0d43ebeaf81b512c726b171051f216b4ed062c0b39eb3a5aefd4b8066d49ba283d745da903b7fdc9c81066f756df6f19993802880ecab73740b4dbf269bf754ada47adfb59d63335abc624b180d90f6efbb131ab802a56d981f3cd76caa672e143c5df3b60356d37281e31060f43296e57d842e78b4a77b405b8e9c672ec1d56677bb01e3855398604480cc1e2be0af61b48258107f9a6720e0217804ad98c4904908c03b10165ecc2c166f661694cdc6b23ddc756cf8eb41e0010e1836ff1ed3709ce7d76474affe1353c88679d", "98ad3b6915e6377467d2f0c71c761f8d5acb8889059dfbe45087d9b60531207eb3adb8b8d31f0432c6b17bf9a576688f86a19543ac070319276210d7db42a93653bc8a4d554f517cac28689f32fd0f12de11b3a1ea7446b340f56fd6ab1553d182a806c414d982c24e4894c942abec5ced4b1c0eea80c5df5014a0b053946dfbb2c9a3710882ed315e4d1c2318766d8a3642501e07d184ecf793b979de634d04358da7e095250f019738fa8474b092a64799736413ee7e7dae6f3fc1a069f23abb2609198e7173401b5477488160cd9934a4b61b03a72295e139c17958a6cae28359a64ec90f6001bac2e1e4c540bd6e14938dd1fcf95fcd4c7bbe0ee32918dea63fc6443be5bfaf947b1734cdbc4ba918917344936ef0de69d357f1c2b879c610f263526848b2ea9408f8d4b4f0b18f5c54c84948cc81bd44ab9db8498ac64e7c6030c649891d29afcbcb98f386d497"],
        ["81cf5a6c86046ca16505ad24b9060c50a0832c3144e44eea7e697710828979f356679ef16c6d2fd2c92b56f9a67c87a7b05db81b92de71079f0e741d3b8ddef6d4aa833a15a11fed6dc7d2014f818252f92e72a4d972bd04664fea7fa370b8faa61290007be356641b87eb4be652741efad0b6335aff9093af45238210aa0160dda277ea1ff5bf28dfd18aa01b10e6822544a1c4efcf602a734aca028fe92e28db51261305cdc10955bb27246e209b8a0e51ae9942cfe81956309d0146720c70f5fc51d1eb2267bc9b9fd908904c31c56216290596a5025e0c5ecfd5e117cdcac967661aad5fc87be4db1fffc0dcb0791a8612135b7b38b85e0b6c8fb878c2be50706adcb42557d6360c6bb2c878c02065f1faebd6c102a1b8939eb7df0e9fd6dbf70e61e9c1418dc9ceab1d27c2bfa85a939f231a94301644caf841d82442b48cc6f0ad01593118d26b58465e81f7aa3a3cac98b9b253ad07b26cf57103418b25e0d91b1ec7212a782ec07ef4e6294c000725b35642d603456b7a821738c174ac9c531512d3189874d4203ba958ac730af1eedae01462700b8f2830fcbf888d0d107266ee964227901b9704ffe5e1871fda214a84b150b1740b5c83fcef04dd9d784ca48040614278b7016e7292d4881ea864508452d20328ebce9dc4b017a54987823f55fc3e7dd09a35a184871644", "8136cdf9a0f8f00aeff3bd8de2dbe8bb8fcdadcb8f9c1588998907f5b99030590a5436259e3488e573ac591c773117a48adde6922b893a7682f5c0023352adb374715bd7e06e8cd9fd669a81acb213410da5e24c0d59af0714bb78348c9a811c8b4e0683b47ba3b3bc9fb4e9901394892327edc9c107e1861116534721ee39e78ba4e180cb64c30245ca4c90be75737f009d7a90944d7411840e46870c5491bca4d165990cf29f2c52e3653aa7c6329b326ca4bf5f17071a822ce59b2247eb937942baa79f2face91b6401481f3981b950a2c9ccc54487df8b7889dcd9ba34ec2bbae6d143b9ed0de43b4294a673b3b127c2a00163f6f28b4bb8a5c4fc641bfe59a49bc4c46de25a1cb7a07f4442677b443d0f79e0d3660780f428a2ba477a930f61c6f914fbbce0e1ee583224cc76f82ca6945e3d806fd31769014cfac849609648cd5b3f6d1c96be6ee8634ddde1905e86405b9b896575278265e1bf56349f78ac281b546488f93fe20dc1a87e3bee2dcf9a8369b6174a6c2440d55caad2d702131ba243684a4d96f56bb7a6accf4327640da324ae0419008f3c4c27b1f927d3ced60cf0c574193fed9736250991e54d920e88b386037d4aed84bd803400f183a3c5803315976657db015087aedb38", "815bcc3974142077646bbe876a5824ccfe7fc1fbfa2011189d1052b0e4831560b7c2f5c8a4fb8040ec9e267295482d57afb89ddfa356b047a7109f2a62e0e6fd4f7070ad890c7db0590fa049ef9ade02644e324aee089776c507dfa582e4fd6b823db172553c8dcdba17eebf72f7d700e63bc746ba3a38e5a398d07dfb6c3c1cd66d7e823db4d01373714597c551a73273464a001b766267227743a9b32b314f6b75a4c5f9c80d097c25499ab347746f648322679e436a8de4d2637337663018514e9fbd79317f77999d417fd09fd2e1163ff49ead5ce462a9502e1ea44aa2e794f4b491834403b06bfd050b26c562df57632beff48e2f3c85b9d40ee3ea1dff61bd26648017917d1e30855ae36623714c90e4c00e844a775c183de4f2f695ccdfb4d070e6f71542090ed90198297c5c47ba6d6d802bd5902307d92f531846be596484a69b485b24694d21b9c2a89faa32d7a602751304cb679b09af4264971f4d47f8d3d7809a5b24715038afa0dfff723be965d0d63b148db08f9f70b165d885c8ab2ad3077decfa900a1388ace6d856edaa3fa28340c3920e97e9a1c4009ce3a624936f99dd26631374d1bac0a829", "b9e993c4619f24e9471031373bde180557670907fc755dc0415da12be5c2f1b18aefeaee974c6f17613992e43ca1996aa20d9c08f9418af3d87d4ab9c9a5a7267fb73528ccc9e6f61131a41df0ea3649b6548f776fccb1980244ef06bdb903d5a911c94edc0a3e6c45649edd21d1d241f299cd979a5734693c6bf8771e95e41fee2e8a0bcff7f30aec8d612c7fc087b50e8cdb38eb76fdfb2a949ef84b7c47becb97e1ed83276eca70b7c23278a1f0b46e0add1f991d0e9d6559e4f69037e2f8fb46561df9d8ad9c5c8f53ac8a3cb9a82f1ecd2b9c3435b48f1aaf27644977cf4289ab869d2688cc888ea8e596409e940d8370923b7fb3214e22c4df6de7ad21943df372bb44b017705a87df0eb8eff659948cd3dbf4c483e5de404e0835fed802a47fbead3bddafa865fa64265be3133a5cfda571afb36f439b1db324ac5e62faba454d0752e958e7c5f0a8ec5211ed1ce7af82e9b5d7167de9febbe185f125eefb7ac3eb150d1cfdde041d0ea1cba50f6a7040b3849fc3facd61fed1c73a1191d227c7d73c0b08dec89ac99e27f98f", "977cfeb37bc945d76fd78d146e872fc3e6e7cbdc0f576585cccb670eda364e1ab8ab50b21b9535d4444423e1be4340fe809be9cca4a31af6cf841c24372d80da0785a9978efd44a1ec383ecb2eecd6f87b4b59b44135ed17769397cbdf473700830c7d06046b0ec242f3b3cfb024cdc5eb9926c86977318e5e20a4d17c94996bdb8b2da8711688d301a6c09bfe1109c756769c72f9bbaf9e07e87aa1872a2bb6db6a0f5ddb54055185324434d030dd8b608152c98f5dd6298a9f3efbe2c3ca6f6c92fc5716dd9f19d4fcc3b43d6dd80200d29ccfec268becd0319593258f3509b76d0e22fc53e517e258d864a1d4c00d2d2827fec94560400fbe0ed1e064cdae3571212ce61f2492625a2313034b300501fd7ab7918d2fa9afe93a1a9c59c484a0b51b92aed33ff1edb4c39198e6f57568c8bebf5ae1151c823751468b002213c3817d5b423af08d333001b96e35f5e331834cc5e5c3b7bfe19f7b723de414769cc68b369d76bc87ff6166907bec5ca8", "80d62eddc281c12b9c2cc7ecefa313c9e9a9253efd3ceb8c912c2c341350f1cadf05211cd5b6c548f35559a3f27669f7a3bf08a237bcdf613f3c4038c1801da660e853e8e4b3b293e15282c7fc8b3d84ed78e51e1579fe5ea360d7313f1f16d190d3a76850ad25ddfe9b92cbbbefcac22736b86725e9baf605353723873abaf8a8ba6b8569e4f71b9933f39b0661f5d443506ab04fb7d1cce5de65ccc5de96216576175092ee449197758aa98d1c4af6181796335111e6fe14a18f3cf4da3832a3ac9a274dcc30101559281ec6b648397237a0d01d07fca5685fe5907aebdfcabfe2a6f2b0a6d2d46a7df15d80e74b7a35bbe74d3dad434638768e11c679eaf75d78929e5ae664cb2bc0323e9456cbe909a49954f2359bf3b14070ce097d82505f05d0ac7454ae275e3cafecf1da9a446808dbaebbe405b926d4b41891cdb28338b14e455659fe9967c64972f3f3375b"],
        ["83f1a767a05e53fcb90317d8218cf99582315040a3016ee4cd5acbefd9f0ee3be20be35497165bf7927c6c2c3fc91b40a39760506d04f00646f827076cab242c34c8aeeaeec1c350b8cfc8e91bec247aa64d6a11f2b3bf71732458a89023617daa8ec1ccedf22a454ffa1b167eb750f748db5cf290de93f7c72ce34d5f68cdb8ee0efb095fce93208d293b1329eeb5b053acb314b845cde636cb6e3dbb6cafffc37d7632751d6b38c3892b600e2f4f7b6ae9c41547304a4bc0d39866e8426a040ee0d447e03b87575d91362dbd84a539364245771a65e98faef546c16128076d614c0abdedc73099549a347aabcbc74541fad74411cf3ef9aeba94c88a08e05725a7bee77ed4d562e634d515603d0593043e72cfcc77da4f29b05c67b68c8f83ba0f28e16a9821d7431ae9388ec80f5d68919b5e8d7a96efc6deb487cb6cedb1d1b7816932768ec9afd4fe97b5aea9b2373098f6791ed815bd2dc09589540b5636be9a4a87cf5cc85880b558f00fca6b04a93d5fb27f8ba4ddb1f988268b38c4734f0798cfc958f6bfb268c47803987504d2d465f576b5ebb26df6e0df05fa01bc32e65a8b37766e482e17e0174e104272bcbecf35c7fea02fb13a6c41b20fead53032768732700d02cd40a1e86bd48f4764d58f771ab4c4c378547800b0c3482ee763f943d9c28757a7c0e0ba273260", "a7d434df0ff925c1a0f953c7910a25b1efa21d2e907763bd9d8bc2daa5a1e43cec37c0467018a81b49fd3636b5a07545a3a6c140546463b9f9ca77598f2c435c77d67e78a711163d52c87d79d6783e8c6a7b25218de90f1abddb833d4b807a56962bcc07d38f7904b49c6783998949c3bc212fd8e08026c82548a553ce3ddfcd0275fbf743c2533fee464417ad8bd0bc4d68966ba8b4b5d6cd119f0e925d7a87afd96d0d8f1d2b86c61ae5ee2fb1b70215865f67b9a98689b751fa4cc78f52b6fa11033175827eed74493d1aef09242d62acc758af683448e2ba716740f06457dff078da71a2729bad1e81f8247b957618af21a634920beebb877163798b8de079da17851c3e836e0302965fda20c7d704dd30898ad80a06183c09ac9514a0488a4816f605ddb484131916207f09bd16063ffb214b216241279cc4c1250c4d93ce542ae656622649f7784dee8041a8176d6dabad3d6ae9ef0e730313e133dc77ed13c8ad847603db5d2e566e2efab8570626809e2a1203d35df51ed975f8d3fce9e87e5975780c3d62dc15752c518cf9693d0583bb33472035c598ce0b11fcc1ed888fdf6aca54519b245033bf7a104173e0f1c519927ccf41cd584e35ac28b90f860b4e26b5ccc7e0f08d8d833b08ef", "a6c7b4a1edb53a5c09b9b646ffed3e54be41dc1c8f107ff98e3291068d6ab55efc8092cc7c49b97e27bd6f7429c2551b8ee7dea00abb7dfea949d4e95b34981e77e79009585d7a75e7472551ba7d12cfcefabbe58b9854bfb53af742c8343d728fafdc74fe6f3923998476fe60aeed57dec4c0b0d4e87e58154938226d79f39ed6fd11ce51526095ed8133db94fd603030dd9e5b07a74632d206806d342df14008785080adda284ddf2c0cc6244f37382a2b684c1699d8cbe154524045bce393ae6ec7768f175ad474147a079c9d150b3a9f1a6b347b7d786df2fc5d6c5073f3ffbef5bf03f76e55dac4c0514cf78d456c859bdc1a8ba16bb59cb10f42174b1b40a373baf9a63a34d5dab6b1ef78439e5acf4b715f0f6cd901ef632992e1dccb32f7c0a41042af88a14d8a9c714ea3f31b1847e0e58cf4c99b196ee26f616e54c9ff7709230dd4c55cfa2f0fdf7606695bd1daaef1ff268a976c98eb28de662e32be9da3475311b51b1112d6ea5d48ac3dbfbd726bc5d24be729beb7a0532599935ed8d7b43d6f3b9598195a665951623597052c0cb264145c575d879f180053daa48d06eae9da126b31cde69ad4ea01", "a92167c98e1c21af6491bcbf192a2a3689c5613bddb99f9b15c2075b7da2393dfc2076a5ad1932b419ebdf3e7f56084ba2cf9a49b09d17367db99ea7c95e2e0d4a92dc0ac1e852389718b7e1edeae7c642bcb9c622e7be1dbbca13818dc8d2a887f9c55726b4dec22bd278af72bcb80f1dc1cf6940b7703f483e3ec0c919577414d73c4f80351c7d8bb9514afc9283d160b6ebc1478db95dcacc65fa5bf4bcf48843bb2900ed34ed279374c52ac14e0928ace7b339c3fbd77f3f184beb1184cb298838417f565947ec48f8dd5a4e62fb6f6359607d535ffb46964567b4d5a7f86517e0f40f7fe060c52057e4f07c5fb9680a83e911ac498efe38ca50fc195c0fe7667d4a7af4689f2884abde3c4e46ed5903b83360c476ad02c23ea2a3b663864cecf76ac5abd84f54dc40b19fdfb79e5e19b0d54dc40625e6d8664a20dc9946d9b1172f1aa2576001973c3d80db19d300e426f0ce88d2fe0c308de41b6d0998f12f4646320caf948137505c295247ac601850446953404cdc78597cf241b0f96cb566c06251a7fb1d0347cf6017ede2", "96f7e65673629dbb0e077a1ee2a40d644d360ebbb71f161eab13243edd30826014659c532cd508e2490f5affb09c1c508768fc0d07d08ad3ecf92de924b31964d5e98c99787c91d8923aad44abbd76c9859b31fda6a329f9662d20b9c76cfa7795699d5c9e118c6a1f9f2a5934406145f34dfd2a69d0f24d3387a2972d96c816c3b3c6b88b4cc496c0cbabb954d6f44e080090461940b44ddbf8cf42f601155dca06d099ef1a8c45ebce72b4854690982ddc2b5480d9a82adc2fe3ee971d5dd134eb41fdbc7e0020db281c05a8ef6a05239ad35e80553945d0089b70be4df7e43fb0d7be9a4239931a9ff7ed28e108485d079fe8fd10b8ccee6c9fcf327ca079f007fa2066d8e11c5fbcf329037f9f475794223d494939a17ac9c7b60c836e2c936d2d9ca3eef7fa362ae5d37899e3942d2aff2cf5476eb79b7ccba949c03fb7ee5389411fcf21ac4370958acd21a4fb1b1ffafd13b8f92b127f676e5d740a145ef8da580f765a54bdcd047435d79b61", "a18ecc362a411154f56fda57744eb4bcb16b1b8efc8a94d27b1e7dce3938f0a2097d1e20c4599516498419a710e4e6e188cc5229fe4021c06d4ec5191bba6d98babc97f2b2332264dcf53b0234b7c080f5344ff7e5d9d81c9b03ac56da32b338b3aaa8965bbe0e3c62fb7aec23e50da833474e233e403a6a4c67ad55351cd7ae67a928d7b9660619cc94133fe0ea4da059398c4b9dc07b89f20b520bd92a19293fb1cfb478fbac290e221f3c3f1cf2a7692fa778821b3b6f2416891d7182eaf923ef45e8503e4c9d78ea67c841ea5d927211eedd687a0ebf68edef52a3303c5d6c858f1ed271bdd5a07168c14a3e08ef5f2d1c652f3f753bb9d611ad43557d9b59168b87b8f974da9516a5d15db5638c3fedbd5c39e54c5913d699d88a74acf8731c5dcf55316ce56e945c1731ee108d2e20b57e64379da4ec26656a984fccd81b681d18f70b03d6c2e71613df061821"],
];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(
                TEST_KEY_GEN_IKM.as_ref(),
                TEST_KEY_INFOS[i].as_ref(),
            )
            .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = Signature::from_octets(
            &<[u8; Signature::SIZE_BYTES]>::try_from(
                hex::decode(EXPECTED_SIGNATURES[i])
                    .expect("hex decoding failed"),
            )
            .expect("data conversion failed"),
        )
        .expect("signature deserialization failed");
        assert_eq!(
            signature
                .verify(&pk, header, &generators, &messages)
                .unwrap(),
            true
        );

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = HashMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert_eq!(
                proof
                    .verify(&pk, header, ph, &generators, &revealed_msgs)
                    .expect("proof verification failed"),
                true
            );
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            &mut OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            &mut OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for ((key_pair, header, ph, generators, messages), failure_debug_message) in
        test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature = Signature::new(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = HashSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            &mut OsRng,
            failure_debug_message,
        );
        assert_eq!(
            proof
                .verify(
                    &key_pair.public_key,
                    header,
                    ph,
                    &generators,
                    &revealed_messages
                )
                .expect(&format!(
                    "proof verification failed - {failure_debug_message}"
                )),
            true
        );

        for i in 0..messages.len() {
            let revealed_indices =
                [0, i].iter().cloned().collect::<HashSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                &mut OsRng,
                failure_debug_message,
            );
            assert_eq!(
                proof
                    .verify(
                        &key_pair.public_key,
                        header,
                        ph,
                        &generators,
                        &revealed_messages
                    )
                    .expect(&format!(
                        "proof verification failed - {failure_debug_message}, \
                         revealed indices {revealed_indices:#?}"
                    )),
                true
            );
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<HashSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        &mut OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages.clone();
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<HashMap<usize, Message>>();

    assert_eq!(
        proof_all_revealed_messages
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages_same_but_shuffled_indices
            )
            .expect("proof-verification should not fail"),
        true
    );
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());
    let indices_all_hidden = HashSet::<usize>::new();
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        &mut OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect(&format!("proof verification failed ")),
        false
    );

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify(
            &PublicKey::default(),
            header,
            ph,
            &generators,
            &revealed_messages
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify(&pk, header, ph, &generators, &revealed_messages),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            Generators,
            HashMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert_eq!(
            proof
                .verify(&pk, header, ph, &generators, &revealed_messages)
                .expect(&format!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            false,
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_prime.to_affine().to_compressed().as_ref(),
        a_bar.to_affine().to_compressed().as_ref(),
        d.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        e_hat.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        r3_hat.0.to_bytes_be().as_ref(),
        s_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
