use super::{
    create_generators_helper,
    get_expected_signature,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURE,
    EXPECTED_SIGNATURES,
    EXPECTED_SIGNATURE_NO_HEADER,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFO,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::{
            bls12_381::{get_proof_size, PublicKey, SecretKey},
            bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        },
        core::{
            generator::memory_cached_generator::MemoryCachedGenerators,
            proof::Proof,
            signature::Signature,
            types::{Challenge, FiatShamirProof, Message, ProofMessage},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use ff::Field;
use group::{Curve, Group};
use rand::{prelude::SliceRandom, thread_rng, SeedableRng};
use rand_core::OsRng;
use std::collections::{BTreeMap, BTreeSet};

pub(crate) mod test_helper {
    use crate::bbs::{
        ciphersuites::bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        core::{
            generator::Generators,
            types::{Message, ProofMessage},
        },
    };

    use super::*;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
    ) -> (Vec<ProofMessage>, BTreeMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: BTreeMap<usize, Message> = BTreeMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn proof_gen<T, R, G>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &G,
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
        rng: R,
        failure_debug_message: &str,
    ) -> (Proof, BTreeMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
        G: Generators,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng::<
            T,
            R,
            G,
            Bls12381Shake256CipherSuiteParameter,
        >(
            pk,
            signature,
            header,
            ph,
            generators,
            proof_messages.as_slice(),
            rng,
        )
        .unwrap_or_else(|_| {
            panic!("proof generation failed - {failure_debug_message}")
        });

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let proof = Proof {
        m_hat_list: vec![
            FiatShamirProof(Scalar::zero()),
            FiatShamirProof(Scalar::one()),
        ],
        ..Default::default()
    };

    assert_eq!(format!("{:?}", proof), "Proof { A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, B_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), z_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, B_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), z^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let mut generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("signing failed");
    assert!(signature
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("verification failed"));

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        OsRng,
        "proof gen failed",
    );
    assert!(proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .expect("proof verification failed"));

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert!(proof_deserialized
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .expect("roundtrip deserialized proof verification failed"));
}

#[test]
fn proof_size() {
    assert_eq!(192, get_proof_size(0));
    assert_eq!(224, get_proof_size(1));
    assert_eq!(256, get_proof_size(2));
    assert_eq!(288, get_proof_size(3));
}

#[test]
fn gen_verify_different_key_pairs() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["9954ad83cb9cea6a67d0dfcfdbc13e355f9870fb84dbfefb406f962b252f0acddad2681093f76938529e6e54765b093f93641109086f58df704d62a160a21a09b9934ba4ffe7a38c148d211242a4670b0f642296bc04422e330519830412f0705f77525661570da37e7ca584d3ad0e6ed6c66459ad2daced4be703d0dea665a52fe956bdab10a4d95461b28822244f6420aa32b683de80bb4627b259a7e392a831944ee1e022d790da405ad861e086eb8e0b639763c0ab3b0b62b774f1b706f57344e8bb89205b20adbc0988249694e962625b492b69bd2e128de41b1f66b4a933eed6a862049400191138712ec9f387b905ac8e8cc793403e21a7edeeec39824cbccda57e6ac258375d4743c3c88a942b56ec608faee1d456f62f319bde95920e291fd2200e95749ffd820c42f34f34edb9f4fa7ead5c10aca43b64e0ec3fe15e36a7a4b6de74aa7c52819883c5ec115b13463981d79755f51d7c1c6741b03e16d053cc6859e4a161d89c65e62ce0e72e2d710ed827871e7f00dc9886444b6d", "ac9379e8cd2966c0fa65555c1c3c51f22c5b9e88fc279944ad392ade6e1142c56c57115e3e33ce63716874fe85ff27bc936f9b053244fa08e7bea34d127206e2f80d10ba4e24ed925bfd9de8a88d1e7d9bb895029247dbd785469027b39932590b85b0b13a02c6f57979e36468f8867a9cd1e1955cc578ed6f4987fb1139f75e42e5cd21a4b98f6d41be70855ee2862febaa0799fa084821f87294bb83d39a97406e7476f5fa0e53c13d27a611fa072c9b274987a24d6274c1e0b2bed4e8ca481fabdea1e04632f207eb82d65fc023fa999dfe5ed749eeef1169e32885e287b636a0cd1b4cc2016f902301212a8128f64781e36f48836e3adaca882cd24e1ebd087bbe6be1fa6f9f4f4dc81642db0a1fa2381e9bce2f794912efbb649b7b01e30e193b965a1a3eede02b33aab241b9f5c3c75b2df27c1ac2566d318f5a0c43cd6d44428cd2a5884b49c7e0152f827e3cc95f0f3315ed084bf20fddfa5135b969", "843e3c0a488ba88e8553d218346d1efa7423d6dcd9d1216ef63f77a810a9938f694782f47712ccdc00136057bf25e78290e3b7988d247a20293946b3be28db49cb44c90ebfaffb7aeadef289dc7fdc390144b8e1d1d99474014375972d01a90f27b337e72fc240717941643d32d619deb9efb42788bf82aa8ae976300c92da842850585a5e4a0a01f2bf290d1f38e7ed2f0f3508d70d8eff43a470404a01c7085014005aad8321b405eb126660b3a9a4f6698773680c7220facef777ab2b8bc0711e3f52ffe4fdca1b221cfa50441e9032ac8e52d671627418edaab5ad3ff2f82287d10b94ad410d5d546266dad6d7e655b6b3079ea49bade1569a6239d7a92724e9b4d75354f06e7b0348c813215747414d5b2fe2b1f0359458501f6287b01c5ba722833d892dcaba8fa411953a135122c3492efc4366a22e348cda1de3d644", "95693a822b0f3105f253c1278fee8d60322037bae9bce4598a8e1c318beda8bda7e6c46ddeeaa27d1e63490da2a065fa86bd555e78e1589379c4d5b8bb484d46caaa22ba0d3c1ffb756633e1be78022ac9516dbff9231a18b651fd4e536db1284517cfe45470eb7b922bceb1dff5111ba99b2d6aa362b227e81ecd9074dceb974f56757882507547f87df58da056ef3e15117f2700bed04545bf27a26aec679b483bf40a38ed4203f049284029a3a10cb17ca0cf0cd6a7150018332952e1877d53adf98472c12e3eea9b4ce4b1583d8cf0a240ffab3a569033b70c4d847d18d82822ada5c3aa2a1fe6ed2b2362bf1b61cae285b148639d6215c8ac3b10758c7f69a52e176e3e394696e8e5be9add63cf61eb24e45158a43969a91374ec1b2592", "af0a61716fca78ae26d022b6e369b2fefaf9b4d92133687d27c52d3c58e00bd32d848556669dcd28140be4de27aa2b59b612636decbd549a17a3c8187a1e1ff8212769035a1fcd83a006196a50db6b8dfd278fb543802022f60413fde96044f53d0c884323ea336a39ace2d16db73d011980671b7030ba9371759544c34460f16e0b36b4d909d4b10b136a28da3a29089d5a46f4788bdd7d1317ae7284766a7a715a969ef0e69c719822ca11019fb0cdec5783c6f7d20d933650bf0abca978f41c16e0d5f7e83fe9af535c0cd7ef1343a10f888b6e3b1ad430802fdfd7e9811265ec4af499bca562d167b406a0da49d42a9623273cdf6464f3a92a4eabd30447", "b0ea6b5c83bd7da2de70968142e7df182d115b860513004aadb7b951bdc3417d26a43291f79159fd40cae9717d23eb54ac5252dbf59bbad98b5261ba55a00830d48212d4658c121659a2e0eb6bb2d6326a864c7f0215bf9b72a52508c59c6a7e53f9aa360a3a9c1095d5e640ad5c3de9a66ce4b19dbb549711559a7839142ad511c8062478b149420de847a91e13557d908fa012477ed209455013dbe42c11f27372a68249fcc758b74858e6b49d1ed90ade01d0ab76183f7f49fd496452e0ee33eb12eed7aed83c4f5c12a456551d8dde95e90f08c0be48eaad0deb48b60a71"],
        ["b76529ad2701f095cef4ffcec6ab329a620dda7be04697f864214480151f3a0c36180a5c4dab695b67dd2e37ea09412782f6bd32d796199e27a3460ea3933603d9ae4465b4818b70272a5acce2696509caed073320ad35665f293affcc5ff9915f6105d62975c0e137b73a68f7c18c12c177bc0b06f341f9a239f87bff86bca56cea491329dc2616173c1de7e698020a06c88c6850136150f04270def75f49050350d3d9445a15e228a456215bcd245db98613b2fe50572c15498f3411c5ffc154beda793ed7f7610b7a766488b5811669d23a35a334a85b88ded579b1cb1f2e243df5f4a4ff5af54adbeef60b0aaa17f7ca4bcb2c4c1bdd560f7a2c6963319212f3556ab62e36b517210426af2d5852f761a6b613f15e949cc5645aa0a91ffa1a2d2f22900a1b6f8189e41d3b896ec7fecff90d0fc797680dd94d8c9cb2a2d665164ced50f4a7ef87b10668f631dbf6ce87fe07fcef8870d8a5137b32831e862afa8d401d7f11c9fc632ad1607db38b7430cf7bd0bdabe7de42fa9640e7c7ec", "83b4e3d189c8824a952670429d2569b63c0ecd18e855fe3652139a21833ecf791b8e03f8e4f89abe99b8522a14179b03b2c9dfaf51567e591066b210b5cea65d53f5230ed4b8fba887f0c82315bcdfb5fe20e0d73984e8f22cc5cfe130909d501bb6007c7c2d7877235af8e698cbdae9cf54837fca0663531f82e15341cd72751a11798b0c118f7b48b66616f89d3236b70bcf20dd1e91d338cf957ad6bd1ea05c1296e9334033b97973f19bfb4db4b909d9a51bedc8b190e76029adf8c4af351e74b5f58d369ed2c8c33c0a49073ff8d07a09c08fb8c460ce6f6e76af684af55daf0d214e7de8deab341b364c2580ef4b98987d7b4aa61ec5c229ef25c49efb013f4f2dc9adda598516882309418c24b000f0d94f625de180e711a61901fd5905307b18043865f067dd8a201b3da223085b1ed5ecf75450683751476fb62c66674ddfae0c2707d8ab08e412557597aeb5ecad7ab86bc70e65843128381a4dd0", "a0b03114b842809bc5c709ddf5ca76046b0d35bdfb3a9d4b4ef9e9b68f6af955f3477b68f25cf5c656ef522d1e39a99b9998da95e8b251ce9a9b8d013dce15c3c50c3cef4faf8688fae1ac581a7a151b1bf8d2438356e37cd75422ca8aefa3ca5e77fc5deae445aeb3126f35da4617205b418f1bce0426ffd107b9f3954d5a302eff460e00e9b5b9a3c19fd60ffa67c6412391595ed859dd35f8000f36bd72c5663a889b2c37977264898e7254682589c66ed45e48295d6cdea61c23c34005073f5fa09875aaf352fa3fa7650b37bc7c39551c6e6a2fef9ada54c21c2549fd476b5e7ff14c071755782048d743351d8596ad564685ca5a170dd75e426233109c5019994708192b0028fab45ffa2f2cc51e0e20aea3d573c07b2c42f59177e5586abfe4a9da4d239130f5264d28eb95f53514cd3dc706add28040c05b32fc5498", "8ea2300bcf91315c34517829173883fb541323b4b9ce6db17f21852cf8af3b7168a199c2ddf6983eb94c782dc14bb06e9088cb18ca7f85c40f61f4cb9b91a6ed171e980330ea1599899281d4844d5f7087c8f6f1fa7258d8558c35a759efb4c00e9edd3c780fec2cadc1316b3f6be592d75779409a94cc291e18e6fd04448196677661e15c6d17f55551e03625da9d221c3bce5d50762605f58c111cfb3ac0034905558b98b620779ce186d7bb411050ce6e72e662b8d5adc0bfbb50a803062c73dfd6a3be2536e9f57e86a040e90ce7bd5fbb587a5ba31f5f7214bcff8778f749375f552aa4321c3c6cc1a1950c5b6130da987965c0d9fb4b7b665107a452ad1b3b47b0f877ca8bb12ea815ff1336829d7655e6ddb9297aae74c49f3dd98773", "a6c0ac2da321ee74882a27ffd2d746569c8c542a62d76abe544c6b2378d5e07f53d0f22e5367cbaa00c35fbf3f74e98aaa7173d8e88b8aab311d0419cba82080e0778159742eab4877c2b83989575bd2d77205bfed68cb04849e3f7dcf57615118953264908210242a366b685e9e7a94f09a874928b694a7ad398388dd8fa50b2e9b3a541ca3dc8cf9eb417e03b7445e6ab00aed586a6c20caf2bbbe13728eb517c3cc33d9238b0e1421f52b885ba5a6e75ebe9d1e80b3cbd390f5eaf3ce917a73c82fef8d1a6249f9ad741ffe51984c4bcf2e4eaf1773d42df880eaf487881c66827548ff112d5a419c347e41f20458cc10297b335eed2a26a54b6258fa835a", "87bd718d7fb590f137824829666e464c0797d3a79b55415760c07b65db5b9085b1af07a3768e2aea1bd09ed27395a6e6b678cb99389bb75267af1110248ff4bd713054e05bfdceded5116744c0f0019145797206271ffab11bc8ff520861ca25209ee6a8c456b29c2cf7af6a242753e7ea38e067d3789fd2a633d3c7709ea0ca2f1d79808e637bd03422b3034bb34d916d0d882517c7ee9a6682a0cd93ab73197012f37e3899b416bc9821e2085e24dd3b60a03b7f40e6b0770f4637c851db7d11ee8bffc2bff2c0f76efbe008f5be252c2ff7033c0ccf4ae6718cedc4407d88"],
        ["b96c6833ef8d30fae5922d53e40447722967f62cf482701ff444f0e79a03beaf15b2013618c0e4505df2910a3e7bc44584caaa5980f811b1a746928c69d64da53be4d31cfcf0eb1dc3e04a9a06fab72e6678abb7dbe96ddf4a1dcfb32cb25d2110531c83a70209ff94b12fb523a1a7ed2b48f0781f15c12e18ee215ea29fef9842d40e12699e567a76a1796a3b4c970a36d9e6e0275ce6a6404c16cb1f2b199216b01ae86c55ce13ab83378acb9940968b230e3d164cabea2a5ec5620e9bd8f7225fc4048134c6631ca8ea9ad9427a24b8d7cb29e1f2626cabdcc77933e63f526646f5480a55bdec9aba7bd7582f4806dadbc7bb1b19c71bb960fb754f1090be5fe2afc71d5ebb9b2dc86c7e9801741aedb027a9cb738c80333c4dc33aa4a5ad003889b12e3b7d463f8de741c739eca156f9581202ec6463e42894dd16cad62b0e7f848e2b09250e30ce07d360e4d25a7e8bc5b1badac0515da58e3f363ad6ee0ece8881caf203f7fa0f65801860baaa97f022cb27e42af8630f070dd0384c4e", "99e5d6238e61318dda5ca1b422e5e4bd36f11a24af5bcbc1742647f2e898074a582b2a9eb61da608821af60b91222e35914fd4acca9a8b1587da2ef6d728531fcbd3518ce52ce0df90dfb109ae4b0806b515d21df650efe0886335ee605f4b5e219fc47e5579592fd7cc908547cdb82e61a5fb0d376b140fb61306f7cff65bfc3f40e53aea6e22d2a79e2d65ddf9f6d8ddc422156e4f18199b79e410d850df1e5bdb031fe353773b547c2522f0dad04bb52b914d49d12fb7a75f1d98eb081d4c61bb1d14f57437180cd419d56f4a2e0367074887e599c8be6e124e8d8fe2b18600eb2c6859603dc2cbd100f2b1f9e6d060ee057457444dfdea3434e33f0c186e2c461ea1f844ede28db262bc362fd43471aff56b04d8874c58a81809c366a6ad5718d30fe20b399b9de9038aecb66433d4abeefca478bca73e5b7ee776623ba700a3472b3af663afc6e375cbfceaf0d2a224db432a28515e300daf5008a4f6cd", "9896900a1b5b60a360089fbf4c8999d3901412083fdafbe3d80fb61c87409c70c8384b0587839d339bf5a8b52a3f1f46a10b49c74b45dd2dadca61444b478bdf65027ac22dcd0e670f79e4f6a8cc2ba24f72513dd914372dc9dada00798987b0421e011b57f8aba23476186c12eb56fce2515eab05d0566025b4aa65de229f5200790009f1d7a675a0fc446c54d85b49ed39a7e9d1d908438fca902f12c37b5117f6022e8ecc1f03db8b204ad2f50fd24dfa0d320047f53a497902a518ca1fd905c62a4b881429db3c79543de6c068c552f8bbfe25ad06572766feae6d8d842a340470f79abbd86d519f9d4326a250da065253e660b7bb5db5eb0c9230446929732c973f9e734915657aa7bd1f91535801689943cf8625e8c84f50567d9ebf6147b56694751d948e7dff1bd7f3b6feac3b70718f9345771cee74a4319aa8b2b4", "8389e70cde5d02a94848a701c4e54892d82eb704d46baac7953d77903182a132163120730e753476f7c7ee6da139528f99cf73abbfed0f50932286deae4858f229bfceadfd4ca2de8c08b52debd44304c4afd9d027f1fea0843708895951266f52e3b2abbc86d3da42bbec3ace20987ef445aeaf7f87f524308b414f9ae5dd3270a0433ade0875a50a2abffa70498fd0bff12bcb1606a9df2f3d947b079a8889680d2516095aa0047c22a9fd7c42329aa7ea2fc3fa7944758462f98da22b3dec2493c88f7299f5ca3f977a458c21c35b0fdb54740942eb07e4c201b91def95a3325ab851ce875a2e5fc2197e5f3eafe26e2e44b8a76e0401216505d0dc9fd6204dbad6f208f7d546e6b0de565054d6940a44987380a7b69daaba6145b94bc81f", "8148c3d1d32f167feba9c71a22cfed435f48c113456a852b62298b7557875047fee16bd75c6707e406522778af6a3f90a9601b03f639a66f6b8639be02a4c2832b358c1577849e1c31badcff2fae005f5efeb6e9bfdf5d84eab3a903ead2af0930dfabe760f599222ecd814b2103f08e08dd262b22780368f41968bf257754994181c9a3d5335e61458e98d543ea5b5aff6ca68864a4dc952540251c6d0b99e60379b3e42f4c6fbfb6889fd49ee355e08853d133c0c7714ab82e9d1c8e78e5436346777478fbce9539c8f3cfd49f36e44ada398f5137e98be221c8389b6612cb0cbcfbab80a1d6d324fc3a0eb5f9ab8528011988369b3597c402b6797c92f5f6", "906097ddd9d8dd8b0d8fdf6aeea7cf3b51d1e932524428fc801f5c7376db005116741a0668fabb249e6a2ccd4906345ab5c0d9d71334874e086108cd2e99be81967a8159094f8e9ca57100efe7786921f1d06b4b8b120298dd1a7d97b545fc75727f9ea8e8af9c7edae482cc30c97dc4b16b08da40ac3640557e038da0c313255432086efd6d76bd7d990ec22feca9344403f93d122ead8a5483f1d16dde9b1a0f6b6e1f56e608ce0d94ebbd5176f82ab4910708db1d3faab462b03a883f913e5d5445dd034673a8bff7d9054e9dafe565d92e25ca3ab1486769d68b1b147c4e"],
        ["8c729b13d4aa40ad6affbd46fb1c606556e3b27ddb91def0e2a4f955f7e434c3038a25aac4a3a7b9b605bfa92b9e2ff789cefa11e138190658b8d039d0659d0f57641808b081cd9b86adacaeb2c6ebbc55a9ed3519e02894925e18a6105d665c2c63d4b594fa5bf20dbe229a55080dc17fba7337789713f5b1ddffb2ed23f5596fc39fdd08575f383cc5316e6e0a350c92bdc57eb3bed5ffb16594c3db49010d211b7a30589d2cb7228e20408d6c49aa98e20e2072618c779a25b793e910c02150d342709ebace11dbb5ce26c7a69c210cacad688dfcbdd6cdf02b6faac5e14433743827a01674553fa733ff49778b9f36a4fe18002d90c752337c794ca2aa982b8c0802c088976d1d6d98c4505299e42d94339213c663ffff23072a9b1bd8864f76811bd7a7ce40364bb47ee60071d9476ec402ebf647b449f7f71163e2c6e0349eef52be2e32f7322549585d42b64bffc674b29e8340172027b131a7bf5bab14436f038002447199cc1a4ab05202057c9fffe43ec85c0c4912cf898ccca659", "b96600792bfbceb99e3aababa80ec5912a4e48021edcb4d91f4b7b4565ea584f9c4200f4adceab2e2a0ceda16321178b8374d30db26cc39cc39701b62971374cad219c7aabc59d9899d5839c589e0509917da77a4751de0fc3046750ccb23760593280c5da128800cf27180c91d8eb44650b1a7531c0198a5bd3b45317b466e81d2c245d015d84a1c95c1bfddbddaac8d8c7cc577acc5f02116b8f27deb391b613a1fa4a9ab0db5e6a9fd4311e64f2332b9b9ba85627ea7fdd4c4d6a3d4fda99541bfaf91616be4dddfbdf85e6c07911ee4c9a7727164e0cacbd8ebdcb72b54363c5ef8a3d3bfb7bf9a713d9042164eb6d3361322767554b71216b4646ffaa0c3c64019dd407d9ba9e7e08a4a2f44a1890ea641c3c1681614cbeca83773b18b513af42997b1f855b9980b4bb8d521101d6fc449becb5fbad723e3183ebac5902553ce10571bcd9321a6cb126710611cb4faf902011cd7356d2900d6f6b1bb10a", "8d418283de3c3384b881a829cc5229690f34556d6a3f261c622a3062e9e047dcd75cebf58102d42efc50917eb06b4d30a780c64d312c854fce69b958170f8f5ea5a46eae688b300bd0ae3169e310471cbacf38e7b408d0441b4dae4a448cb37252081c82ada18de49c40c6fa6683f85f248dcd72f2775a4fd519bf6701de7bb061153304ee16420c353608b70500fc0827a04d8c98fb96c2abef6bf0c8b0c0e56ab895611243cc69bece461c4753cce76750229a7fdb44b39663a36649a8a49e5b7556047a73a3ae11b0a9c376bdd00ca998b932f061f78ed08b9d0ebc404424357e9e2703fd10b128c104a24fe37b5bd8d63ff576831506f213931ce2a6b9ba56a7e09030dca356b80f20f01fa9ec5fa8c7764921ddd0915950d688f430841e578b58681ad394f91f705b1dc701ecfe058b525f5af764d05f92ac623723bc63", "908664b8cca5b33dbdf5592dc3cfef659c01052d429c0db5b686949643c795d46c89e7b3b84cac6fb838ef26f288c3bdb4812a798f8e0225a7f5c5144d3643e811e05fa99414fdbbe811561de1b45e5cb1c474c36ad1f5df00d5aa9a7fcff000672a20c88d87d2dff74c81c843646fd6913064c90931be3389a30eb2bde441b94d12de6d8796e68c656b6ce5968f3b589939cfe7e66006fd2ba03d5e1eb702a333fe906954479daa538067e349090ba23eeb225212a0c8870d0f3a5265d455211b57d84820b883f74e6209c9652b7f2ae0a7d156713eb82522b077d614d8c9c90b303588ee9131396021591e471e91b17f3ec96335490e1dcb3983866c310cf0226308d18d0dd36b47bcf12c8d76ff3622c1e5b4652bc432aa022a058081cf07", "97425f979bb2fde77ba61e4636cbba2d4546a47fc778c2dc94d4906e3c7bfa10453fdc97b256f74c830dfc60bb64e499a4636876f91a67821c9c9a2032a5728ef6af1e1de7837c5d90d9af092ac3f444beb8af0533c4823030e1c3bfe8ae7ba131305b7a4154d6b379170f96386ae7c9de17eaaf233f6dfdbdd988a21ed7da780b9e48be25fbfd90db217bced2eb9b258fd680212d453c5acb861179a8b2df1833ccf102d715c7cc929a9ba66d72e912775b6f6739e945b264a798590667cdb745765f9ca1c1cc777f2fee63ba8e71c66b2a0c58456ace55c3980d65f91093c0055c66b7224ae4116d8145b69e803974f8846d4d24501c88a404325728bd0623", "816a5e99bd933612e7fab01d94f0fdd3df9c76a1068aedd6e89be72ee16265f3ad3d84a9587f8b3d05c29c4372750d48a02c0fb801f5f5fac77760dc9461660024f5285f0026141d68b5bb2b24393dfce009ddaa751059f3310daffb7aef7a581a1d0386a689151e350a84b24e1c2171d294d34869ec955db9ab90a7059e381a668efccc26f5fcb746502b685884f8f320b4e2e0916c089c4c091935571362f91f8b661a9a2af64f219b234490baa5c8414f5accf68c5a855dd2006c1c732c4b66bc51eccc6698c287bfbda2c865b109ff34ee2f70231b93f8c41a0da6902c1a"],
        ["93b8205783bf9c5ae49375279f5097c9ce2d25fbc7cdb25fce469bc3026309f4581e67d2cf644788008c8403ebb9c3349204c8809b3de1d706b956411b25a5bd190e63c50f18811c13260d2f68c8dfa12d839d1510692feff976e75b50c560a004cfbd9c172c0be995f643ea8a3e87e9f24485bb8fe8e7543e36add2829f3b4e0e8b934d45fe7b97ff9c5ec587bb69fd254a8be7dcad84d7720bb9bcd49ede9a3495738a5d18ee968d73c8bc5adb04559cde9c0c6f073b9d279dba05e7af7e153147ad519349efbc3ad6c3a0b8235097ef216a61a842957443f27f944d6c0cea68c82c6651d5da98b36566965a5f1b8423c71c56e003b5fbb1a7023e106fbb2f3f898c65bc8c0b12a1ff20d47df9e807a1494f2146a6b37896543aa7c9a91340579725e1948e30da6f4f8bd3a33c10c0c9400fd8b50b2ca6516cbf5c1ff81b1a52c763eac1dc120829063c2f9ba0e185e4e99bca226f659006f48ac7abd7fee90c96063e3055125d261afbe97eb37a4b021dd910071d23ec365b0dd3673d026d", "a5ada51c5016103b62b4ab51c17af4deaa8e913e627814517a95a35ae2691b14693fe73e84b3c952572a306d7f0ab2b88598c7f613ff315cecae5136614df35016d1c95e753a191d3789497d2828c98fa5fe2b3955813295eff2e4f603a75a6d6442264a6ba0a5eaf815a109d00486ccbfaadebdd82ed0578bab1c6fe6c3b26b1ec34dd2d247bfed7fc6021b9f4935a3a5e4998f3b6cf5bea9f00ccf1fd652750e8ea3e9270b5f746216d73d48e80f85bf3133944e2f17c2a2a47a9d18bd529f1c3b24024c76adbc4f7ff0acc1b3aac86f539bdaab3e37ec9a4e53b5d0b9130e455c29b93f2df7727433e59de32eb9ec4261e74b5bdc6590a177111ad4b865ac22c08fa9cf1ff844024c4d46aadc6059f57fe50d5970c09bfe52a05fc1efe5573ac2eae3308111c870b25e4e22896e15beb7454ab9b870a3f4094810494a89b25008023eee3e98e932747e35acdaccbdb4b5d4c5382eee3c4abdde55218b668f", "a9566d942c2d226c5b25456d949962b5e43bcc6c4d414b012aab167927554b807af690c8954651ebbad34d34f90ab4d38e155f0cdc08a362105b43bf69635b88bacb39ff48fc3db19cd2154968c0d52047896b32e3732fcc80fba89cf266a64a2254f8f340064c6cbcd5c417e678730bbdba6b413d234f25821c3678df81752f52260d372a4767d04d5fdd25a3731efbe5983b330d7350e636b682c90b7b75e20f9e46b6bde6cfeefa338a1c7d06d7062597a834fe34c12f7fc7ebdf92e1743b4c3ff011b7cd5ed70a111c79b2d7f398c396fc74c88d9130183aa70f89b068ff43634281e2adaccdfb7fee312aca13106c2b5be03970d2fa5512cba5fa23a958145d2748a794130f40a11e8ac182107a4e2cc91ee58489996aa3d4a5743d14932f915fc10f96161d16adbe12925e2cb5c451927ccc3d41046498f1815104a1be", "b7a7fb3e133a68e223eee67b520f7071ef3abe9aada3fdba70e0c11ef6e70e535b93279c4ea246445204bdafd3bec81ea01b509c1fb26e785efae8b96358e2240cf74674169e740e8472fc372708a7f3ca0b7667f1cfd28345930e5d610a78b5524a175e53dff6911745411ecb351930876f32352a067c3c697b983b5beb155b3607bdc46e15123a79571f36146a446ef627efda6af60c397d8d03131d9d9416059eeca6e43186ea7c79f4f5e219e06abb5f5f28c2dd8d23ccc2ba9f7ea6cb495de57ac324377da98c5b79627f45b2db948b5b393d8988e898fc714fe5ca642d102dbf1ed9dcad3a80cf1d3b61279b8138b2d177b636cc765933d7f08e94de143b955d797e5fe94fdd7094841ae105953ec74c5945e82eeb6412a7abba5b04c3", "9225354605570efaf6cec325c736517ca07b254178510e431e81e69971b4c2ddb54aae413fd6835e9f820aea5f970e98957142a5b5ab655fcb47ee64e03f08fefb91d1ef577d4a728f0fec967e142a897ae34af26536dda139a34e607ff1b876598972b20d80689d22533eb85cb687db14d67c5fb44e0048b71c1254ca2bbfd472c5b4cdf137c0cf835ec3e83c28280fe7db40aca233800dfc6ee217d7bb1dc64ca69b774f727f3bd791ea2c4c8c61368a52c0b4fe71a77d0f95d686aab2162f5235fcb614dfe926f3921760ba396cdd52f84ec701b3fb7ab88fc589340458a22becc922c0be63be890c2003102b87a70bc6174f943e83aa27a65131240a2f85", "90a3ea40c54dc5280a56008d7d4e41a9bd7eae5c4cb02fe58d699a6d684359a8bb37b63fdde6b9191b59a2d544c56203af1f954873caa4e4315451a84b89b55d6f2a7e3aadb064b85f0681731cb7505c732fd6ef35817193cfe3544d63ded635092a92bf040e9fbb6ddf9f2d7daa43b8083d842d58f1ea6928f5d69ca9c729b2446f66c2dc8891dd670fa1f314d90aa18cfda0947ffb28c650e85272dcc191194e5e711ec78ae902c767b33ccff1aabf1ba688b5e6fa61f49208acd737e67a672811ea8078d59646d6611175b1697ba678e09f9e813a472ba43e3a4c7174d15b"],
        ["9537cd9de5c3881c2fe45832ed22998849bd1154d72a8d5ae8dc8315d00b3bb4153803edf73c08ef229c26fff36cd445937495419dc7891714580dec6d407e58ae0ef2959db50a6a4b3dc781c2ab31aeb2a628e1fd4de9ba964dab6ab93e2c553fea42de8271c052b899bbddb8c8be86bec18f40082f78b30e9cec0a353cc34671f5424d4176d1fee068f473236063a5780a3b8ce042c16672c75ab600cc6dcd0adfc021ec56ae452fd6f9e194b5b1adfae123e7919b01752ab88b41ecb751106682c30df977c5a7c74bd1dd09b94917d30ccda1712d58939253d301d993ddbb3db6d2bd5aa7cc4bf8d6da0c7f5bfee5472e9d5420460ff8132fd317eda57d612b13c15261ac32aed7e054e97ea397e09f85c5500d52ba2ca7e956a7583e76f0490e91aed27aa8634dacfaea081bf627576f7b0b850ca0e9deaafad96ac053473ec444a2b0b2d5416c03e9526fb126bcef817ffe8d1909f73179dd4c634900fb0c7b3d0757362b86f6b89887cc2571a1c7b4c63887ede9aba8f57bf9839feb73", "93cf1d7a8ee41208d7b0acfbac149a2978ae76475c1b82400f41331e3571c274f0f3ed05071921dc4451ce536c1794d8905088b5b683869ed1c4ef1cacb6c215d0e4a7c04c86a48b28432c3782174125e44978dfc7d7b0e57e4cf9be6f89da4471ae8fabb74bfe1d917a4d7b64d9013082f9c547f9e8e23b2a9101c1f606d6d862cdb73a3f7cdf8b30e519cdba936c072ea7b491d05b9322fd9548dffc4e50ae1dd67855d3b4d4b8d54af17e0624388a732ddf4841d39ef21b88f531877eff2a0c7109264ced09657acbe9c845fd4132373b8334fbe2a0dceaef10b3134942de191cbcda7c3d018071d817396f58bf865bf6a311795db7d6238603bea3f1d2462593dde66c6195557376cfdd81f54cb94084da8d714d30161c9bce07e25d4327661c10ad4e5dfb23cf427069f4f663547f9b0f0c507236ca12976b5ebaca5e4a3f5008ae908f810777183124db8ccb48709b3a58618f19fd819f7d0a9b685300", "aab0be085f13c9ef6e53250d0d958e55f1e5b0563864ba7c03796e36f85d87f7f363611fa08c927145353e323c8478f199c7d9a31571395c25fd62a38faba1302125f41e7cb9f527404f56913c92f3fa196086455733d14154b4624a10c5c451093d3ce0c40e8cceefc5083904e8a26f19478ef654b717b1152915267b6e274c510951301a4bbc84bb0fa05063c4dbc2368d2806f346af1fb42080124a954acb5d51c7541cc96b1b34eaec3122fc3e044d63f47568907274874e56a01c4323a8343311805829f7c3eda75c72f2bae82e9182d03f1a2f7deec1bb214c25d479955dbcfb3310771769ab2597fa1b31a759034ef81b25a983dd2d8aded0082385244189b58f8a8980942353923d0de768eb755885e80e0545f6ad84f60478b374f30ea7b55a0d5f7aaed06ee8a8c441e07768b00df3acfc26c6c0bbed7c21731249", "8465fab388847fb59477bd71ebb0cdefbf7164743539e1d60ce886dde70649b18775fe17af14ac5ac156e6be65a1015ca5426701bb071b7ae533609d652262a46b5ec1ebc3b355c4fdf1a159a17bff358e1ff7af383c6797846a5a2339ad368244960d6a12f0140cb88e143455d851a175055ca17be0c0ceb6a19c2e8717fdd731a4f506a67d8aa8d7ff669e76498d89e36a3d2163df1741eca690a46a18de152ac3183a4d9097523e686f9322011df1616e11eaadac27c86871b6a9d3ee417543ef8eddca66dfb3685eefee6e6698dc581642f2d5727c34107f7895ade565312f89a1fe1d3965c98fe5fc94c348f9fb31e90b9e80f7973a62b2a5b0caa79acf2d5a1d06b17a07367fddb7cf33e6638a30c436fdbfe6796cb6b6d130342ef623", "988532ca11dce408e0b124c8afbea2633e342add03f13de4908adb1928b0f9ce35efe92f968cf20643eca2472d180fc0a8c25118fa1589a0fb8649ce17ed978efab6f21929ade89947629e5fc4e1108eaf2aaadcab2febf6bb2501f38d60de1146c17036c4be7e9a03296dfd021db98bc2c16e818fc4d09b301489b3e2a3266343d3784c95b21aba578b8847617c2b92eb29a7a6382ff07447c2c5718757bad64f6d23a2662c985728cbd5af3b050f6562386c2687be9be9e6d67761bc541aba279052fe5a215a96a557f12804a3cbfad02edba19c54054cd45172623a6dd3eb2f3aecd4540e6213f93ff7f65d8fd7edce8d4e9690c1aec2b4010c4dbba6eeef", "82c9b0428acfc8a3e4d33c1a7c5f8565334b6c573daadaf39bbe413bde06fa3d96367f9d344e2d021583d142b8a948eba83b886a640a15209a9ac8838ce6492f87fbe5d1fac69f26dadb139a71f5bfa0de399726bbbf3c001676e95663c1954059861a42a521250d19ebc2c72018a5ae73234d7a38e887986cf0b0a51c4ff16d3dd767822083e85458c1d141ec20c21e27895df12f54430bd6e208136f656ddd648c544011d320b46cce5e97c41cfa493c078a1c9c92d3ff3b010bf114885a0614578c6554a96d437c90da1e8b327e40222c8471583a8c3dc84c3d90b9f88ea5"],
        ["8a45d3ee762de0816248b90a93f7b0071f8799d1203ffaac4137d9884de7141117881399ba00c836b2561ed0ab637590994ef8087a0ef71b8857d8699b8393a794e73ea9ab12fe2a7ff437cccf02b2a2e7124bd2c6f296ac855b57aa7d4f2ec3007eb45c0975a72e1e20cfd525104be47f793d54627cbc31f9aa426039f3019b72bf7cc91cd5ea78590ce22b76c90e8b81ad8125385b669ae3735003d29d478345951ea3854e70526b536d7c7d40e9a9321b120e43e07965d3f42d3e1d5b35b734be529bf5f8556b7469981a03617cec0998c75f135c88e54dc4a16acf8d358521cafbf8ce56bac3eea9f6957e9c1722fde8dac2910ce4e8a18de2df4952b06c0ac10d75b32d91907c15ef7aa8543bf5ae41bc06b01fdf72f02b377c1df89ce90ffdbdf783dd0770471c2ca14b3365abdb4622a5c9d55ea10a046d8aea9bb44b5859f9547217e3c020a54ab2e0f3802e5900b5c5e61cd35abb6f1388c071224d56f0408a94f55ecf2aef3a6540b9cade8ff3306a23520cb4f33ab39a1c7a6361", "862b601e38e8c788bc82c20224d761eb94c36c3de9ffd1b32ea22c63e70421c99d55c3aee66c4f220ff3500839339fcbb3f863220558dc9a15fbd535cb2c3c0dbb5ecc4499a6fc3b9143cc94517c856d4a191b35dcc28780cd968c652e998310143069986aa3e7bdccba9953a4eff7be594f95c426e8eaf019514d18a29ec2d444fc0dd1b40fda0f78ed2e677d6fd7cf82b33a1e2cd0fd306fde93717ed64d0d2dc65972323f71a9e6bbde026f45b8d23891f96f14118b60c76854c370aff2793bf4fce674664339fb6d59d622d3e976f46503d3bfb5c1ecd46790b7d01a6d4907240a921fef032d701fc767409fdf4688fc7bbd60f64a579ad0278c1765f064653e6cd48696a68edb899279b1f16d4caaf4087e4d2f4d30fd610a3ef2fa9deb4533a1a21f4dbc92bc0546d079caee911da3a7b3e5293ab51f7b54e4f6ddb29319ddc961c6fa40bbe2d4a46bf125467c122e2e262e822b9e3ee34f07dbd122cc", "b37dee311df776093860891b5226c714bad521e2243a5b0fab09a66e20dd0ec292c1161ea6b9b13f2bb9acd3c6b16e5fab17ae0145b0ad001dca0d4ec66b23a0d8a8b3b78202fcf87a0059da34194521205e585f21f36a91c28e8c2c6e62de5603408956477b226bc84d95abccebbc1a0da17538497bd6829b32bc0c239776735c54d4d7e7951756849fa5d25793b1422dadd70423c0d9311332dfdf7b51afd8371232b4da5253c2aaed2607acace6c5c129c9053bc17a9b28930c19fda6de8134652a99096d65367e5643cda936a5d7cdd29a26645d25260f3a7c398d94adb02704d1425448cc947f487569b5974f1644251450ae8f6d5551f4f77b49f62f9819c45a916114f155fed1728d741e3705002c59d5541b3a86fe82d494675d20406b1557751b4e83796399b3f1990aec5c20e30eb2131d7deed31f925791c845c8", "a9d2ff9cd1a5e0729a88d08ca6491d53831a3e332e4e0f1a229dc2de14807667fe0a9d4f9b1c974b46649c66034c879889da95e7e6e7f54e23001b998c7a3fd51e4cf0708661e47f3d09b4e885df60a9cde058bde9c8c0dfdc17c5c3541c924d4539f2d8ed6085bb5f9bcf21daf2f05d2d6a60cfa97ee8af73b6b868c8f8e4f52a30af9c7c263e98e9e11c82062051278c0410dba78e5bc31f0c44aac05d63f80df584f9470aebc890b8916b1fffe7c4ce9828a0f22a14c0837b55c16b4a5a5c637851f9ec48dd172bd88c2b276eb014df9a1f35e418abc58a87835189fad7d372912347569d309afe4e09f66362942652deeaa0cf9d7add4b961a7568ac1a080bbf1372b89f2d73060af74684b27dbec093f277c83321db7b3323dde186962e", "b7b8d9ba73a09a7f3bad41157c11aadb94d25d84798cf1548446f7dd156b29718ca38d335396ca008b0d51c1b264570db395a9ff5a2ad01ae4c0e2e4660d16d14b45209ccf3a09825662cd9bde71c6e37777ff842b558c1e790d908e5c33b09a3da9eed5e0916104bbda14ca8508102db90f1277393bf60895e3d6e860ae0b243116ad0ae8fbb3675677c81b31ca995901b463f5cab93214828353342c296b8d1032713f75851b8a70ea4547820b8143e75ad679c528f065b1a3f7227291fe6c2f68202285b88c31873693dd1e90967b8bb7c77aafe1434e0f55043b1eb88fc772eb2732ce6da65d2634821bee2e48feee0c4a6d46477b54634a53ef5100b40d", "a05dbbeb11a2178fc7e0e572500233ae6122fc49e62990d482d04fa9ef0d9109dfbd535851fa0d11fafba53953bfa18cabaf9f329390e9fe569f5d1ef9cce9c51cb251a4d6a7d691b5fbe6c27b7ed8ddfd41b3c33e4e977439eb821c748ff3f2204bdb59213e7336da4147ca56104e17451760dd7c08215ecb5e3db419c220205f306199d19a8635d58724c6f525174c92afcb9f92f27b2897f885a1cef4ee144c07f72831a978f1d7fd5194e39ba367aaeeac9f26e9036de24df5986e58efc610264e7b2802d0e11ec5497eea9eba7cf8c2a9a6f1031562bcb0a3de88cd8832"],
    ];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFOS[i])
                .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = get_expected_signature(EXPECTED_SIGNATURES[i]);
        assert!(signature
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                &generators,
                &messages
            )
            .unwrap());

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng::<
                _,
                _,
                _,
                Bls12381Shake256CipherSuiteParameter,
            >(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = BTreeMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_msgs,
                    None
                )
                .expect("proof verification failed"));
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test no header and no presentation header proof
#[test]
fn no_presentation_header_proof() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let pk = PublicKey::from(
        &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFO)
            .expect("secret key generation failed"),
    );

    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proof_with_header =  ["a3779ba1642e5f67170ceb5adea51fa8acfd027f3dcd2a7fc9e605b598decb88759d763b92d9c46a94d526f2225946f9aefdf4b998386ecfd4a8e28d05a505198d95b88e4826ba74d431ddfc78ea4dfae2abc54f2635e4839a948aef20119b4e34f77f6b5c9b4e779a9d6762bae76e32f3e843554073e0f72f2dbeb65fb70b0747c595dce7cf8c48874a5af3ab563add235b8c284b36c46bd66237cd0df3a00d135727f8f89df1786232391efb3a1784d56d9b5b34984283746ace255e9fd8c362fbe6dc6cec283f197a9102f9c9d60e62716cf49b3a18a236ac1054be2d84f201d354d3702a2b024e15261ccec69fdba91cd4859c868b5b5b4d5166ee7213983b581c6a894590a9671a96623d742a48a2492e17ff051b6d24e6c22bed8657dd72d744a8d54d803439145feadb9198ed2bcba62467e1d0e5f11a30d6c5149668337faade1af9a5d2b71bacdb861a9b4fb0cd739fcf79449191984fa850f8cbbc520acb097f5860d0e9f31c4f50170abe30a7e38f5f1af0e7e49b50a0eb92ea86", "99a4776dd73ccf50498de7cc7e695a256cc6c5fb21a20420c916456d307388a83e88bcb1b484a9f0ecf77023945a37f58bde543c9a7d0397638a4d4b1b17374758cfba86c3931fbfc64ff78182abd3fad0050e924871d8b2b4630023459b7fa164065b2a257237d7918e38c3cea2ec87d51665309fac3bfa22575bc7aed56e94525baf2ff7540de8a09656e06be39f7be7fdd807607a54e76c5021a18d7fa8db4ba94c61bc0b3f5d4b3436f5defe6c5188a578ca6c7b56932235b72bd2adbeb22af3a79c620997db30eb28e108d4b462820ad1531e8452d0ed49b12cb019839a1250bb0fe216796252339b743d4c4764e7be54a91b1a844e6bd3125789f118792715e7897ea07279b299aa84ec1ea5e4dde6d1eba854528c42c469b9510ddd230d2e2b0761f521ed894588a206b6276bf8bc88fd251d4422778e3392931e72d26b60504ab603bce927fb1fecfae20b2797cb6db0541633be8cdbb667d66cdb0d", "ad8877e9fd7ea4be44fe35bdef4ed58041fd27fae587ef057d698f858e6988f1cac02c06307cfd217d5f27e48a15a8f0b0d8de97e7bc0496e50fd44ee8543dc21f3842cf95ed41faf8a6e20dcef3637cd12be9b38b90249000275aaf448ca3f501ee4dd54951e17e551593fc2ea4ae314c420f0dca63ff83a42283fe84c9cee4427e2c8a21cd07e279e9f96a20bdef4f7fb7c5a5d94b12c637fbc395f8e72b890d1db44128722aaf25cc97a58fe31c730e70dbe5c233decbbbc47dc89c3f0dbd42704953a9b0472c97b4d4320f4b531fa6c0b8de2c829c4dc422779084cfc08c33de6ec5847bb21ea1e3f8de71f1007045ee1b85e29e51dc7981f7a67f9dcc28428385a4fd2a58d1efc3e381f4ae4a4fa251064c6c5b202819350c533e6c4fcb58f3601e05349de7becabcc8bd53ebfaa793d136d2d3fbe3055b8e9dfb096f1f", "8ed8da66c526a7938ebbbc67ec4daae9770fc8779caa898c94db8b77e64f15070585e3470007cd81cdf355b8bcf0f7daa1cd4b9bc13245dd0d1cf5de1636cb12b54cec2bc14c2208613fee2af71abb74c0a32a23f9834fe02e4dc178eb47dbcc41249c100f5753adf956ed0c28221d6241bc00d9159cd960c4b82415535ea1890e96c68c0cd941af804969402e432066fda75e7c2db802bd4c54431a098477683d67f1db23495386bf0c23deeb9c994a6ce09efe8555211381efd3c09a23e3e7008226dfaa7f3f2bccf13781d87cf4eb99dc290fbad984495b8e9acd458439a9495395b3ef164d29a1bf3b10d46cb9b355363d6ffff81c20b886ca831aea3d5a26a1199d7ed0d1791224041901c0d52c4335e8c0753709c1f68e341f388d5487", "b41f5ef4b36ff8eec817af2fc357ee0a5078950a5ce14f71c40ea59e296a61c47b1f46ee5dca68b46abf2c0598bca41f852742dd10bd2a089d7c896dd2664a1fd2e083d9707735bb32d7d9bcece666e429b3912e9ecfb0acab6ce8832457e2164826cfbde224be7bf775ff1fc75021f166262bf46fc7c9379f55cf45d9d225dc519cacc90f8d009e7b3d8fb6f9ab59566e467e5bed33433ba3f415276c2a4041107d299252a7e7dafaca8809a685b2d280966da06de504656565afc8d5ac034322bcd7e2dd6a42a982b90a3b76fff9e0df1098b9078ca00cc7719ccbd675715c44d560115f017045de569160f1a04642f41df8d277b3f873a0f32a6a2f309863", "b26f7323843258e16b7d9aba34a0438b059fe384d83da5c8f0c41ad65080cffae1585abb87d6bbc4751f04fe89f78f9695c5ac69b0b3a7a9658a72d902a19668d5646eaede9552ffefbaf5f863df25ce90f885f8f586d583a7c64b8f35d6c6a1650a9d86ab16bd4dcb881c7ba8bd45ac989f702f3a10118931161047881c623673924ff453d2b4279b9de8e14d444a2e131a988a4d521a70766878ba40800e074520185738a6630799791ccf345edcf2df3a10851cbc0ad579bfaee6dfd7961966601b37edf31a8d734a236b3479571d48886950fec63d51c2917b7f53ddb749"];
    let expected_proof_no_header = ["a9ae12f3ab5270f49305e39cfc3d905cf0e78463c26369ba58699af8badda2c504f0e3778bc8d8b290cad6c0de8b94b081ac7b62ea07f9d970728686de639243f3d08abb6ddc12f1ce6e29b6d8888deac97b155d2a33deb7d3b3bbdf6cff85de4a7f0449de84913af1f675059dc56f83469056e523d6fa72770c2c198d18d971240180f06e06ee276aab6b8cdc4494abb234e0dd0df35c8ce563fe5a1105b0664bc58ab4ee749d84e0455e70d4323b193e9c4f29c064b2d4a2a4aea04c9d48fc5f25a7b8c638a81f1998d57325f1b9daa548bc072078ae9665e5cfc15bbf5ee02006f440a5ba67250f1f5ad45b31073bcf124db8cc15876b9ccf639b8f854598342a9dd3fbff2daae57f172e69abbaf4ae674907bf1fa23c50ac92ba3903d6cf3f8cb6f601ca5579300553a4d3f807b54db757414e0c5eff2daf55b3b7910e603502350b45fe7a50aae8fa4bfa874b9d20149092ad214218676380d6476ba7543df2ff4921e863ea5ff9724f26cfa3d6ace6c1f0110328488eedc0eb4ee32d17", "870248548f656859bc02f640b842b98d8ac4881f4914da6826fc9c131853dd27d96c1d3e419f62cd855146e2a472f0f1856c8d79293803dccde1dd29a28c27d0c3e72d50e9dcafb0931f421b00e72412e6dea7a6490e7779b931e4523b17c7af4666cd227452b3712b518ce6bb494da1839af0a48ce009399248cb6735b3b75b1509d21ad6b343883b51d87bae5be4b171765bf13473d86cc3f95221ee1cc9735a4e3a8ad48314126661161cd9fd45bfadebfebc4a1f9f61f73f168d276d064e49a4fb34926b48df01f51bae15a0736cb29de9669756c3bae7d0c013a66e3b6e62295c5558302bbaaf4ed58ccf64b9f9d553f763e901ed670622b86a25879ef437b104bc094b0fc63c29db2a51bd31b2de82b7d4ff448a10d343643bf9bba8074eb2b766a612ea5eb9fc790e3d99fdbe57bcc88c1a346d69a54e426f641151613ec2304c1414c2fe75a954926b83c4e16bf49349c8f0584dd26c435aacf6de99", "a1cc5aba2eb49302dbfc82a11c6ef56355eb0f156e9ebc96d7d03a4b84b65405df53e4f7da35edcefb706b57f9e151aea48433fa6a69d87e49742c4450beb7c9c0731a2793f99c698272bc9d3bf1ebe480fe35a930b34e42d88b8d41822b462e01c1b303f281644518a8b7850a3a6e971f0d6928c7245d19decdcd210e7db9e5131849f0f90a97b9af717c8911f56e9663229c4751b0a5dc4da30b51e75f75362737d56561de74adcd2adc62ec3f9b10707f69747dd01922b24f5b64b3705b054683afc14738cff41e2ef6310fbd43c0da6ef4b7abb454e52c5c649f347cf2ea489873de8413129825e89accdb38c766d0fb161f2df7403140ceaf9309491962108d6573aaf05b2bc793d459498c075fef055e907477983ea9e24775f5b2616c4a69e14d11ca69574d3177dd6a7738804b7d2fa5bec16baed7dfad353f97d14f", "a1be14a70212c60e079e821eedfe3bd6b9c29c850fa5b9dc3b722defc458f42c32ff43a2d4f53724106ec2cc8083f86a94ebee35a678ab5ad1406edc4235e2c007ab9a96036c3055b7a0334b0b43eb079e487b0f3045bcb05ad53945cda0f3cd120b5d887b7050da9137ac8cb46f9288853ae0841777af7dbf9bd1328ebf2da66cbd28fb2794da492608cba26907914e500c326145d9ac346482788405036e9320fb27be338f7872c1b793231321e2f940b881c3475966e5088168f9f04c75dc52215258f9b71871ae14bcb1c0ed577d0e507293b2fa80d4073dcc9149752d105b3fff75dacd1b49788132540ff1832cec6d103cefc97656b38bed003591da11636a1e0a41d6874b2002ce3d99561bb6027d360eeabec6958bc86daf69eef66e", "a285d16dae4ccc80b1490146f724314fd3d82e4d29d033e77ad61276ec0f51e727d27ae95f862afdc5a9ae26c28b394391fd36d4b2844fd6a2d4bb198ea9ba4c7e37a94316505fab43d97d6a688025c18e654d3f1b5152dd92971b57235dc5072dfb87247decc6b04f31ef9fb60a07bcf596f48c5e15148513dea44ca5c2985d578feafcc66192aade6a774ea9c5b3a1403491ab81f519dfc5ed04fe2af015ae3d9f760933d865431f5f95b69ba9cfabb45a4e08b28825c4a8a1be89156e677f35c03ee75bb2d01a4a8d950d29ff260fa3788121b6143187ca24a72dccdeedca3d15bedab2d8fdeeb4bd0e78f9084953abdd9b41a68e8a6b8e3917dbc469dd2f", "8436f9e717626a0619f46d76167cc8adff8d2fe40b8e79a80a4a1cf2be0645b13ff055eec651bad2904fe52bf05dd5f1a0c79a3c3c826468e904ffdbced0618e14839a04dc98f4ca00a3d5a8460fe0ada8e193628dd2fc0761d3e5492b40284a53e43385d538def058b3981ad22ee0329f4a547ede5aeb1b3e95cbc95d04f48e6e4f2d79b778549d3f82f97ccd8500291808e802dd6985d51b1b90c9204b62c03cb1579a7774038a33568ec464e3b08a02b96e708010984b9ee0372df1f82d6a6431658bf554d94ebdfd65e7264672990e1bc5760f6cd911fa7d060d1a355ad8"];

    let mut proof_messages: Vec<ProofMessage> =
        messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

    let signature_with_header = get_expected_signature(EXPECTED_SIGNATURE);
    assert!(signature_with_header
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            Some(TEST_HEADER),
            &generators,
            &messages
        )
        .unwrap());

    let mut proof_values_with_header: Vec<String> = Vec::new();
    let mut proof_values_no_header: Vec<String> = Vec::new();
    for i in 0..proof_messages.len() {
        let signature_no_header =
            get_expected_signature(EXPECTED_SIGNATURE_NO_HEADER);
        assert!(signature_no_header
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                &generators,
                &messages
            )
            .unwrap());

        let mut revealed_messages = BTreeMap::new();
        for (j, proof_msg) in proof_messages.iter().take(i).enumerate() {
            revealed_messages.insert(j, proof_msg.get_message());
        }

        // Proof with header but no presentation header
        let proof_with_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_with_header,
            Some(TEST_HEADER),
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_with_header.to_octets(),
            hex::decode(expected_proof_with_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_with_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                Some(TEST_HEADER),
                None,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap());

        // Proof with no header and no presentation header
        let proof_no_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_no_header,
            None::<&[u8]>,
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_no_header.to_octets(),
            hex::decode(expected_proof_no_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_no_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                None,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap());

        proof_values_with_header
            .push(hex::encode(proof_with_header.to_octets()));
        proof_values_no_header.push(hex::encode(proof_no_header.to_octets()));

        proof_messages[i] = ProofMessage::Revealed(messages[i]);
    }
    // println!("proof values with header = {:?}", proof_values_with_header);
    // println!("proof values with no header = {:?}", proof_values_no_header);
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for (
        (key_pair, header, ph, mut generators, messages),
        failure_debug_message,
    ) in test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature =
            Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.secret_key,
                &key_pair.public_key,
                header,
                &generators,
                messages.clone(),
            )
            .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = BTreeSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            OsRng,
            failure_debug_message,
        );
        assert!(proof
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap_or_else(|_| panic!(
                "proof verification failed - {failure_debug_message}"
            )));

        for i in 0..messages.len() {
            let revealed_indices = (0..i)
                .collect::<Vec<usize>>()
                .iter()
                .cloned()
                .collect::<BTreeSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                OsRng,
                failure_debug_message,
            );
            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &key_pair.public_key,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages,
                    None
                )
                .unwrap_or_else(|_| panic!(
                    "proof verification failed - {failure_debug_message}, \
                     revealed indices {revealed_indices:#?}"
                )));
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<BTreeSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages;
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<BTreeMap<usize, Message>>();

    assert!(proof_all_revealed_messages
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages_same_but_shuffled_indices,
            None
        )
        .expect("proof-verification should not fail"));
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());
    let indices_all_hidden = BTreeSet::<usize>::new();
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert!(!proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .unwrap_or_else(|_| panic!("proof verification failed ")));

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &PublicKey::default(),
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                ph,
                &mut generators,
                &revealed_messages,
                None
            ),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            MemoryCachedGenerators<Bls12381Shake256CipherSuiteParameter>,
            BTreeMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert!(
            !proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages,
                    None
                )
                .unwrap_or_else(|_| panic!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        c,
        r2_hat,
        z_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_bar.to_affine().to_compressed().as_ref(),
        b_bar.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        z_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        c,
        r2_hat,
        z_hat,
        m_hat_list,
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
