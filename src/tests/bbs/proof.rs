use super::{
    create_generators_helper,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURES,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::bls12_381::{
            Message,
            ProofMessage,
            PublicKey,
            SecretKey,
            Signature,
        },
        core::{
            generator::Generators,
            proof::Proof,
            types::{Challenge, FiatShamirProof},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use core::convert::TryFrom;
use ff::Field;
use group::{Curve, Group};
use rand::{prelude::SliceRandom, thread_rng};
use rand_core::OsRng;
use std::collections::{BTreeMap, BTreeSet};

pub(crate) mod test_helper {
    use super::*;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
    ) -> (Vec<ProofMessage>, BTreeMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: BTreeMap<usize, Message> = BTreeMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    pub(crate) fn proof_gen<T, R>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &Generators,
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
        mut rng: R,
        failure_debug_message: &str,
    ) -> (Proof, BTreeMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng(
            pk,
            signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
            &mut rng,
        )
        .expect(&format!(
            "proof generation failed - {failure_debug_message}"
        ));

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let mut proof = Proof::default();
    proof.m_hat_list = vec![
        FiatShamirProof(Scalar::zero()),
        FiatShamirProof(Scalar::one()),
    ];

    assert_eq!(format!("{:?}", proof), "Proof { A_prime: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, D: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), e_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r3_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), s_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A': 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, D: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), e^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r3^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), s^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(&bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        &messages,
    )
    .expect("signing failed");
    assert_eq!(
        signature
            .verify(&key_pair.public_key, header, &generators, &messages)
            .expect("verification failed"),
        true
    );

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        &mut OsRng,
        "proof gen failed",
    );
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("proof verification failed"),
        true
    );

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert_eq!(
        proof_deserialized
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect("roundtrip deserialized proof verification failed"),
        true
    );
}

#[test]
fn gen_verify_different_key_pairs() {
    use rand::SeedableRng;
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["aacf078893ae79dc794e766b8db9bfed7c4ad6bbff0c092fec0e703f05bc39e1ca71c364ed1daff29b37a3210cf56b0d992fa0e34fa4394bdd6d6fc2888b60603d5f5cb9d668e44bf34662cc6ba9e712e8d96c9e6972775a4ae16bc863209387a4c3f738bf4ab5185cdc1f1f13e931d7a7c5a4d5506c75e0c0d70fbe9dd342b79af3a2c7508926032048bd196cdba6e900fce3e4a850e1c5b7e7554ec2b364a348e010240397b5d2e9fbcb92676a63e06c3fcaa5f0039b120dbff13c5aaf01dbd2f09aea2b2259eac29ce487d9e64fa66c9d45fd25c157470a7b0404441c5624a5fbde155f339862053907599fbf7266382f7141b183c1ee775bef97cfecebe99c3da4f54fa4460f7c3e3bd5c1f5b98b2f3a91e1bf4c1aaf13dcbaa138b3889cd404d0885efa7cf6948d74e7c4d303814f6e4aeea39ddd52fbdc2f2845833302e0f0dffeaec0254f2ff37be560ca1bfc5e75d629de3baa0abfabd2e14fcc1bf8fcf8cb2d1a29fb0eeb8ec56aa10466382c93b9a048606422d3e46cac2f13e6cfcae595037e2d807c2baf4997f02f6e6d68e45e7f6fe2c4db1a102c26c0df70b20da0feb48dc69d7d6c6efa016563b4491f317194d111188fac63cb8a26240223478b51188ca60bce039a13f1ac94f57f725e7f2d9a44eb9f2e82d4075e4785fde7cc52213ef3294af3c98837062ecb6f", "b1de1054493b9b28a40c4b83ed46d08ddbbf128117188eacfe6de3943ce51545a4b3f5393cff971df16055f4ae414d10ac9f6d1a4a702cd0354ea49a1b32a18e97cb0f93e18f54a7c223a8a5d22f06dc5728ad18ed62152a117ee8ad35aab8adac03b35e33bddbd0392381281c1f17eef1ff15d2638698c12060924226824ec01e6d0b9cff56aeffdc83eb9a6e30f3763f327a0d207d66bc54da359c1b8fa8a6c39c77a5d096d681d005eb43dc87ba8418069840afe6c58abfcbf303094d9b844396ca9cbf6ace57f8fc4fb5fb020b49094c9b611eecad16c8b31ff04f1332f5c30b92ab8ba847abf8f087bf0ab01cfa24651d3216f7eefb06cdd8c58c1037b0873d157c4b1d8f7425b80cc6e680f87b1d867fce83191b94633e326a5b31d5f3a61679a52c1e916254ca4615646dc0f541b4bfb66102dca3acede9cb0d2891667cc539251a4d3d2cf002085c14ba48486c5dd7fce850e06ef0c7109b3c44f9e82c9c9cea1cb60288d9d766c347c8410a6a6251b9138b9a900b4aec39df36145f8244bf36a1844c509e3e86586a0507554ecf441b3bfbb04e970d3ce9e29e78bd6c8db0ab4cf3f1004afc5776d09a24e6619a82502068e69e4db0c9dddefaf80b11027f4a795ba82d06932c80d4ebfbce", "a580b85408b0bc770f093d7ba0bb44eff07270a2e2f61159ea051811c0aed76fcc996e321357b1c708b6863c37038e34a117ae9502165d657ee3f3de7df439f8bf63ef6b4328ebcf50121e3883722e2fcde6ecb8f564204ea08b83af4be6d949a6f771328b44d77d249558df16fb2636b0fd4146c4303042c48d772f2bb121af740566aff789aa4cc04e7a9eff5995272160213403391f03236bdb5de515ed61483c7b51b14ca76e388360b71108e15837ab3b6d0ee8209907faefba7792c65781d6e562e966b8eea77d090b3ed1473213535be2354d2707e64ea2173a8b36d98af1008f7139b5ed489a2904227e041e2ed6b5ff7bca7d97fec726fbd796ec18e9d50f7d497fe4fc53b90f6683c59f7f1a0e1f8604681662664b85f953daf816a7cd89ec3437de00b4a9420bc668c5f32716ff8d9e4365c0caf4246fb23a76e0cf813da5805462e45a1c3154716be0f43ec1633e73cb0dc59546119e6047839e71082149b7bfcf58a5aa88415481b576028bbc523a9c0740fcb9ee6064d62b40abd1d204668c29eb0d2051d8e871dab9060f038e0b884a3bf85d8454a91cab643423e230692ed5f6850edf83589b1304", "a7b91e53efa3032698aa6326fbc00304a735e42b322d6f67a5d1a694ae0cdf4dcd10c47a1f6656d4fd2cd79029b263c3a1cf8fcc16cb78929b7c5735b27f4e21fcdf55f796ed3a6f45674b9c1214f3a9fcc208f527d3d079d1bf60f46df55879a9df210da13f075b102afd06816a37bb2d7d77e13378b8e77d0bfe613a5f8199fea7e5e020af669b015adea12b487697076ad1c0addaabccf0d66ec266ccbe5e0b7eb9dc39fae95a6103625afd993e3e30bc592fac7e3205bafa06a18e3e29672cde1d452251e90f078fec37eb42a6501e0125990a5dba7682d5a099cdaa1dbdb368207ca6c3612ef266503b9d8550764cea33d23bb1e018a898c391a29dd117126744b18e7819552369f58a6af1921a0b9ceaf2c326eb9220dc21a6af9e2008fed64ab1a924d003bd8c0a62917272fd4c0414e38ba7b41da654fdaf164271b644458afc288465754983a3794ffc725e1c4d02138a13b955a7f7022bff735d695efbac5d3c05a4e8795fd738d67e87397180c4d97c51b2c55d3e12488cd9b72511ce65d3880c4993dacddb254d02e169", "84cc4a51d420ba2f8a3b3d843f3e3999d82213ee6ee5b5b495be1ea4fab105b673f2feae0780650f07e8bd149556750289b7c2c3d5193ff3fa89223072c9482df4a4002c0d13b4b749113fda65f5de23a28a622b9fe651b6fd2b742aade29fbf969e8ba203613bb2b3330c7f4c161e115ca5c95125d939b755ea2e0dfa1036c47687440f83a3c38f5aa876d6d1031e1f2ee7398224b7b0d69f8b380cd5fb05a2c75a133e5d02369ca1136aad3848619958fd746f597f3e3921876f1030f3fd0a51318b15057ef3846e6a83a8a19b67750c4d7096a93119c1d82c64d84c756763a031785b23437b9d02adfb94aee61aac2eb6932c6f55b0b378eba71ff216cae88c4942b747b40ad81c1d7723cde54c451c577cd45f976979d2a46cd4ac0e3e9421a28ba792644d541c184f12a6be0049493aa2d112d2146859ce3b400db3343258c40bcac18cee757d06f15db06efafe67087a795426f0928ba9d7e79284f620419663c762495a5976b1e5a1299c00c3", "9565b47ed14324e0a6b926722e26fe595742eaee031b70068e30acb90d7364bc49c1e8dedc09891c791be7648afe495bb8184b0186b0f78fb3ee22d4655d236b59993d0d90054a27d11050d5a79772af48e93574753e57b7994743b0a3f5e79584f9e900e93444b7ac7d4b1e6ad035cc77e946790b804c4983d8030074c56c008e72c19a97f7652594e7291da68d89e418d79cc4cbb9863f09381680f2cecb7d44ce1ad7ebbfb445c4f40e33d7d777fb66215a243526e57d7bcb077e6865a07b303013069c9a140092b8d6d61a261b016f920130ed8b495028a0da5a021797f0ce7d9e96b1d49f43adb24532c0d30df36657665d1aefce4b0505ad9f8df9d8f26e94f450b47ac0a21ba2c3d4db3ddfe00ded4110f1358099869ba5b7bec1adfaf3de7ec20252b3eece5ea689b589f45311c7ad4948d4e92e63e35ffffec9ac5229af114cdf0f51d8c506e60ff8031386"],
        ["99b6784c7e438736364d30feffe5a2f499df1775bafae1200ce39414377384f5cc5f529323f6eca74edae535232b0591945e7975f68575847894a536daf1d6d520c0e3fbec05670fc2686eb879c38f66dc9710b4824aea9bfef4027eb43fb2a3aa6b62128a7a900bfb1340950332fbd1c8576cc8817108eba94194167b0701def6bb5fb4029113630d07785d39f6fc7b22a041e5e068b6ea8f1528f97e644a4fe63bc7444e3a018588c334fca5c8b34166fbadb823bafca628c0d04b39ad0c1dfe884ce979a9bf665ca5541d80bff0995de3c09d9b3d4a73aa5f80fc6a749fd90d674582c423485f27c4aa79486e89435f85300e1f6c4379311145e76060036c39ee71f60d57058ea882f580887e93db36e37eea63714c05421dd906baadf039d9eef2ec537525cbbdea57648b89a8690b05ffa29c0beb6e25b8b0efecfac8ad19f2f66d664419443ffa6a8fb27511cb104e9fd49acfa92f82de1390f660c1d0deeda6c282913f37ed7a10d7a751d44b32ea4c09bc374b9a909a95b1da92fcde234df97e0d52a23472b8d8399e550139240573fa04c7c7b159fd5b7e4f3928c1469099278477259f4f7d9c729a2f395510ad6cf974d7c7051a1706d9c9472bb42955598de709f47e719cdcf01619030b2d08fc01932d1a094ae70e6ee1acd4644fd4f66018376f9948b81d84d8e4474d", "b29d201287d6e19d6911a499406e1a6553ce159c9ff9506d795358899d2d9ef990f3515b485df89e654eb2c3ba23e244b53e72043d16746de95f10356dec64873f18337d8b7093418631de5624a877f5cc3366ad79746c2cc53e325cd689cac983a7dc57d36b70b28e4bd6f25eb0e18817abb3ef01c987bc69c20814546f1dbd6337f0043f88195981f4fe321dff900b6fcbb583b4ccda850ec934562f78ae889e7660c0419b5f8af17936afb222b0512aab83b928e5bffafba2cf8311b40fd5a1af34cdcedca61bdb1fe432988328bf3c7ee0ffb824803a17cc345ccabb00455c8af44f3ca188ce1902e8f571b76dac287a96745f7ce42dd15acc1811042888c8c920d5e530da69e981c343905a3ad3737eb7e501cc2d324da217bb38c4320b5b1ad4b4b2c451618a6561dc7abd05bc4e4ebd39931b696f2aa2f191446a0f869d62753bcdc1b29d8eddc29f0e4bc0293a99b19cef9421fc7603e6e1cc6ae90060c4ef56f3928eb6de3e8933386fff533d5369def434c573610a3b301036e2f12e6a10727a49ad98876750e81a176b117144c900c936d2b3a50a4d98f5f6863844e3e43bbefc919777f9974440e20d0923e74646215e60ad41cdf195c2dead06c533216b304680352dcc25fdcedb736a", "8dd1ff608f18900396edd04b99ae7b80c1a6db4d02aeb0afffc52110487f3273f8b9eef2eeb66327a8eed71a4ed5362dae6d077987888e3685f7765a16584e3a9df064f7f65050cae4a5bacc8ee738ce71315f3ed495891775658ce925aa018897540e3d13d1e0e13e6b9c88db4a8f61eb9a68bbb09e261d043dd88636c2abb42c4af7fc7e99623eae04f0f287122c9d7345b493bf0deec6daed323c4d8e5d1cb40d9ac56f751ae7e51990b86aa4fe4d281b62577eb6a88ebe76eb90a762a5e098923ffcb8fec73b7644de2c3f78f3f74030763a978aba9e47bc3aad2a12cf411a98285f7e4fe0eafb41e39df4c0f0396f510cb9b0eef0bc163759c9d478aca1e7df727e68e49e7a7e3c4c317d9fdbdb71874285c1fc1a9a7fdf5df7fb4204a0e42b5d353a4aabc42fd0342898ba65bc29ed1d806d6374d30a819ea471eec1703c9170b13661e5af4713369cc09bf6f93b94eed522f55a636d7f28ee90aefeed1ab48cb29c63d67ec484724d4a751468200bfdbc77e4f672ba1e3509ca75c3f3f0c804946743af4804bbb14da01fa0ab6e9d40b95a2f64b2285e7ca436f491da5471238ab14a08cbb5aa05efacdd574b", "94dca0257e2626bdc1d2a4ea6192476f174cb3e671aa0b906f34175054c7b870a6c2fca994efe6cce3cb60ca71104f38a63dbf17e11f2c0b8d58311758111f8dcbe9a677694fcf9d751c2dfc6737248915a46c399c09786dec8c2639db449cb2b69a47a667bb8efe8a7c4d05b68d0bf5d6209031bbd3e36e284567b1a6054dd06a0e0c04aef0d8aee42f532d5c292c67040563029f79cc63d2128d02464278ff792569147ef16fd73301f4a7698deae9435f7daff8e9c5e0349f9fe8270aa004c1920fed5c99d98c286b4ea97c6b01611f0555fd2f27d34c1a4c0dd883cb0bfd338b95d3a998ff86c0536739bace7e2f67ad085ad18abeefa07189f47c66d22fbfe24c75dc512cbcb291145e874a6c065cb920a19854c90816f7277041b96982f8d533a053b2645ba6b52d39fefa83836a811d5d900497ba76616e50ed8de34f22a5d9d83ef89cfc560d8d4114f70a6825d0b0da1446e0b2d13e14f5ba18e1c48c866ba4839c2ed3011a5356b67e9d132437ac8708fe097cc360829b143a71b3936c65d84a70c2ba431f52598ea63a58", "b3972e7571cb5572a04d6261080390786a9ddbc7bf0913b8f465b245f5b124858f9b14aec44ca845ba1407b0b8705ff1b92fc90a036408281f52f9bdee423d0d5de57e50c9b1f07cdbdb437808a662b6174798497ec6f34d3563a00f2c5ba05eb47b6850e1ae9851cdbbc92b6432316daa776dad956f2e2e04de7a3d0ed00a4554a63b724d7421e63f5292133d42017661bc55df9b22239617f32080a60574e7a7aecffefc691d214d84e2e5ed5d002f6cb5167231151d59e3d008b00af7ee55fb46cf188a5a8e672fa2abc7c7df31521f47fd903c3d87255e273ff17dcbc801cc2c14343d97e6db3a6e54bf37cd5e6f14799e1c32dc79d1805726961ca5f1bd82f06a7a9a31204c457a557de4be70294ccd6fe0a31df771945a6bccfb68e7cf7cb8b5e459292dd2629b41682c0a9fe044e31829588906963b7fcd166358ea06e1061a5f5025d34c2e3d28f882a693ad2ecbd8c1e223ccf63f3c7dca1b1dca6a8ce2c386c8ff96ca23a881f4256fee12", "821a273c431673ece9c29e9875215c1849a756e1dbf34e89c250db9f7434933ab31fd670b839376bcac19d14fa536a61a21eb003bad4a17357964143b9ebb044292f240b521135b3d816236516f6ef7f758460b231928db4366b58e46be32426af705613830495c84106d90e81ac96c212daa10fca2d4e182e33c478f76c0ecffdbfdaadfc8bc864e26d6f375d5e73181f721a85c3d0dcd2737a4d4085e467b58f975a0011d3a162ce611b1897477f2d4de85a18a1b3a9e425687e3666c8722c1999d56b2193989c8df663aa36df303144bd6f1f72cd4bbcaba3c40934f61d1746a72b91876648e4b11199de0f08900c3faa9c5c51bffc7f2713ac97779bb2dfc15937ecdf419e43570b9b1b9555aec40b7f15b3d2ae0494ba2039818d296ac6df9dc7183ad2836a2c3934c9d523a9ee0c97c8f18a2152359ecbb0da427e7b2da0883b8ec750eeeb1803be3d9e4d25cc"],
        ["a69cace3ccfab303d94cb172249068b8e46bc3ac2ec72c480a99651d50241055126d29531ef75ab1c0e9a44f3559a6938b63f0b049435666d7c15279873fd80d1064327b2161385c6f7540b8e91a4d0bfa204edd79e3e4996f864a2c03103983ab36c770405c3e9bc11820217f1dd019c35e076c25265870b35e2a592f72ed76d7d72c370ee8225e7318729cf68dc4ef020a63836809be5e04d283dfd691887122ea3140b807893de6b76dbac9d31cc970a93bef31a44f427c42cb02faea5d898fd61258f4a2fc1c25ba61fac1f8818702e2d172ec40284ec408e67851a7da12eea923ffbb3faf4e3caf808dc886a2716c1782d240c0c9e7344d751fe9956858ab8788a0f8723d8f4e377d909783084e37b56c425f04082d52a5ba52058a6e036cf44bd81a45de00dbda87e3c6f4885639637e4f6dc8280855ef41b9d0e65720257be3c5c602b58a1b41aa0188b965973200d2cff35080e10607537ac1e0aa948618b8347b1ed8ea495d532d33a26c0e240a6e5ace41d9339a5a299d57d3b2e4ec8d2a24d21d6e046896a4145a7525c20debc2153a15fc2d05e796079c9c4f84ac45efffae4733ef1ffb398a6180df9537e7215a19807874c9dad612f4207e77c44ecaa938b589a75835b3d51ddf3eee30dbe48d113d62d1e0ecb4eeca53df950137bdfd42076c323e09e2b2fe543229", "a7e957daddf78b18d17aa552920558f555a07789befa52870b76bb9007b1873936d0bddfae69d5ec7918a4c414618bcf971094d36f478562609d4709cfa29395b643f1c6fc972b0fc512ed143a889d77d4c0b2a64a4a10196706331ac449e609a2f698375ad9b63b4bdf81fc19287f7485daa8bf4488aa59d51c899eebbe276ae45429f3b9c4d4128a45c05f6682d5c44fc288d8e8b5944a2857521e6f887b400418163c27780b71840df95ce40217d0020451a0fb105762c5898c681a5b2f2ac1c46007b5760338439f62cc15ecee481330abb5c3dad5dcc32cff7609c09718952eb9c9b8f4382e4c7935b9a8cd543a01ea62f76c5252958e3498c1b374cec2400673fa0937cacbb7dbda256a4229542406ad84445f247db358162d25d8c38a7577b498252f261f1684a4cc5d1ddb2b2d81c624420fdc6ee26fc8ef4c8b407c59d20f6104643e3fb23f7afd615e7ebb596fa3aea6f0c0e07089a323d3917b1629dbb517dc97fc050f0b0a0198f08d4a24bb609f3626dcb811de413ed3d929ca282adcb07b3634a7265be1c0dde9211b4be60bb4970fe08bc4660428bf1eefeb6aa36eb831b2aa42f5e5702e65c7e6766231a4a2c9f07112bc59f0f14258e055f770a5e552d8de2e5593c69bd787d38b", "99c7444f70fdded323acf1e9627b4e0ee886a83db01c851b9093c85af36728c1590b90564a0db617f87bc27c8df0bff1a0facb20cb32c17e7ce862c9d69ff3427822c18c4ceff5e82f51a0efae064416ece80b24e2187167964ddf52235739fa8fcab578db98cfb8b8cb338604a4660fbf7561ba580bfe6d26fdd89443da11805e320e12309ea72ccebc5e809688574a3f19c05ed89bfa15d8f64f58daa60f3418b2327376786c793dab9147b566da2a1520fbddb5dd04e566fe70e12c430652d7b074a340b3f165d02766b397c95c5e6d2d94e3d892427dcb02f9d2bd1878af841dc86df5fc24497755377a39732c2d044a25a2cc58fc595254c8b607e830b10be08d99fa808ec6d129b285e480a3cb73ea94632deeb42a8ad9e97a1b1038cf07db20b351ab024a77ea840717d74ab71610649318160c45eedf56f7a586053c7ff4a59a3a85bd1bdc3728fab40f56c935ae03fc1e5981d34c810845a1e9ee24c13920e0837470a615b65ac38f53095c4b85e04c71f4968ef3f1d7e2a5e121316369290ad97db6f69d668af3069085f21b5c545bb8d2c2f2c4f01ea6f430a00bdee94a1693739eb6e702d243aef15416", "856a412da19d583d9b4f43cfe623d6389d97aacddcd10670e0bc0ced02cf96bf4171e8dfa1972ab555760ebdd8768af7966aba266a4dcd205788605ce0fcb55474dcf425f488d69b0009b7181da650ec76570530551f0596791afcf5afc9f9d8880130a412d2c8bd507a2a91f18abfdb58c6cd42e49e4f74c69c04be5787a9b99c9380f0ec16b87948546d9a122d404c4b636e77a1322989f741fa8418e6595855410172f06ca1a3a3c17dbd963f093a079e8ef93707666d88ff8166de75af040c3b5c18e79bf2b5b45a9e5100f60c652331c373ba8bb189f049b928ee0acc8c687e5b54a1895c6958725017636f16016fa8788f726c1fd91fb44d0d7d7a507d0b5333273e1839444c2f0ffe8eec16fd41dd31156af8f08712c469cb3a38ca2850efeaa024338113d1a2cae2f04b36820b225d38328a1e5cf55967f2eb0ebca96a28ab84134f260784c0fb0db96bdf18345386670987fec43a6dfb7c84ab117797642e05d2e6de2209194d570ffaec8c33dd171042668431266ddd01b5a95e912ae81f2f3b209d434b9c3173aafa0c03", "a171010a58d71cff224050bec131cade33971a350f3f963039983e41b36620fab8cfd7d8a35d90ca08a09b1738fa351786a7ceb4cc13500216efda1f58218b34c5862313680c1731b665435700ed63d9e7bb1b1a5fde7b65a913cd240af8392cb902ecb46caa194a248ce2533fad682cd94e30ef24819fc7414c8ae89437d9be2ae7c6ae3c934939eca5b5920bd390506099d392519280bb2396ce49668867fd38e4069c8638e0c437b293d2e69b980934150623c9090675edcccb310d498288fbc30791c5e3048392a8825b9002facd50ade90379a1e6ea41466e7d45867cd85d49395b1c1e2bdb175ab5a86061a09604166b573729a0942d92e94acbd52ef3c23fdb494be4adb9cc525d94f2a6010a148659baff6b726c30430cc70d95d4036d716aadf1555ca451c5e32d3d5271866e9b6d2680d08ad19e04948f070ced6841dff6cdd4f96c73911b39493b713d073a83558d587d891bcd53f3079e42ce373b74165342528029e5ff32f2b9a54888", "b110afa775c3a1b44866c1363866c7ccc40ebbe85ca68e9b0964b0ee950c406db7bfe4bf2420783117d7733d892e96d2807201f4d24f96306fe4463103c4aba3614fee5bd70dcf6b38455ae95a73a97d9aba5841968a14a92124dede543242f59819af3c8ab618ec14839f096db1028cb3e948f427a70b2d4f87adc8d1b2efe16ed80e8109ef6ab7fdc6742ff258e4b436a3df89ea65139591dc224d8ebabc758ad7461442dbcb73093d56a32ebab9745c61466169919c82e55844a7b69d164a385acff5a25f0ddcf1101ffc34ffa4936c4ce3f3a84a3c9ac700cfb2677eb8df7b835b0c81fda92769b37b7e9d9032882efb71f64277bde12064e2b1a1ac58e816bcab34cacfffb7ea7473293ffc91dd25821ece469465250200b6e8ebd9f96b2d15b2b85db12ae36944e6678b57687546c7c015232fe794f44658c688475457dc045853c6a23183931a3a6cd0743b80"],
        ["ae75660a0eb92c0d9e9efff99c3eb8de60bba80e3eb599239e6b654d3328b7bcf1130c8fae339d2d8f85a8e0f5cc807691e82a7308cbd2820b8a161b961eab829f12ba7fe9f0dad290d99ceba6bf3e0a93894f9f9534b00cc3e41ff8feafcd7688645825b6e9a453f64b01cf714545ef531ef3cc0c7431686f587564a9cda512e4ce9eada18094c3b6ab8e08e320551e646cacc53195409cd7340cfc835dd1ee0214e17e9ff07b7559068244f0766386552628312c8585fcb039c4b18c8b13d5576da613e18c6ce8dbf9f83e669e2e356d80849ca830ca2ade960a3994805af064df4855139114599bcc9e0f22ac03850a4426b9921325e54aadcbf7bbaa03ac2d651cdc020fdac1d2f1fc551e9324c4280c57bc0f9c2dd4e476520f7311f48049cb1d7e64f232240e44cc4bd043a90b2e5415be4722f4e3b34c7e47e41ce87acf451485132dc0e08893693faa6bf3522bee869eb6babe99d7f7306193135dc63702b94f2ceca44b19e3e4f5a02325952492ab99e4aad16a2c5fc2a9f50a1fd0b48fa2194937e80d328b511c09fcee5743d63de84077535db930e686dc99c1022cc424f25f95928c9f07841b769451ac6cd76c6d52e30e08ffde55965348d95cf7698798d67117fec3e4191d6fb778cd62626c2cc2f9bf8e28701821150a954f8dcd0621247b13cff65b2b253ce1367a", "94275170dfa8c763ffa60d6a794f2385702baa175b4b8ca9b68713ac741c750a5caa4d908162605ae0027f2fe887b024a295bac7bb3c63e6602865aa7b217433ecef7bc2651ec0e721ae7e565f747e5b7c2e6a796553f6be3847d997c4d529dbb3b6acc1ccef2141a99f991430755eb7d581b10d671f4f7e7393457ffcf172600c527d912c2069462cbc3a5c420205333c1e431d9e1dcd6c348f414e2c9d863996d212dd3a061c262e0661cd64c572e01bee77f7a444da0e7f3f4a8f22956de4d14e37e8814675e295e188a127b38e2a62da776bf0b1a064e10a73b01117353602129c86575388f4ad830f978039008f11c8f42885d011665b1493b124c95358ea1718f0dc01faf42cb7a0c7f1b5467c503d45de687bc1c8c7c04a85b0a7c2b70651b1e7ad5819041e6af1fe5a879a3c611cfefb40831378a106b10b6ac456a70806dd8dea5711206ddf9ddf78740acf5f2c0a351a0f92507d61a60462be192d61ec8d46fb51b97117f0fbeb8fb437dd66c96a868f96a3bb69532e67f480518ebc12ae61eb151fa25df1c9a366357bc02ebb40346685da85f74d822adc92710fe43f86d96313e51b319b8f5b30bb510c6fb6254a6d809ef1db4df6bb0071e2677bcb35fbccc41f1a8e71702a484e46de", "a128867fefb5f524d2214128e156cd9580096539443a19bc4d9a7f2fe8ad33be7b9e437dc8f90e1f8587bfdd41de7341a8d4b9e6d32632c9cc72f927edd4c8129e4af5402c5ca25ef5b9572d1e29bd97c530545fd1f0b1fbc54641ca54c618eaa67b73801b862d054cba7d240b10faca4621cb14f87a99ddc25ac400a6755a16ba3bf275f822a87afc1c617bc01fec445fe79c104cdbb9cdcafcb64e7619fa506ab134ea41d2836a7ff8a1216b418b0d0f1aa1d20b103a9d3e4b0e9f1b397fc4a913fc83903825eb1d4c791044f737682ed74f5a87b6b2e32f9a506c815741d873bcee0407c0eee5b6934e0cda8525506d0713bc20d5598be1c7f4b9a3d0e06aae2d87307f298829631eb49306c9190f73e792e76f5f36aa1cdbe7d0dbd6b038a5c30080a1bcf8597507f9033247b62844bfedf5c67d8cd3ea4548ea2f255dadc2538dee9988634e4c3dc3d7d6cb163a42b44c27cbaf3d77771d31e807edf8c6c43d98dec21248422db9e340a4f3b4371b10dfcc830b4aabd8ebf2f2e377a83dfde60877d0c86a02031da45e31f4fe4348c4b697f490b50e55b4f8535937a98b34921e93065faf54025d08e56d6cd006", "a87be748534784d4dbef90874ceee93ecc14bb353c399534accc030ba3a7c35b3a97138d64f730630a52f6a759a73ceeabd3e05e6ff31bac20e15d85c50a9689085b27eea1e7190843055f23b96f11e15841a6bcb304bd899f352ed971dded31b263642aa472133539abc4b1479402fbd447da7ddeb3901f7a6832fa5c1617a4b98861d042a1f41672a22f765cff95cb5a4e4a190fc8ee8089a2e4e17d13e93a316a6ca2acc399f3ff54c151ec76e3024cad68fe0eebbc74011b78a921a82319d5ac6cafd96051daed1f05dd1f0f07062a5d7b33f4850eee16daf9f38b4d82e0ce0b4661ce48a335c44bb82caed6604404beda9cf77017361a17cf4c6dffab41ef3b4752ed103c892c077e0da0656f9820d5f4231293689065f4b392aa9ed72f758a4d1a02fdacb1d12628e51b01abbf033c6568599f6860a601c7f5c258651eb89c71cdd4fd55aacb732cad10f8ca4f352e8a2ad195c3e9f90ae5c0a9db612e4545384bad7102e1a9c0570ca3938343735d3c9f7d6d04e2182b436405f27b6aa9e2fdbc4acb196aeaaf32d7059c7f23", "8a6bc1d7e97815e968514cfd8f6e166a2065646b1adca2af58a3739e9d615462ca94ecc39949d07191dd6a732a3fba51812f7050b37b0cbc773ee095ee68b6fbe5479e15420dd03b3a758a81c1bf14b9f44958e91d9bd379b2658a0b784a8109a6d8fc1abced1d524405c46844ac48aa9b2562e3fa65527afbdb9e0076dca67a890921cf95b373ff216178a8df7803646fe218c991840ff51016a87f9a4bb1e0921626b113e0f62380b8a36badc5918936305ed4180bee930b7267cea146a2ec5eb54ae803be8b6c53bf1fd5ae3d5bf555cc05936f7f26ce2d413edc6c84b599c948a3d3a1a4e0bfe00a1d35b483115528df58149bb4a138fb24ece3d128cb789df22d8482d3121ded72ba78935d548252b004698d817b6f766ca27121e96de0ecec1c734ceefd2539d62ceb39e8f8b20f57ef91748269d781b42bc8c70d87bdb4387616e8c87b905ba380991fbb1c1a423d09ef851ff8b4e1215312f51889cb1c6db39695405ee3bda4fe7ecc26d8d1", "a9772b532e447cc5ab6c881d204950f5feb1a0aab0810abd7626d9794da500b0818052d3a35ed506f8ace72c67bc12288c0ec2bcd5e9d2aaef514106790e94f50abb37cbfaad59ed4d7ddb91833fa5fb111e0ced1f8f5f1be5338990588fe4e8b0ce929bd0b634e27146db6168170abe9ee23f1ba8ed5e64f2c5e4a8f5a52bb5e0c139127402a06c34688e25f99701d3387a3f3a55aedd5cdb5e6a9c206d2856af4e77cb212d19e583c6b132e39a49722490f43e415402a5a7d2c44af77d8eed83ef90da06a0905d2187abc8eed4b8fe129fec18cfc0ca156d71140ac49e1b9d8d67f69196fd8e34c783c93c328bd84d4fe0925f361b1d81fb50eace1c163287f9540704e5ee1e86d3d07997ca6bff281ed8d3f5814831154a75ed53982f25f2c5e611db1a698b11549de6e7d809d9423337dd3186657b3eff5e5d5628480f049e8d69cdf6565fb3c0fa6967035507f1"],
        ["879552a849dd5dbf97df2a746c2b0ebf9351100a75417a1afba8a9840210f6045c2eb9da225f0907385fc50565209d71abaee3084995db8c28a20d38001b9136b085483d42f2c7ac4023d450c23856af38e7c5723332c098e92bef99bd25a8beaae8390eaa528a52560fe56bc10023ad87a386a60cefbf4df9ebc6fb332e15af27213507545e30263ebb4a070c2bc35f4cc9dfe711ea724318fc53e9d3c2cd57fa997ec8c2570342c3331f84778523ca2839e231d1e93686b99bbfb7cbf2a7e4fbb62ad463aa3b27e59262071409aed84d155304a79692cdb151970c96659135cc511072312690dd2ffee66a23a2885f1323cb13241c41cec289481769a5a96b9954e02b9cdc7c86a65e1e4802f5f01c4f329a4618259bf0faec1ed13479b5ece5f85be7604b3b92d40aa61b31f93a5040c336947d295f24187888e62844fa1dbe35e3481e5e2ac8c0b8a66d1b4eefd1168ee0db2e0d975a5fd1717004963fabc19a163ec41e254713d0b62ff19b13640c2f7a53e2ba0fa7c44a311fac01ad80f57978b7a663aec12b0a3e2e3c043cd467e7e975943dc97d72fbf00d933f36aa5e6b1209159bed90f34db0f2c029e8916a01d184d89f2247d6ca0d64e75690d795c7a4d25ef33ef7c4b304311c45fdb0501a930419fda0867b379d13e1d46105e192e1f3abcd8ac5820e882b38a53a8a", "8e1ce1b59f9e5bf60ab943154e3d67a1134cc26a970c1c4bb0adc242d7529c25b73ca1b28de2beea399feccb1c0650bd8fd2b50ca1ba7921ec08d0424938f78e5e84cc5bccdcb95c73c598ea323eaa618e06835bb7ee2ee06d20be4ab2f9c6ef803c0349e7c3c7244c6069a4e673b08d78d248a1a8d1b7092864d051e8da59ce71066a4ecda55e78b98e1b624faed106608e4da7c8cdd3fcb176e937fcf63d33976b23bd525f2a44ccc6da0437881bfb35d8fe9212c93d3d581c1cca86637a42c1357643d7adcc7c8c00ed7490b47fbb6ab932df8b0ad74381953d7129f9f478b436c5242d6970b7e9b9a80eda3dd2d143e4464a6db8c84d6468a6b0f70606fb2bb75150a41e544c0036d6072a8a1f943c88cedb373538e5830703d6cf5ab0312cae153a5a1533cc81cb4022a8719b79399bf4aae962a23561c1adc47f31b338067bdba8798ec61a5bb664b93379dec10e7b47c9a42285c49c8f0c4638221a21e983b4aa9ec85cb1cdc49c760e7af8d16b2ebdf49129dfb3cbfc5e39d2fd5e5ed677f155dab35674d2c28700a4371c110d68840b67acf4571d792bf0ac75da54aec54a20099cfd100659568370aae532420fa1b2d25f060dc15bd767a18f56feaad2bdb1692e2f843157c6f1d3bfaf7f", "a30f66ed4bcef18d4e5b00b022c0e1673795cd677eeb0e99933c2d8cab929a493fa4bf0793488a50dc17f6a1522969f78f1c9a559bfb49b0583e355166599a2111167ff6199e9727001208a6cca9ab08502c70552510a4507b7f9145860a25c6ab3aba9db09ca51177eca2322957106b8e8461cdf668ffd1d2a97280cb07fba0a6afad2e74aa5f05f5f79032509da3345c2f31e8be831a994b9583a939f08543bcd61bdf2a27719c2272d6892782d7ed5e5dd7e262272e309fb291927f67ebdeae00b7c268bfa0117952c8df0fb6c20a6c90b226cd980197c1f6e9353eb444ef2f4b9d968042d9a794aa3e85d1e36fd908c7398b7bec073da84d8471344cd3520e6571a6268884cf8949d958c509f4eb5001633f8a10d6ae6102057e60be5e1d3b1318b5b3f92145395ba836b619d2c5196fb723f1af2cc72ae1d38f144ed002b74d007df7a188224522a55e8c4bfccb3940dd598e1841cb21e99bd24476423402f41163380158f29afb362dea1201fb678b0a9ae4ed2aa39a4baa2ecaffe1fce7fe05b97da39c6a02d60881fbf6615c41432dc76dbdc13317daba46634d90b36fee99497a41f57eaa632e3d830af119", "a227c9a863aa86b5b82714c07038e85aef3fdd938db102e7147fd123ac83e260b80d7d9cdb57272a6d6930691eb9ced1b9eb79f714e879f25e3a75d17fd1c6f4d97cc6e9cb1e39089b091a358c0bb95a61d0e868f3489f46a2918b49b0ba980285d4caf093646e50d5b6b8b3b9b1324fe4c67c3b66e49882608bf79803ac4e67c7898bc0f4aad493abb035e2f9a9d64c09ff84411fc2d1fdf12ab45b659cb236a4e4856a3178399e336700cb15f9d9d8123b7af0f40f8d8c4945860f710cc2f1de9845e0951674caa1d9726ade9d323f65556074a862f3e3fa98de6e1062416f1053fcdea20424903f3ff52febb0667c1628e7525c26b8842ac45d11e783042752fd532b80f1de5f3d3c1b75e74e884a202460815bf8b9dc0ca0b4b1f41ba62ce16f87c1505d44dfe1b00e4e00f841727134799477b0dc7c20ff8c4e64e7d49276d9075758bd07f30d479405d768d3a025ce4716084be0c02b4cedf56d245dcfadd96e854e654c142cc55ab305f852d6048c620709bdfd7f43c58574e4af0bccb51adcd709f81656a2369244c674e9fe", "b73a8db2dfc6d0d0de292c0fb95d72c87ec9315d5ac71507ab80d3983046b300642d0422beddd3ed3884cb584588825e92a313d5e36e337ff9a90cdc154edfb3b05dad7582414ea98425df8b93b516a8d35824ee3f5978235b2d81297bea27cd9350139c9538bd85857849a5c809387ec3f7a82082c5a8f631b59b143414b4fdfed4abb10ac5be6735d384f2ef6735ec572cf95c77559ecc9d6cf33c393999c82a9a9b1fd8755889c0420d54ae3e630604c8cef36f7211d529ec8dfb11d2690fa65f90a19ca9e28cc400f8251b569daf37feee25ddb4d24b971f6f20cb65dfd6498fcd9505998a0a87f36d354719173234d49aed64957cf9d9d26a164b7ebaeaabb85d88847718619dff17d3305f5e03226848e99d78770e0cf26373cff6d981470ffd3a831e726ed2baeebe4a2506a45e9a1fdead521b35b6b80e84d159949970857abc4a81d2b3e4aae8d629a1abf32cba0f45183c169feda1598f743255c36a74a9aac3a6a02309aaa9c2f070668d", "98ad3b6915e6377467d2f0c71c761f8d5acb8889059dfbe45087d9b60531207eb3adb8b8d31f0432c6b17bf9a576688f86a19543ac070319276210d7db42a93653bc8a4d554f517cac28689f32fd0f12de11b3a1ea7446b340f56fd6ab1553d182a806c414d982c24e4894c942abec5ced4b1c0eea80c5df5014a0b053946dfbb2c9a3710882ed315e4d1c2318766d8a134fa42505ebc5f72b438db16455e77be721fcf8f7cb36be9c10119d7c81c3224fc106d83952f33c42996ab416410f204225d024fc7515f9e1b77be50005b6250fbf136bb30f1470ad48369a4be4abf802f0fa15fcab35d858229af1972dcb66725447f535a2fd9592d8c0ce8f736b809c77267871f8580f754357288476fd1b18840e5083d74134ed24f12e3c8b1552f5f9259395002afebcdea21a7d6dc68d48644f060099b1fe723a462f828579e1500ba3c71bb80bd8a6b456a55aa4c5cc"],
        ["81cf5a6c86046ca16505ad24b9060c50a0832c3144e44eea7e697710828979f356679ef16c6d2fd2c92b56f9a67c87a7b05db81b92de71079f0e741d3b8ddef6d4aa833a15a11fed6dc7d2014f818252f92e72a4d972bd04664fea7fa370b8faa61290007be356641b87eb4be652741efad0b6335aff9093af45238210aa0160dda277ea1ff5bf28dfd18aa01b10e682450259f24dc415f36bbe5c934ca45f4f3e073a5f6f85330c88942df92c333eaf30cfc0dfa0d623ba3c00b0a15d86d73681d4b2b04dad9ffd08b97c60224ccc0261f7855e6f3d04c810e61a877d8e43dbd343fac7741bfbaa12a3c515dc00bd9027395828359526637040af8ac6a92eea6140a44473757458099c81107e4713a92c53dc006693e3e1cdb6856a1536f788586e2578d4bfb7fa71262c49e5af78e5255701dcad7fa86d037bf51a4a0bc4699dee2480815511429477ba2df311631d298409eab9c84e95e90e427f19b4f001df42ab868ee1760ccf745bde01b2ac5650a5518e6fd533830d53c7d36adc3b69538bcb8dc1cc725172379431509b5d7d44bc9627344295fefa29b635d384a9a74ad7593feb1686129fd419326ea4a03b1702446938255a0910715ad480438370c0306d2e791c705558b5ac89c4f51aec14d2972ecdc6243fc97616db83761d5b6bd4bc75eb9c9b4d3e1cf6891007c5c6", "8136cdf9a0f8f00aeff3bd8de2dbe8bb8fcdadcb8f9c1588998907f5b99030590a5436259e3488e573ac591c773117a48adde6922b893a7682f5c0023352adb374715bd7e06e8cd9fd669a81acb213410da5e24c0d59af0714bb78348c9a811c8b4e0683b47ba3b3bc9fb4e9901394892327edc9c107e1861116534721ee39e78ba4e180cb64c30245ca4c90be75737f120575b92b1d5a16245a34d1789c3990f4702ccbf6d043ac766b93bbc009d7501c1116be8115ea8a46bce9a6b98ee5d5cbd5bc9ebe53c99aca58d32e71d5d20b5db47323cb67f6def3c9d500096466acde2c56c1cd7e135152e4fa060c87db7e4057e977fe3be4c4b9286622574b4d0eb754f944ec490a97800c070284b1a3011e30e1d6c722140d23032d73639c3bfe3ad2b2c224ec59b0d71f98da28d5951d60da680e3071fee100f784c12f6567ca3f34ea878c4c994d0af170931ad794f40d399bd7f83f6ee1d3d0ad7d8ec06e844eca1f0dbf2b924656a2612fa45c2f633bd47630781c669e99ff82b704e3ac11ad1548e06aa41fcc6cd36875b0949e1e6cc5e54caf74eba1953e539406934a14b58c9e22531a80a23eba3f81ffa7d5135ed6d978f0cd7d40b4570867603b5bcb040f0ae31437c59c576dcce2456ef4a4", "815bcc3974142077646bbe876a5824ccfe7fc1fbfa2011189d1052b0e4831560b7c2f5c8a4fb8040ec9e267295482d57afb89ddfa356b047a7109f2a62e0e6fd4f7070ad890c7db0590fa049ef9ade02644e324aee089776c507dfa582e4fd6b823db172553c8dcdba17eebf72f7d700e63bc746ba3a38e5a398d07dfb6c3c1cd66d7e823db4d01373714597c551a73224af5cf7ba59098f89708a97034214e904bbcd47fa583012e7e4970b9c19486538a2184aca0612974a2d92f001a15247c670d2f394740f79ca1e3ac9136094592254d6f0ee667e533480d4ce0920929153f50f5afdb29eedb705e6f5e9d8a913738a816dd363a64d13a11a54cd8361fb52f02dcbe91f5b1816c5021470f0722b4d44db85c212352efa5129612d4525a2216691f8c6fb5050320d3218455fd4590adc7eaff6c0d2f0a659b6740042b2de2e895342398bac47c858c4960c44e4a66b81c188ad3bfe523d40a99409c6ba85d0b42d1bcc0b8727ab7ae56fc76531b221536cc8b378804f0be2bc80b90557882c7acd3aa3069cb34e195e6eb567c49e6d755a915f391b13e8e4d549b823bace718f82b50780f86b9bd8532e5eae8e32", "b9e993c4619f24e9471031373bde180557670907fc755dc0415da12be5c2f1b18aefeaee974c6f17613992e43ca1996aa20d9c08f9418af3d87d4ab9c9a5a7267fb73528ccc9e6f61131a41df0ea3649b6548f776fccb1980244ef06bdb903d5a911c94edc0a3e6c45649edd21d1d241f299cd979a5734693c6bf8771e95e41fee2e8a0bcff7f30aec8d612c7fc087b571d389aaef2bfe1f1ad8b18a86acb5f964a7ed70e4cdc4a44d1abe1738d0216201ade45c056db52445d6c79128fe57ee19af23153ee53cf3d7c6e805e42996431c1c80f1b7a2dcb0ba6d8b2224c118db9d20c1e7820e119e9a7e62a1e435288f5079060d9f6c40d6ed9bd685ba7e4a4dce4076ba7465aa5024087e8ddbf1352466580c17c8ef2f543aa109ca4e82bb2c5114906f3413138fa7eb41d570998538122183ed3d57ef642dc1d4a45612e4cdc1308337c031c31f8f5ef008c872d4f603ecdcf1d74167b568dd7b75765502992891eae925b52d7a4b1ca19c2d7c869065ffda3b4e8d64b33d396bf6e624d2281ddffb2e203a5250d0b10c21e75e5a7f", "977cfeb37bc945d76fd78d146e872fc3e6e7cbdc0f576585cccb670eda364e1ab8ab50b21b9535d4444423e1be4340fe809be9cca4a31af6cf841c24372d80da0785a9978efd44a1ec383ecb2eecd6f87b4b59b44135ed17769397cbdf473700830c7d06046b0ec242f3b3cfb024cdc5eb9926c86977318e5e20a4d17c94996bdb8b2da8711688d301a6c09bfe1109c75a961e82ae52445b32fd6a2c6959a005fc184c151369041f3ac8648ca3c14a4c3b16d314e2011cd00110710d35398065569086cda93adf099c23e4d5d9bb02f9510a714a21b8b2c022f5a2a62428dcda8649171e933f7c07d92a997e496922e657b5db74539e95b390a28719377c4824b5ef0db635589fd86f8f6006a8c54a1817439a621c5a92ba1b2ae847a2fc6a4a718187a3a76f7f7b936b04062cf1c937096f3f364499df9d33b20741e39ac49a8a36ce038ac49ce2943f70a32f2ccdb726d2b8c317d037255f34c1a16c80fc5cf96934d0ab200a15bb8f1c0da01aba76", "80d62eddc281c12b9c2cc7ecefa313c9e9a9253efd3ceb8c912c2c341350f1cadf05211cd5b6c548f35559a3f27669f7a3bf08a237bcdf613f3c4038c1801da660e853e8e4b3b293e15282c7fc8b3d84ed78e51e1579fe5ea360d7313f1f16d190d3a76850ad25ddfe9b92cbbbefcac22736b86725e9baf605353723873abaf8a8ba6b8569e4f71b9933f39b0661f5d427815934c7c07f92b364378548c4e0fae6f4cebe41b7789a4ec1ba9a4f8644321c46dea8beae851ba49505fe84fd47efcced2e0529220eb83ecd399bb6b24895108ea6cc977cec82ed79bd56b7adbba9667ff7719782accb828b3c34e49b27fd469c3ab322c08c4980176276f80321a60329e8c2351c828b6d955fde32737fb7655e14892c04e3adafd65ffb2eea4bee392857b8608cca5111611bee4ae1bc0401c36c57e19414950a0dea5fd120067a335cd60be565ff2a5d11f373d8dd1e3b"],
        ["83f1a767a05e53fcb90317d8218cf99582315040a3016ee4cd5acbefd9f0ee3be20be35497165bf7927c6c2c3fc91b40a39760506d04f00646f827076cab242c34c8aeeaeec1c350b8cfc8e91bec247aa64d6a11f2b3bf71732458a89023617daa8ec1ccedf22a454ffa1b167eb750f748db5cf290de93f7c72ce34d5f68cdb8ee0efb095fce93208d293b1329eeb5b01907754e0ea166c51fab9a72dbb23817774d5936e9a49a2073bc002663fedeed70e886514e215d43a09cc5a50ab5f3ef328591389ef20d26fa0864792d83855d1015d4ecaeb90dfbf2580249ec3fa70172ee672c6a5c693f3e9767f843d0fc890ecd70446bc5bfc7172ff9d4d3c710653e60bb2f14abecceddbbdc0277cf41f13868b032f245203cb32169680ec5cbce76dd7eca4b607d981fdc9a6526792d3818e54446721f4c60abab639f583a5d471ee7d791b9590591748651c00bc984a70dba0d392b171a61600d8e45b48f412df78bb24de858c18ac5aac68b6772ac083130402c1879246d0a5b6e08d882b0e33f6776063e3aba5785ec8e4eb610911a71c5c2bd75b429cbc9412a7b78c6ad24c9a49e08e64cf6d9c10e742d2f96bfba031045159e2198f1ef71b02cbf07fbbddd41d4ce56828d70b9d7acc8d218286118f91366499705c6903b5939a807c1fdf9bb2285d5edd44535b6858fd3d02886", "a7d434df0ff925c1a0f953c7910a25b1efa21d2e907763bd9d8bc2daa5a1e43cec37c0467018a81b49fd3636b5a07545a3a6c140546463b9f9ca77598f2c435c77d67e78a711163d52c87d79d6783e8c6a7b25218de90f1abddb833d4b807a56962bcc07d38f7904b49c6783998949c3bc212fd8e08026c82548a553ce3ddfcd0275fbf743c2533fee464417ad8bd0bc4380eac1b39e0417744060f14ca9591d744dfa4b15f81abce4002f60977ccdcc1ccef57b568f38bbfb378899c68df46dfcf0346f6d1ef6d3d35e8189514e4a7a703f24ff21709385b537db829b4dc6564470d2022bd185cdcf00d59cb193943d3cfd5f1d7dffe989add3532b269c8d48f19296590a22a0d9666017afcb119d4117e9b253e8626933abe66e7534e32d4e4e34b758167cd9a71cd36055a58c379d59f036d5bc465cd69cd71a23932f227b6a5717f4f992b863f786aabc997fc53753be95ac1c2592e3315fe38debd9235daa680cb1f8e8a39a43d214ed2dbb3e6553b6c79cc02a40a9e319a2587ca270a3a106ee2b3e8ee213c1c6227b19f9394d5e53ad52db9d5eb987d1fc447e9a9846f94d41f0116b3bcd91559e60981b3b8f2b576771a8f97405ed6fc12e1af5aa436bd7176fe3c02c3770673806adea6acd", "a6c7b4a1edb53a5c09b9b646ffed3e54be41dc1c8f107ff98e3291068d6ab55efc8092cc7c49b97e27bd6f7429c2551b8ee7dea00abb7dfea949d4e95b34981e77e79009585d7a75e7472551ba7d12cfcefabbe58b9854bfb53af742c8343d728fafdc74fe6f3923998476fe60aeed57dec4c0b0d4e87e58154938226d79f39ed6fd11ce51526095ed8133db94fd603022c9415fd85f0d7b79fda6d84275c61887bda96f04321599e3265c29eaebeca068365a5f13a31198fa3fb1632bb4cebce4118c9f71ddd37f7fe253aee4fe0253157d1cd435e4cdf2299487ea9dfbcd1aa90baf7f4ff48c36faf3bd64af9e8f3e0d793c0b6d29c3dc25a989f021d9d75d0bb94c3ad45c50eba158eb235f11d8bd02aa35439e1531d25393433419fa2df5d2b2a11d34b587eba5ed97bf250599fd26dfde927ee23604603d313fe4b80b5e369732402dfaa44f0995bbf2fb936ddf0f86b8ebd98eb99395e06b9247376dce7febf2cbd09ca173cbb1da9f2225a4ca5692ce399b24cc99ba219d2f8854df6d9221465ee0fbc6218a4d485c636a0d584035c253149823f330d714a2f47592efa581719db432656982e2cad3fab1eda2", "a92167c98e1c21af6491bcbf192a2a3689c5613bddb99f9b15c2075b7da2393dfc2076a5ad1932b419ebdf3e7f56084ba2cf9a49b09d17367db99ea7c95e2e0d4a92dc0ac1e852389718b7e1edeae7c642bcb9c622e7be1dbbca13818dc8d2a887f9c55726b4dec22bd278af72bcb80f1dc1cf6940b7703f483e3ec0c919577414d73c4f80351c7d8bb9514afc9283d12e491d627c0fbdc777ec0ed13655c2cd7a20aa7ba98d0e182622d22c406f7554454066f4149f2ec56d30fa267d15ea8473a8ba053b5ee94a0f25910c00df408338b4871ec1026c4437eb1bc23f37ac8a0acb68da9f9b1a92aaa801d26a4f35b14b069b49ab91e779c7cb14b809c5030f8e5093b27128916268c5f762dca47a0e11c31ba52326a229e4807d3fdb4622073cc1d9b0445034412d6a86b8aa62b85b167c1e47d7068285188e86afdee796d3374c031fa1e4aea6a4b6ccfa60e1ad1051ad88e34a6a9f3293d51caa0b6c9a26ad1dcdfbe71a452d25b3b59214a36b4d2fa8f5eec84308b25774b11428386b9a04970a1e6a2da5f07bb3c491a59f9954", "96f7e65673629dbb0e077a1ee2a40d644d360ebbb71f161eab13243edd30826014659c532cd508e2490f5affb09c1c508768fc0d07d08ad3ecf92de924b31964d5e98c99787c91d8923aad44abbd76c9859b31fda6a329f9662d20b9c76cfa7795699d5c9e118c6a1f9f2a5934406145f34dfd2a69d0f24d3387a2972d96c816c3b3c6b88b4cc496c0cbabb954d6f44e0be33154de30487a93f2b7844c9b4f476137e755682126f5ffd877af20ab5515695ae21cb5e2b5bdca0fb58f1d36a636048f5a3930604d3269cac9c97476e25f3a2e047857261f3df2a364e830b0abe4837d8932e35fa34c25b6506c92b845e90d05ef7b1eb4d9b31da6852262b33858354634507e1866fcf8c4ed6a4c4156dd4320b24b320f717201f603215cf5d862d9a5ce7d3c28a38ab2de3b3f572ba9365da29f1f01a32ee1a733e620a9e85b9b31c284421dad7f1ab6d86d748fa509532f3f5ed8730615e663f59eae1f8f66fe736b59d08d06f935ce7aba647a7c9f7a", "a18ecc362a411154f56fda57744eb4bcb16b1b8efc8a94d27b1e7dce3938f0a2097d1e20c4599516498419a710e4e6e188cc5229fe4021c06d4ec5191bba6d98babc97f2b2332264dcf53b0234b7c080f5344ff7e5d9d81c9b03ac56da32b338b3aaa8965bbe0e3c62fb7aec23e50da833474e233e403a6a4c67ad55351cd7ae67a928d7b9660619cc94133fe0ea4da03e34c9742dac8b6fa5931d87e469017656484a1365e2f394d546ebbc93f040fe73a56570a39a800f27658f046b8e8ba4f58a8cd05a1554414ea00e669f35c50b32344d44d7a0940d3a58bb0d24dfd6cd3257680f484db7056195ae378f9ebb124890a87b9d38d04fda4d3d27f71a8c7ca81cb6ff13c04c2028f7cab53a4ca1593634e409d9b2760f86b73df02253031e99b1cd4a89dd4d355de89e6875bfe7243a5906db53ce105aab385d3f452312f281e02d40be808830f89cd49dc6ee14c1"],
];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(
                TEST_KEY_GEN_IKM.as_ref(),
                TEST_KEY_INFOS[i].as_ref(),
            )
            .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = Signature::from_octets(
            &<[u8; Signature::SIZE_BYTES]>::try_from(
                hex::decode(EXPECTED_SIGNATURES[i])
                    .expect("hex decoding failed"),
            )
            .expect("data conversion failed"),
        )
        .expect("signature deserialization failed");
        assert_eq!(
            signature
                .verify(&pk, header, &generators, &messages)
                .unwrap(),
            true
        );

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = BTreeMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert_eq!(
                proof
                    .verify(&pk, header, ph, &generators, &revealed_msgs)
                    .expect("proof verification failed"),
                true
            );
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            &mut OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            &mut OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for ((key_pair, header, ph, generators, messages), failure_debug_message) in
        test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature = Signature::new(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = BTreeSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            &mut OsRng,
            failure_debug_message,
        );
        assert_eq!(
            proof
                .verify(
                    &key_pair.public_key,
                    header,
                    ph,
                    &generators,
                    &revealed_messages
                )
                .expect(&format!(
                    "proof verification failed - {failure_debug_message}"
                )),
            true
        );

        for i in 0..messages.len() {
            let revealed_indices =
                [0, i].iter().cloned().collect::<BTreeSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                &mut OsRng,
                failure_debug_message,
            );
            assert_eq!(
                proof
                    .verify(
                        &key_pair.public_key,
                        header,
                        ph,
                        &generators,
                        &revealed_messages
                    )
                    .expect(&format!(
                        "proof verification failed - {failure_debug_message}, \
                         revealed indices {revealed_indices:#?}"
                    )),
                true
            );
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<BTreeSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        &mut OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages.clone();
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<BTreeMap<usize, Message>>();

    assert_eq!(
        proof_all_revealed_messages
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages_same_but_shuffled_indices
            )
            .expect("proof-verification should not fail"),
        true
    );
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let generators = create_generators_helper(messages.len());
    let indices_all_hidden = BTreeSet::<usize>::new();
    let signature = Signature::new(
        &key_pair.secret_key,
        &key_pair.public_key,
        header,
        &generators,
        messages.clone(),
    )
    .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        &mut OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert_eq!(
        proof
            .verify(
                &key_pair.public_key,
                header,
                ph,
                &generators,
                &revealed_messages
            )
            .expect(&format!("proof verification failed ")),
        false
    );

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify(
            &PublicKey::default(),
            header,
            ph,
            &generators,
            &revealed_messages
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify(&pk, header, ph, &generators, &revealed_messages),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            Generators,
            BTreeMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert_eq!(
            proof
                .verify(&pk, header, ph, &generators, &revealed_messages)
                .expect(&format!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            false,
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_prime.to_affine().to_compressed().as_ref(),
        a_bar.to_affine().to_compressed().as_ref(),
        d.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        e_hat.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        r3_hat.0.to_bytes_be().as_ref(),
        s_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
