use super::{
    create_generators_helper,
    get_expected_signature,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURE,
    EXPECTED_SIGNATURES,
    EXPECTED_SIGNATURE_NO_HEADER,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFO,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::{
            bls12_381::{get_proof_size, PublicKey, SecretKey},
            bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        },
        core::{
            generator::memory_cached_generator::MemoryCachedGenerators,
            proof::Proof,
            signature::Signature,
            types::{Challenge, FiatShamirProof, Message, ProofMessage},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use ff::Field;
use group::{Curve, Group};
use rand::{prelude::SliceRandom, thread_rng, SeedableRng};
use rand_core::OsRng;
use std::collections::{BTreeMap, BTreeSet};

pub(crate) mod test_helper {
    use crate::bbs::{
        ciphersuites::bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        core::{
            generator::Generators,
            types::{Message, ProofMessage},
        },
    };

    use super::*;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
    ) -> (Vec<ProofMessage>, BTreeMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: BTreeMap<usize, Message> = BTreeMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    #[allow(clippy::too_many_arguments)]
    pub(crate) fn proof_gen<T, R, G>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &G,
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
        rng: R,
        failure_debug_message: &str,
    ) -> (Proof, BTreeMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
        G: Generators,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng::<
            T,
            R,
            G,
            Bls12381Shake256CipherSuiteParameter,
        >(
            pk,
            signature,
            header,
            ph,
            generators,
            proof_messages.as_slice(),
            rng,
        )
        .unwrap_or_else(|_| {
            panic!("proof generation failed - {failure_debug_message}")
        });

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let proof = Proof {
        m_hat_list: vec![
            FiatShamirProof(Scalar::zero()),
            FiatShamirProof(Scalar::one()),
        ],
        ..Default::default()
    };

    assert_eq!(format!("{:?}", proof), "Proof { A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, B_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), z_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, B_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), z^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let mut generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("signing failed");
    assert!(signature
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("verification failed"));

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        OsRng,
        "proof gen failed",
    );
    assert!(proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .expect("proof verification failed"));

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert!(proof_deserialized
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .expect("roundtrip deserialized proof verification failed"));
}

#[test]
fn proof_size() {
    assert_eq!(192, get_proof_size(0));
    assert_eq!(224, get_proof_size(1));
    assert_eq!(256, get_proof_size(2));
    assert_eq!(288, get_proof_size(3));
}

#[test]
fn gen_verify_different_key_pairs() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["b3c8fbe03ee8d368537257ffa02db4bd5e0b4144d150fb56adc68a9bd589dda2afe0a473e5c0dff04fa251241fc0f875998a50576163bdc0102b8d1dbeed2e0eee6aec0964f633b769c76c02f2d434eafe9ce04c949ef62200f69ef28abdc97365c5c676991cdbb906982aadcd14c877e2b9f19958659016486ccf8829010be230c98694afcedd60d05a6f5191508f0e0f7ae6768ab77d2328ce220c88216fb11c79918a1ab73854a2039c4e8cc7939f9ce9241afdd4a8edc95b50374f03e2b9696e71a9e13fc31b21a598e0209ea55302db20d3987943af14be38773c2c972e7355e9527c63ccd2789378d719b264485fdbde58fe3cc4f32a54e124e2b343cd360ebdd44c547d91eaf933d64516f9d9828767989b81804f280071fb3b314e0b5b7e0bcd44d7f6d18e0bf1ce9b4ad2a6189eb16cd552122f8e45df2b72722a9f597f58b35887aa3d0634d3f26a9ed9a5b27efd5aa400df58c59ce836a684315a35197af5b2d5fa86eb57db3a7d0ebfae03022251f078f8a0764a2c1050df288e", "86461891925a780d6b3b5ee4f4bac5ac21507ffc4fa080fc8f3e61c1d10d7c27b2f0f9212a37e2b46c63c4e53ff9ab89b086ee8c08f2b4e74966df294b8deb081e9b1b4632125a8e75056d212487a88f9f9d53df3b00646b062e3733b1fbf2012b25761c90129b702c0a6b8564f32d78ff6be752214b5ce3452e605b1c63211a6e9cfa9b5dd2492125d81cc8b7af62144f2aac5824a0f75f822444fd99ee9b400c532842778be0404437b3beff2306460854c64510e4060285d13b10307969c7201db099dd75540649a70446ef789d44c49e40d61080c074d00a9926afa4b8705412f586ae598a0a9fa5861ed928350f834678b66965e2d368b0a50ea6fd5ce668b456884c8cbad9237018c3599d1edc5bd0df119eaacfee26a29df210ef9f9c06939d3a45cc0b1b32c5dec109cf5876c200626411cda6f88d800514b3cbcb75152787af75b552e01792fa76b260f8c1774fd95280a3a4c7e280e3a81486c068", "b46cdc5fa05ef56c8970fad13a5fddc28560661f333cbd3d8119a40eec8562da79929ca42d15ef413be9cbb5b5cdfb65b630dafe5ecc879bfea92db704a18559e218dd51f23508ed9762f403cd06c18b89bfc48c87d6825aad2e1f11fa0d6dbd1d79de792f979477811d2a317b9dd206cd26ab7c4118bd47a2e8a592197d07d16f44f7cce95f4eb56a26cfe388ac58685a63c5cd117dee4271ce855b2307530c67eda1ac6027887553f2e2011560cc9006a87f97874b517a4eeff2a1033c5b0e3bf7656ef1ff197d82e9a43eb73cca8f2050d22b41a7394705f77aa0810278671240b2aa6eb2dca2b6e23d38b189ca0b47b7f1193962f62a175d267e64efc2836765769c954becd90ff8b260320b1bdab70c70659566043de9bcb480fdc7cf884749956acbad874a8c5a633f548d93781848fc05d8f638fba5d9020dbc930a19", "83a472a38dda7719d35baba6bc1b2d6fd3562f59e317abd0cbc271aba943119fba768285ddc31cf4201dbbe0eab09f978a8afb8c95508df185c72f3b3444490510adb9885d7b513f38b3a43a546d37cf95c34ad8e8b7a085f5e953d56d25e43a6409c7d62151d18202ab5e9bf183519c944e2111090d8291a9cf055df8f4ac671f46e5133e3caa4da03ff4337bd9c0e5f222d70f138c3e3e90928a3eec559a4a12ae548b6a4b66695fd0606f7517e5c0e80e5028da77fdf621b1857903497d172e0c7f87bea15fc6280607adff7349505498bf1cdb2f9a35893726c778b9607262ce44c8af78517e88fa4237cfebe6c851ba77ffa3d46b641ce38cd406f733ae2ff43bbf97f3ff78eadc6d32ef373bd59cf3e6b2c993436727899f07c5b82a96", "8d0401eb4f9e823a458c11c22706b883980977e18d0bcd3a76734fb58f44cd95d413bba74395cc632ed3438265ecb3dd97d537401165bc21efec44b911c8642d38da526ef6a8f0993fce01a746598376f2fa14cadb1616a935962220083031e62d12c374a1d9c7b15104dd74b72bc1ba1c92bbe5e24f2af9499ec90dc0b8924c0174a75342f7818fbb99bfaedb24115d0feeb57006c64e4b83a0ba1aecd5b4dc5f207ce8a9f3f2e7f7f737bc5fa5aff532a6fd226c1537cf4d0861830e34d5ba45fd70058afa551fceccd20575fd5495b0f2a461e9b81fe6de458ab26e787ea02618ef872de67fd1730214dda6816604cab6efb131bff2e45906a4fd4151121d", "89c6727d85d26d2fe16763f90d2fe55ebbcc4d6507e62a8804a8ae6f33e310d28751aa39ecb03bf3c9519be47647f98aa3383d60cd5ea333ccbb11c45274efb7580fcfadf9d4fe5d24afe3df11a508f340274b97b4c66d267b3edc5b685c57ab5f30eaf8076ce5315cb5e0a805cf26630c29d783284428c90dbb47cee28ec6033c15d7c53e051b364d46e9bdcff943cb759e50a2c5daa7315ebe0b427567db7c479ee09be447f471c8da35384772012f759546de3de639219e961d877f9a975c50e0d77b0783bed8d85d46588a2d32d023ff4c4707087545604781ed907213f0"],
        ["9493ab853b873504c3cde81e097452e34a5f67367c93e2b7194f830f34142c6aa3982041ac57d513319b7f80cc640e56b345a666a678871cec31cfb28118a7030d331ab5dde6909b71ba9c97125e2da57694b237469075e4164e286dc2bc3c7c5529078d6be1237b6f5561bc1efd03be71a34e0c1b01cefb6e2a3cc35e403d3c11f659cd9d95eb1725a8c0e271b03812c782076514e79a63fc5d930f3a2cf1923e76d14935e4b5052c5ddfb98cf2e4bba6e599706280d1fff4d762e7aabf0ed34c541bf1b3d52272daf99d9ae5bc6a7084079dd9d5a18b50ef9de23412a8991b14c4cc643824329a8a09dfa3f6dcb900fa38dc8c1066ec95df433e4c11280f1704efdc09f921314d35e93597ec4e2c85f36f0437ab44406330223f4faa595ac83400d4ecfa2cfef7f7aa2a0e047bc532638ac8bf3cc6dd0e36910a7a21349688439ed053774f45f9ff576ecfaba5f4f34ff9d34bf7026e7faff24eaffc00cf950a0d1f63035c9b40b206a3ba6a5e9e5e17b713966d2142da3eb5ffc1c0307ece", "895b4b5122cd71468303db255dcdf71ff260ae04d7b14ff052263f59382e0debc209e42ab9b011b2bc6ee41ce37766a7ac48bc825046c25a724742b0229415f756982c8cc5675884658239804e721bfbd6ffb2d3afa562357c5599ebd844b7d147c9d7f7b3a7e6e6744d709e249dcc0cd8092f50b6c1e00840fe9ac854ac04e66cbbab4bd256b1cdfe31bfad8fefe7dcf38cd2d8ee47a635032ff4b5ffa7ab2046103b40aebcf2e7ef989da0f766c7e46769658166d275560dc9dfef0628e77e3b1b878e53cf42e510691e3e7b7d99fa2a1810b068c00130722dfdece57391f230d19a77c23568e7f9a8da1ea8c1e0508577d0508c23967accf38f3ba5dd1e200a4d0438318e0231ab8560795f6e09efc7f478a6972ab118e26c49bf297513774dba82ae7e2231803231a82cd83ae25ce0ecfefd66fc446f4da9e7129ba25c3b5b681be4a5458424ff731dfc065733bd5b8e6ee8f55cef6d25991f00eb344ce6", "963c7d00f2e84b4ae71f3f6622ff997cf36971f6d633c77128d0caf1121a5003040ae30985249f21a38c9e9c81376633b86fe5f233c8c2c88be037a4666438d9b181fce99c167efbdcd0e83ee227711ce3ac68264a43f7fed0b0c9a1dc57fb225fd3b89f6cc850e3119e7e4d473c648ead5a8fb45f7f49b33c1c3e48192160da0bd70ba1100ecd272f4b52b60d39f4884d22483206cc27da01b0bcce655ab8435f1cb5800b759af939453648e24e29a0595afffe5d7f2b38df0b8fb3adc479c82ab3162dd1f7a3681fa151920f94ae60c5fc2bb4cd4ba02c7a4d5071621340341a9e655435bcb04cd620e1a050aca1e88a633bee3419ddeeabf772709b2107d92c191d8e51412c4523122336bba812933ac07a060237dacef18b0b58b6962c3b088783f7bd474d0fa953f56425be54b84d0de702bdc9f7b9cb62265bf2673f6d", "99d0800b64acec707a0eec2afe6b59205b3e5237a2c7882d5c0f47f8910885fd052bb64dee92318bc7ab375dd042019a8883f50d5ab4e3c7f55ea933c008f557e3b5cac87ce9048872ebe27ca98e0f69e2e83bf81f07551e42ea07ce33cebbb31fdf546f7571c8817a03205f2390dc9731b89a36b1e5f15406d947aa8b6efa422dd2894360baed1f4ad3ec454b8b955ba082549e9598e24b0c7e1b6edb7d3b3a15fc44cc086fc482d19c298946c15a55e4147fc8072cbdfb5a3bcf0dce304999733bc335b3efbba0d480e1c03912c9e57c65b1c9787fc580e4d0b6224519034d082267d2afb4cc934c2a29f24115e275225e2fad27a3789044d80102848e3b3c2cd6cdeae8ed721d344b70ec511766511be63122ef5c5b7e7fac6b32eabca9b5", "8f4e1bbc58adea3107b5fefa46978b8ee2b13f3d4765918112d945a295a9116ddd61b82df5f8fcf548dad991fcc4b850b592bae99b76d2268787000ab85d09f2144226229c1d50160fa3b8e96a8ee8095d0bb39a9a429440fc527fe6ebcdc283439ac3155ff63f7498bd67a0d3ea4517e6c15c13995dde68ad8c0e737f3754710e07ca656a91bfcaef33d731ce6a105b52b8fc9fa52f7b73e54abe5f55dd0ff6629351ea2fb66194925971dd3faca74642cd373725c5afa601032156f2939020726ae5da5bf36ccd734b81fab5a923f0632d9483159a456b4c0b00f70d671f37709b210bb9e8081f0fa9cbf5e7ad94333d5d85a844c9fd0515fa88db4caaaf18", "8747a5e11e6e0140136f2844b036db8aeab7e2974e00f8d25c650eda596beec1f63ff33dd6529d68cdeb71cf1571ca06b12d275ff750e81d396499a78a7bb9dfa8ad5d820354ae8287aba25748871341b5b1151743ce7da6dd8d049b6039d2bc71318ea5c333290121bcbacffd33b195281d7d2ba6316c3177d6b0eac5767c1f591f26c4445a6afb536e0eb2a59038ea30dee36eb8013bf8ed4ae99304501b684ff19c232fb6617a321d70106459ddd8ed4d0c1ae66a1e2c2f27dbc003cd949150e3961de6503813e7126b0bdca7ac2abced0fcdd7a964c05e5d63dde137f143"],
        ["950ad6ec8070edd8e0df80a2e7d769cc6031e228b9bafdcee77d8d0f63a2a3918005709b01c167d7bd1c697d90ced0d2ae1f15a984584115b1a49217c7a4110ede143022c2225eca5562b4dfd22cdf70e967fc9f68597441b3a3ca6cb3e426d4188d8a47251b471daf001f1326cfbebe77a3aa8ed8310e78cee2cb57da8f40232fb2aad270af6a3c6b1f012dcabaafbe27da34cdab5e6a8004c56f637550322262ed8319bd627c314d9c791c347bfa8aa1be696897b30746a2d5b12014162c5065d086b320610e0ed0fcd2c7ce23c9e59034b238ca77412cc4a76f483950795c402db4213e1d1408aa858e0a4fa7770900e3b6b98188637100027d8db7f3f0c0484759465670e5061634373825e7b100b1af5cc59140ca89bc859d43ef40d6251a2093223462ddab614d3c8e40af961dd4a1affa24540c1d9a4645b0cf0a8c9f49a503705726590857d19717400458dc8f1ed0b9d2d9072f9db476bb2e5bfebf4829eae20656a9f4f6de2815786ddbca8fb0ee975ec453ae5c3ebc2240b4ee1f", "89b37c8002a625c7ff57dcb3bdeed71618bc4c6136a96aaca24044ac36d4dc151e38137edad6492e6acea5dab7e25026966784ac1c4a66d6ca29235dfa5a84f0054d536aac27a9ea12079aab0035fb64cd9f24ed72a3f466be0fdb1b2f7a0e7467c7eaa7a0d3512e7a0093ed74cd6b2e94bd20d5c25de022c5f6e07b0ff4e72756904bd3321f091934aee11d505bc3ad9baba01c34374b74e9b430718c8bbca76e2516c53b8f536cd96170a25e5637803185806eb332db9d7e6983284b7eb18e5a494ba2d9ff00479c989002a1104c47ed5f9e2443130dc60a60d56792fa42bf22d55ef9a7348340096d9304e1f148902bfd9327fdcf332471b5b87aefa68f8e5e61d5b51bd7de96ac7f6c36433200ac0eeba4b50342a2cd714c4013e3fcead934da6e02c10f776616b4bd54ae77c750727c3b8caa316b7ba18eb09f7b75b7b2516f56ad8aa567cea20508f1124226f75ad66f7703ec8db34bd10bbb6b010d39", "b6917eef14a6503f4bab9e5afc29ff0613d9d21977513c8d50ef5222e740dd312599620f82459e0715e654a98ffc9020b184313d15ef00af168f2d7816968624dabfb524d7b91502e17549986651b2e80475984535d07c1def6f1d42945e8d3b52a20b0a168cfee48b12e01f8d1af4e4519b50a9b5c9542ff5255b4efc303df23e66cfeeecab6bfb1da09dc87996e6e3c328833ea1389fb8b53844ea5da8d0ad43e00273928d4804f6f48d5b98edc45efbe4a8d2c2351c83c679b104831ad3ae737c0d4100cafeb3da772f719d628a62f65ef87b51ebe35af0342f45e723d0d04b9c7a058783cc88b9c27a56c3cf226b23f364971d820395e04fccd81504bdc959f028659df21e829ca7adb0bbfc3b42a1330eb5e44db093783a0c242fe02b5542f686671fd5b75093781742781e03d9d82e2e1d76ac0a93b38c9345dc3f5fb4", "b4504634c77dfe3ecc88c812170201698ea6f51684d797da6b5502bbc63f43bef6b86c6090e1ef7499e054b67b4b12dd99465fe19969275f29b15a5a4f00173e5f73be18f106fe8a2f726f828a2939e9ddcccf5e259719418f608e9d661b05474b243a0d628fabeab2ac54a190106d2c61be592fac0537c292e63493f0ac611f0c9ee2f1b827acf1d76b9c58b2749722d771c56857033440499eb5c4798ea2603178d92b067e35b8ed83b26c8f13ff3f0c8d50dbb9e2b7b109a635d662379f922175c02bafe6e118db6f96b7e65e6c9fe3a755121e9888ec191785e73320542a0795f558b5dd8a852be1d4b874b8875dd516bc522ce5227a44b4b711ff82982b6826f4a624385cbfbbdc59ba959264ccb1d48af319bfd55bab443f96219af65c", "8bc9f90cf66d25d8334017330ec9ccf675b8468eacb170782f955a9c42075f1fa29dc0ab93d7c3b1649e148ca6bc40fd980a05e536e273d2940f10fbe8326ab7cbb1f6e9b9b8daceb701e6420dcd287c4d50aa8b8de0f757f1fae7ca50d34f4400989786881bbe320eff05d6614772c611eb317fd9e816ca47a6ad0c5af9917b12b9aff445862233b19225d0bf4bed28442bc5c18eccc32a5ed201156d8634b05873cc9cfe1ff49af1f252065021abe6d44b5ba53eb1607958f30ac8801b18253359258d3bfbdb11128df9dcbba6ab579da5f6907e47c212738557c89f48415e3f2d745c6b8b28c1f9a2b1082533a0eef7111f7870b20ca31aab025701b124d3", "aa25cbe577eea4d4d7bf7c782604705e0b225dad9e1a1dbbdb03f929e721b39c38bfcf125c3d503b402b8b4d21754d348f58bca6766cf6e28e37ce74922fd10f73f89c9eb65f23906f9f03937a2bbcd549fe3836c830a01b28220427ab37422b3d622f347670079307313abab5ef973535cea1752887b09fa199e584fadb6e4b6529cde2dabe81000933285d5bb5f6595e3bede7428609b97d1dac514912ecc010a07dbfb70ee872ef744e0c8202bb023b7c3de429132bcb33f9df224f3c2ace5a9e78f27a058afdd712fbf907367a9fb54c2a50223fc4c1b2ad681519532c36"],
        ["855b1d4ca55bf0215d87689512998f080beb9c0f45a8f25018e2f1652506d9c2cbd03f5075d35dba64cf1b68ab6ecbbda7acfb3514d78aef4f1d0a9e7c1d5f896c1c4033ce4f9370ebba12aec6c5fc0c219f325f5def30141a06b952adc11ec53bc7eed3a8ed33835a353c060ff5ce993d76ef14ed8213db407ad944aa8fbf084a9e9c0424585b9fd6a62e1ae4f192a500ae13824701238622b6b43e355d8b256479c853e8de9b2871cf0ca771565933056781ca7032ef9d91c33152d52a59136882cbf3bee3a332234dd3da8ac3e842c29ec5bd71f4b2653984fbf2d15fb0870dca68e58e3fba61d93fe8f3d244b799f812190a9036679d12a3cd056d5b372b0a2598915b2394594759d595d2ee246b299b664adbcb9eff82edef47cce2575445d50af072565dacee4b515ebeb64dcb6112ef4eb68f17ba6357c334c736efea020e343beefa426d54f6e19f638024945fb9fbb755f84806f37c6e2f15cf167b2bbf1b5483b2b9b83faca1aafe682329130926ee5ecfbb0045620a5f335510f6", "8f97b65731441359b56aed63f181a0784ac80c0a9772a33c6ce67900c7c224cab3b741d19d32b510388ee68579a8c252b62e8cea0979dc4062a49e4d96c5e20f930c1023f4f14a3b51b5093358fac4572004de835bb500c92c4ccf6c959345395485c7c3f1548eddf911fbf0830a1662d404c070e959451fe362550113b79299712d94493a724835d3c97d64580ddcd0b3614d6e61c3d4f2f5e1eb3c7d18912908c260555db07eea25eddb9f08398626a4fa3fe6f259f0354663ccdd93d444173f498f9746340870fd4c72a9ebb9452da4c1e28b3d3fc93a1aa6244346c4aa8438acdc214265123458e52e6ae13e9a436888f6402a346512dcd4b4d2936de55b713922c9dc0536dac71b5ae336b6527cc4de08d71ac9781e1c6ca6419fbc24f63e6eb7c547c9a5b326b6a523a3d59892e6abdcf522c9ca379f909cb68db991d06678665bd221e1941e17fd9ac3dc4d6779febaf926504bcc3c10749dbc15e3f9", "a4513d106de219ea5f300fac8ae30a815bdde2f076662ba04bf3d3dc8149e3991cb788cfd5940fd2d1c329d8d70d5c75b1f215f155856c8f596ed104d8cf8dd5d389a83caea2a0520065fc63dded880096579c3ccf24531819769e045a9de18f567811c6bdc42ca7f34e774c1c32caef8135389af906b0a533a54b2be1cd38d324c1d79d07d02db2661425732f6f304a370713b26980a545d7fcbcd7ddfc2de559a28505f8a834bb653a922f1564231a1bc5123a8c6240be2251a0a6258ce59a23f38f782a9d1a64c84259c86e85e63c562ce98e2b1917dedbf6e7e63bf2bd0b0b9747e2066e0837d51eee7312c132552909ff24a13c8d271757e4c053e18af81e16ae16a5fd41570cd9b055416bc1025b820e4fe99ad1166ae95e98684ff1c3588c9b1991d1bd7ef97dd9dce57d701d19e2e85ba3ffe9fba8a27adcc4364ea6", "ad2a473cf962b0c996cf085b9a9a74c9484e90b08aa3eef2186076fc27308f838fe0b5ef6f36cf3515785a0806fd42e885980d8ad940a69600e23cac52617e7682c2207f60589c1fbd6d6895d88147d92788d492fa4e75e336071caabf43537a4bff5fa7fc928457ea3e0b3caec7a25eb2162a8ff5b3b651c95f8a25a12c51363246867cc7c26edc4da7302bc2f983dcf2de6a6dbfd17b153b7ca546b0827afb2000e0988b59cd2e26e83ca7a06893b62733e0a1856a1aa8b76e14c5a50082be02cb2e897d453f63cd687f0e83ea4fbe2b363e3d0190a5b7cdb1ce3cffc3ae035e14d45e3900be47b35ed6fcfd5b98d789938530488b27cd96ab243b81d21f835e8567bb1a03189b944140d9fd104a36ec2de67928160b56f4337ac65f4837da", "b49f7bb28d977850d940bdd80878cd7622150ac91ee90282698d6a426135eaf7be473b02ca5a8b0ca58986f6fa9f67fea8495ca6333bd3936f443adc24c95338642c89474eaa5890786a2003407ba6299a0de87c3a7ae840234c6eb9b53378c824ea2c10a2cfabdac1edb9598d2730f8f25e94e89c55c1a5ca3aee3b9339f02c60d4dd024e684104f2681e99a46cf1934e9141954d2da52c2267cdd341c820bb467efda68f540fc95e887f9cd8301996fdf16c5bd6422a9c8b3b65421a9fc5742e9dda8ad33332aa6601c79da009c371c1eec0847255271e48a5f2b321265eb5019811118adf93eb59400928c2ee9eced4719f02f6fcda66af9cfd72b6121940", "a31222486bacdea8a4f59fe5c4129cf48d9f4526d99db53397061c858c11a6a30dd7d724e4833df80d25da47a7b8392da831e2845d042cad74caee9ba9824b45c8aad597999d1a857df69d8493ff100bdc95bab392a872096a56fea31a7c618446b90fcd756f90894e394da4661195b2f9b2f60baac8bdcb4aac30c2c843cdef1d4f06b16485f9c1d21870a7828c9b8b9600137a01a17d153d69e4c020583ebb4f166e87366403d6f73022b942611adc441659d19831026efdbbdf332f6883293f4a7b71312116c5f29fbab35a9d760b92fe432e9750ddc1fa75c277f44b9aa6"],
        ["b7661b012953899ac084c38796e9c229ee9d489d6420110e6a6ccb5ba2a774641267f8628584783a7d8b33dec822df33a769092c38920b25bb14f7ea93c503f3764e5fdf458cd21d4353f45adf742fedd52a3097b8ac9877537b723eb54945ce476aa6099598e34768a7a8ab7e99cfcdde7e19ddba4bba5f997488d848c9bd994bd0d6a994444c25604d17d6567af68342569fac8d31276807617afcf453080c37755531d442cb7569b62bedeb19223ba7bc6276a6676134db76542db694ff3c20f113d4f009f422ae37d03b795f8c55e36c980dcc29a90a424079837aadad0540ded4ede71ad283a25c5e6d8f7ed33d6ebb5213341ab8e27ac4acc9725748044a3452391daad7f0a854a02a306dfe94afd770cebce5806df4e9f8a33fc9575933e980fcd64660534a98d81a4c666f7755047f82c2e232b97901d166340dcf9521ca507cc5d4eb54174eb9cf587411b90d73044bb457862e95c54c2c786360920aa932c140aa821e4528eea8f27bda37911b49fbe7c72dd01087f0b2ae7fa91f", "b43d04ff318577e83937c290d57c04c258454e55562cf85a7e00704190e50f11f4a2a18a09849d883fc2ca9da537575cad6b86835ca990982183f5255cd6c5eb5d21851c810f6d16ae7e12f0d7f89d1b1ab2f8f02883cf6968c046d265f9d72441c4f216b44bc05e2d584963ff01ecc58688f6d6afa6cd353fa2da95f3a8c4a95f675f07e14a1fa365fa8fabfeda050ba69529fb826eacc33eaf13255f36420a399d1c7ecb77114847322692dd480f85895f107b2ae173ea658883cc4ee36d99736dce356f3a9d6fa138e9cf3f28fa2b3ede475bd064f59d3f1d97813d89d533034c2c134702a5cca566f14f459affcf70dc73a30f18b9ff946097a8fa1c109c717ae6896cce58034077fc03799e0cbb3e917fd4f337cf9952ecc2af161ea426258cd610c48f3f7169cc0d88b78b7058b4071f8429b68310e9c33eb37b7f576d5f4bcc77f827f128b0466deda00bcdd838492d0040546ee52abfcb28240aa557", "adeda2eca27e4b2451bcc59973f9b5f602c2358f88c39231f41a63f7a37bef89b97f09a45f267a42ba007aed2d23a99089651d4115a1e83904334fdf5800cd950df7558e8dc1e34fe883bd9ef5519f4299cc1b0ab1fe1494739f04c111801de42d57d0bb249db8bbbfb6509ed7d8750b0b79d5577bcc889d3bf693d8c543e1eb6cddf9668417231fe4400f41622a321bfc18729f0fff3abf5504c114a137c8ff3d932aa6a74935e2795d07877eda2898d7e1ae798dacb7a94804d8325cb749082054946d8cd437c8324b5f27be3cfe1669d75015d542ebbf40a1f3facbe4ae606a838e3195a9f6198df3f377f62a2537aab181233ec3441b0c88a79926f549ba2d53d74884afc7a186991ec3bf43879a02adf8f2dcb91a3d09fe278eb64eb881360750be88ba176b7c2b3a771569b42e4926403c46c30fab9137d1df392b3b90", "aa430a3253c679608467d3954482b1508ea3831559f82ef323d2dc77aa2dabe5b7e72facf4b2a745d6daf6e9df0a464b91e38a6d54e4f2b0af2958efd61de9455f6f8173a5a0ee926bcdbe4cf8c2c3c34776a99e5331a33f9480b65770e034745a47d99789d703cb0147325911bffaa99ba9b062d68af80095b4a52e14eee4016e4ca0790037ac2cf68c1fa0bcb57b44b95c79c80c9ada8e534bf75957caaa1e03faba2cf77d8eafa26a6c761009316c8b6b00431dc355d7f0dc6f39001edb7428360c992c62bc88ccdedce975c7727bd951d1d87089e2a365134e70212b8e7302e3af229809356783eb64a8d90ddbd18e23cf0b57b4f7cfa5fd27a0dda730e62e640605a5088219fde46b66762672e90886f5f97f11a1c3579d37da599bd0c0", "8b0cc143f15b46aa2aebd895333967001d71b55f9ad52f7d85b88d5b13e68183969271658afed6fbddc08d332dde1e29a9012df27e27c080dfdc90ef6691e7f63edf6730ebb2fbc245fc74f0fe55a929f946d76b3db487d447a902812f339ef349b991f4c6211eaf7d8fbecd215f5ea665896002d81a3d1f9b01926c1520aadd5a9ef0bb7b1ed09106ed65e313b58df64183e1f8752a7661a0b2820fa6adbdae6635f28093cd125a7feb65541423563a293c6286c4c45e10b5d7613aebfd4d9b528f789e8f442296be5f0f27cbe7f4c49b4f03ac371b0b08b5ab6c5111c4f4530fab241348aa3f674e12df9dead756a8f6e7dae312680a1cee4a4218fdaf4cbb", "b85f0dcbbcbc0b049f7d0cb7923078de138d506a06ef5a456d737ef9fe5b57729d80d5a287f8a41fcf46236b2d37006eac9669a752f3f2101bee099edc79f3af3c73ccecaaa87988e8399efa97dd2e57d6687f043e554d05f5b519225b7e0a0d0894fa09614a118cb6da365ba4e370f9e9682ea41f28d45ff189df19bf59d39109344891df425b77996874ede065b4dbefa1c5e751ac5e2aac32e2e2018e855a6de95111634e39d8c91e288ad5e7335aa0ff440904a499e92cc713a011e3ed305c07d055c1c9e99bd10b15a186bfe3fbaf8f50959ae77e275b951a4b672c0319"],
        ["afd0b55d16ae0bedd5828d004c124c7d70773b1cb979a211321c129976baad381258ae2413a50bea659343f01d2628b18e2c70ec2147de410ce825f62fa2ce6f6bfe254c64b60a6b2366e9494da48e45eebd8378172260ce93a3e22f3e9c7a044afb5053e123bfeaea52c61da3c92b72bd2c9fa8813ab6bd36a8fddb6c9c5b140bda257030859fef9d259974dbb01a8c29b780f18d6ee8d21498d75987af4b62687486c0726492d69d068ecb80095f894b07cd371bf3c5232eb06bb23ced88e703ca1b2834fcf7f9da197eea5fc0234cb5f001c5f7f8f7fa845cff460b67bbeb237128c4677008155c6610810e6c0280c4dca3cd580bb9087a69a523063da90115b887eaef97fbb0c788d6718c8a08c2ab18b6966f8fc1b0aef058e47ef59daa2d34b649812298bbff6cb6ed6dbfe056396393aae6d4c9fef01a3f538e464dbd6c3c0b87c5f642143b388c1d4acc69cf1651aa01f2641bbd4aa3f4c8b9e44f9a6de5c3b5f1d3a75f9ad443aba0d13e1a28865a3a1fb99ceaddc754a7ec5e4f63", "836c10de00028575f282b29e35ae33da19d8850d620bc140b4f7e0b587afebc752abf5780a77a25bd7481324c00d772da836430a5037bdd5d677ee7390e58e03f171c3eb8ce12db0d8cd42d4f4fb05b723c5063c30224f912a99c9d7b96d22491a1318222e4aaeabed1aabdd9bd3c2829653340a515a77c0c94e9369cf7bce091c8b767e25ff43fcd669c08fc80049428938bb3b359908c9def9427d03ee498934d6d166d758c568083054f2fb2c570793aabd12f6faccd180bef373985579dd725c949b716454b0ce57f710a0e657cba7f06aa5e41ca68df27831fee03d18e230ef3e6b688d0f4805017811bcf98e05d1f7bf2051909ba94305432b6b1593d538beac754e406f018be56c5c9561e4c820226b63b79abcd403bbd821f4a13dab1a8f7fded17dffd456e837dbca2e972b84727d46245e47e53db982888d84f1346562abeded142ba35caeba4e688dae09995ce7a49f20e13f3d7c2301082dbc9f", "ab754334bf54426b17f41b7cdec69b5655a3b372cfadf48d83eee75101c84589969811d6ad2cc15eb207e872a8e57b3a858a6224c8616435f1818e28a67ce9245304ce15391af522fd6b5102fc9287d1e50a4d74832fbc08a30c773260d357761480c99c4056e93916aa9dc434835a7a5bcb8873e7411a765564da976ad6dde237255408ab19cf6b46229070fd8a679cbae190fd4c05a3fb6a7c3d2e930ec8d210ab722463c78b0e6c162fd427fc2c47288a6e8245df366219988e916f5bac981e64d0699ae06081f3be6ab7fef47ba4f6477ec9e7c0503c592f13aa5f6cd3fe18afb3ff90a35f92fca1ca7c59a9129bd40bd44c5aa777f67e6440bedff9045b49a0abfdc291ac200308fb6db1ef1e3a579773d14f592133b6167719199dadb46ecfa07e4f355f05a87aafa0f457873fbe1a619587d413aca609dd41d88cd4c1", "b6d3da01ba6cae7d8540a3d20a48611ea3e8d5b9b7950181863b82a266e1ca2d16ac986a1f5f2065c4d167e90eb25aaba171162977ac790b3c827babb7d6bc0e2f4eee2d00aa1f12dbf3996b47fe487fda35864a5fa58965f9dd27335e49b0053f10304784898575d498acce735639b0c938ff21e9fb4210e3f6057c519fa6ae4aa5269f77ad4fd6bd8ec04f4ed3d533b55aeef543553f7f5fc61e6df8001dac7189f52dd197ee0d47641619eb07bb36902c75bd882387df57f7129c9a6213204de5c81d08a8e9566df88217af38777db2bc40bf9a56f7ca9ecbaef2962d974c592b3852bc4c024f9bcbb90cd092dd4c78561e9a4bec3306fd1bc9b5fd9434a53c00dca0cfc9d0e8cb627b9feedf3841c069c0d50ab740fc7ad75830a88217c5", "aeb8eabdc3316799307855b970fc38854cd9b2c1a1b846493479c603135ecdbebe1055eaa06a9a0630740e6a27c5ee85b4a293ef3a350b6bfe042fbe2adde745e1da6a97e2eac11f1d1dbe134fe06173e0df3fa6deea14a32d33e7f22e45942b427a0d19aa410c7238ba7b99e0eb7475bfb22ec3669ce99e0f886d2d485fce64465119377461d2acd3b44e24039782d6ebe6b0d61a0d449ea5bb97e33c7f198f569aefac5298d472c75d30234b43fd9f657417e593ce2adbf2e61ae7cce603e41b139049da7a661881b256220f972fe3c44e112bec8c6475fe945004726b37c16b601e9195482ff761c887ee1711ccdd3ae7333e9a92c7c9af526b8af172d503", "aa7290f3fc50e4cc543cfd6aae2b7ee86431eb1c0654d82f9202c1321f38d866d4e0e430d106c88b4f429b49a3acc64a965b63c75a035cc81489de272485b270447563b6042d821407d81d04c4c094b58bbe03a7cffaac0caa03087ddda6748f5915b72679f0d9c5a28cd2ecbe10747055196e3296d018608f76d17caef86a23499dfadf87b91bfd3646c3086c357524adf811b7d912c78660d4bc72e4c7d01052bae59f2acbdf1dc2468a86b7f99c8a52b9828b895896ab1290aecf7e236a3e17cb2d9ca6bc650dbb70301a57eec71fce009b4c6f4e0fac5398a4671574377b"],
        ["a856ebf4c5c7d7678ebf1a756d7d74a4e3cc48fb3bfe9001d9d56a4f954e63999755b2e47025b647df374ef7766b7d0fb1a982a5030aab7f49c74ceeed94b967aeff2aeb8c0b681c6672e17307d080e80bc6c3c38b17cb70c43bddf90282cdc07096c7d3f873c64ca33821021baaa0f1f97861bfa48de94a25bfba716020d50450713442973ab44082bde31a36f26eaaf00170964079b0c51d6bbe244d22b1033fca6e8af3f6604453f65ccc3e3f011ccfaea36feb8c9b1e57799b601d7caffb4266e06e6f314d81dfd8f1ae02599ff06506a11f319e2214b0bb94816ed3da3222af5d0bb0f7cf63f68a7b80caed849d6d8b86d53bb7bebdc1533995fee9595e2b54744ad5bb2a0caed26ff77d3ec89060fee45a5f8e16165f5b1eb8fd1cc0d36b1f2da3a044b67091652f505f07ce99f0bc9b1ed193f21465de832967caa1925bebf8a94ac386592adb30aed6ac05e630a974537b217c4554cd3bf787bc24894d5c56ff967d708784dea8c9e0188af1949b5be8933a17527734f0f8b3af6e4e", "83aceb1a2d957c6f76977ed76bbaf5d5fd9863a3ece3a4524c873afd4378bb405cd6038196a76ee1c312195b1680047f95a4990247fb8fb71c2f3279eeff660411d290e5025a77cac22730cdcb24c8e24c4f6803ac062bab5a216a89e55ebf8d14910677ad035e115ca5bcee6960278a265c5d6b5f9afbdd1f31f98b063ba408505eb981b30a68ad6a447ba55bac0bac512347ff20ea4932a7335e169a571be0554f6c6184aae28d7c2c698b25449c02a66c99786b9a44654d32c58f8fea0b9f1ed42b2c90f5717fe1a7a11c4982f6cf88dc8191af1ea6cb1821d5c2151c4faa07395ff63a72f47d9ed4470f6b13aa8a886927d5c551ae89f3908ec7d4a2462b549a468e430d8483212d14ce3c46be0c083daaf93e3e76d4dc3963f56c8f3ed71b189a229ee66d21121f9105d34689a582698785c211ea617a9d7ae1b9bce0440724ede0f5db1c670c4ec9e1173564af6a964a1f778b554f6cac38d721c77e1b", "936f76f270d3880722d43cb1ada56c1010241e5fd8d6a225956d9724a992d6ffe255c719dc4ac4656ded0343631ce52fa396a854803bc2904f5b38a17e3bd6b7af6236a5325d69b10b8528967604ee85320babe4700e2414bd7516c5d24ad68f4c1067c8bf4def0ac4a01aee3f53349cf7561a7825837b192bc0f93ed65d735e1d2760b8d8c83e2bf205bc237545737f25b7e82d21307762f028df7a28616d9f233f5abffb1def1001a0239058c4ad6c67cadc4b2b99cb5dc46775b5c0ab635f3435ac2be3735acf96969a670c22d2ff94b5f95529cab3c28535a875682532fb6e7f207f92a3b47f965477c4a656aa2bab42056de5fdb7091618b0b9013b4f8d3b63ab849fa496e63515ddcb8ba1033585cc224881f8b95ad928c749acb37f3563c3ab927fd1fbdb3a6590cad83056975705f473c1e5ddf724cc957448fd0ebe", "8ba81077bf3ffdc011a66240bdfb951a8614052050ee9f4b148dec7d7ef5890b2e5af82b03ade16267c4f94272942577840d53a4d29d9ddaacc7f2490ffd97115537bc70729961ff5dfbdb122ac18f79a7b36e106dab200e62ef16157af05e380debfa65c434cd13ca93118d1d4cae6aefc41302be2c3158e3729d13425f0dc62d16ceaa71c45847d8ecd6019fe49457aeb9f443ef7341f01a3a998f53e11ff34c4a97232f4ce83fb3d51e261fbad8aadc02ed679b288fab251afc1b50d344c108055c7ac348542729e150484b8c257c6d231a93b1f3ee568101936c295eac7f6fd3cad9587b119c1133c48b888b786c9c55edd62f0df5648c6133d7f102598a41629191d82ebcee7b9799d4621f1463fca87c9de0b45a0bc18c8ba87ba866e5", "ac6abc6fe494293e54b2ba7c6367bb1113c94b0cb756f5f4fdfea148b2e4b2274b8fccabe9d1802dda9090d5e74397ec9321d3f7b9e0f2eec4968ab657e83f3f0d0bf8c64764e2755ad4060e09f640195643d19c3891f8d771cfea87887fdbe510a9e1c66d99b0519bf1e1dcd2ed910c0cf188f782579819af41c485cc66e2bf04bb22002a047374ab0374380c74e70a4537636b46fd492310776a24da2ec944513274504cf2f6cf710c2444dab848ecbbe9de1fb3e47ac8c6383d0d684671c904635eb67bb015db2d45f787878a0567205cc43c6ca6b08c4a6dc4b3a530fc6014c5658dc8d93ec6e4a877097cba2f512505be0ff639a97d5fe4f5404c898c87", "99bc2d508bf0dd2837660322c31141575997e62ff8fa9690f9cd041457c3a3d8acb2efbe7fd2bf67284d0677d81deaf0ac9d2ec77dbbfad98b7230c0edc96d42e6336467170a8773e453e58ad4d384d38d526d0ee8fe0e4ed4ad736616318aa42adcab89e792927fafcc82f6e6f4cf8bd456d372ffcead1bae72ded194e77d563757e42289ff307a976c5f153b4cb0948c1ceb5e32c8eef337b8828d05b743bc2cac2e9b75a906c118f83edd7622ffbde6430c7281d36754dc2aff8f066cd3170fd4794852dd77da78782123062589ff5c23a8f44e1b20b06076a9d73cec0367"]
    ];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFOS[i])
                .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = get_expected_signature(EXPECTED_SIGNATURES[i]);
        assert!(signature
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                &generators,
                &messages
            )
            .unwrap());

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng::<
                _,
                _,
                _,
                Bls12381Shake256CipherSuiteParameter,
            >(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = BTreeMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_msgs,
                    None
                )
                .expect("proof verification failed"));
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        // println!("{:?},", proof_values);
    }
}

// Test no header and no presentation header proof
#[test]
fn no_presentation_header_proof() {
    let mut rng = MockRng::from_seed([1u8; 16]);

    let pk = PublicKey::from(
        &SecretKey::new(TEST_KEY_GEN_IKM, TEST_KEY_INFO)
            .expect("secret key generation failed"),
    );

    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proof_with_header = ["aa29329c6d70d762bbb403d22b0685c7fed05d87135b599ce2d0ed672f9c6e1e87f8fcd0746628a80af54e602aed8def967339dfec2eced337883c3698b993d8d569ef8d906f8ce64a77c6b5fb3053894ffb26454751f57298a809cfe8f47f216b01cf153d468b84f25be353ff9217d2749d5ed78b5a487224f553634228719b30bc7d9d9888d2e0afc544061fe88030d49223c652216d30a442f83255b79f1801f14191417815adf995f4ec29a867ce5973115e49e732cef47cbe4a77ac126d5df98541c060b20cfa8e23b7373392cc8691d1eaea7189a57ed6af2aeb7c2c4b4cf77cd5712acf2836fac2003eb889275b8ce5ec83dbb6e13a0946f0984bf8272b2d9064e4f9151df2f0c8c039f3669a6823cebf750ad0e2db78605948dcd88724e535b52e3803d663db6b933b34411dfc00a5604b4f27dbc817f187a2b90df06b62476200475f61982d8e60a28ae13b19fa379a7eceda7750f777ee45d6f74d53619148cb6b75e55d3aaa05d8d5f6828af847ab131df32ac38f34f30d20e9fa", "8be433d742f749504ab28ebbecfc32ab977f5b7e01f0c8fb19012543c491c683e1aa55be5adecf1724073128369f793c99f32c38056383c4889654128416b919c6ed1db38e6f67b2b0d20c13fdac05f4514ec29824939b163b6a56cfbb7a7af45b19892d9ab26f1a605aba0217cb729e82d9cc534ece30e4bcee90010c59df330b7e874fa8e588c65d28933504d4ca102510b656aaed1d1655ba624427690f3120103058a97c9465ec8dc73a20665ab098817b5dd7996554bf980f199a72987a70222ba698e1cf75131abeb8f95037c112465e8a4dc447a8974ae543cdda4fd523800599ee1bf938415ad31143c45cba4c6613a62595d4537a7dd627418abe0b00b694a322fa64ab470e3cb15fa638c627f4388172f64c9e7e941f28e562fc750f133bf405a9bc78c29722037d481f8983da47300acb1fa183a24f30311bfbd971d5f494f105891cbabdaed81015bf16dfe9ac86e80387e41ebe4b2a1c71b897", "b2f9e8084a5c7c103296d2298a87fd92d3fb00b4b0aca12ccbcf5f900aabb211407b484fdb08ceb1c17a49dd78b85bcc84c9bb3099cfde942e75899ff9d620efba5334755a4e0ab425917698fb372044d29815f9f56b6717f7592de619712dde37ecde8891d4849f061b7b644a6d0fdc68a92fb1edbb5e88e6eef12422fcc181575130cbb7426faa73e74ad130030501dfbc4f04529a94a74c05e1d3d67f15d250e111c2715c9f2d87858b959af8be2dd82f7e875fd98147a052420718fe29f8638e071faba1bc7ef697cc047235ab7c26ae2cc5b78aff669c0146c503b95abc63536ece3d58f7d1bfa1e2c9093c5a199e7e51d5ada7c06eb87bd58fe1d7698f01d81fbd1460c2acd244faa975d4ce2b2ee599a4c82afd4069f263d0c83f6e2e2fbef73731573589656d43e01125e142e13a4a69e17d9104db0c23afc5886cda", "94a0c9c5e29afd90eb2eb2a39b6f16b3118623788a5fa4be867162321bcad4fc94d5f53b75879433ae364284d6ffb83aa0d92349e07135ade3e57a5c3a4ff3ccbd19a7469267a170fd47b4d0bc998b38d7ec26cef3eb671e32f654bf09e17c9b0bb3dc992f2a228c203a579a12a7246cec99a13f6e5499f9cfd06cb54dd9caed660f03c9cbee9b85abc5b0da5fe873ef5e844a0018563a1508f7d3cd2e5f074a22f613f0b9d6a2cf5e22a7d3b57df69da3d855c2eabece8eca047db7ca8283e358eecc4c7842f5038d56516586c79938b614dedc1b3a13bf27a160e5beba0c1d412dfe343c19755eec22ee1cb193c0f6e6de3beb0d72d8546e8fec571f28d70642da3f936027681237a73d0ea8420529eae726105ff4c4ec3dcb50b90f89fbbb", "a7c840ecae9ce09182b3b1a383b26aba2306c9dd966b2cff91dc29e2b11b85a0cd19fc7f59e78ed183e3d11a7d37a601b2b52fb4ea3855afd4e73bce0d2146291293f4a4320698f86b9ba631de10e30a235e96b5615ecdf86f471537013bff402d1e3e251c2b5661e1aacfdec4e4755d46c41ce073cea552da14343b99e85f220e8bae59c26aa779a2edbd6de572da0a84086d54d9fa9842a4f26741a35eec6c19ed6eb2dfbf242f415bdf3342942eed2fd27a5eaabd726368fde87572edb0e44c7794f22d95508cd825cf9d3f3bcd4c5ee36d5f810ce220cefdcd0f3bba7b645f88661519e13cbac9b6a82c01ea183102e0ca2d46bc3cd615d222e610dc75c9", "95829604fa4ae17e53b87187035615e24d5c322226aed38909125e923e0ba6155ec1e5235886677bee3978b228f3686794ac8f624112d8181562179fb47b6e0b346ff618bdb0610b0704d1b3c4046baf56a774e810d4af9aa43fb17a7431b9096e8d17cbadaea04a75a03dbf574dd305c7c5a75016083058f0f270342044e91e0acc71e5d8818433b0a25b01f786b68ace6a05d8375d314cc422baa1aa9f96396f1faf1a9a09afa05670c2383b536b7b42c662f6cdfddd86a51ced14f9a99dbb4c1d33f4190d1a70bf657970ba3d0865c445401a502b3813f0b5ee2b7a55a7d0"];
    let expected_proof_no_header = ["a4e8ff26f9fcf288ab562a7be0c62afd635a7e6968193326526bd072ec05557b71e1f6b8f236d51b186534c3b7fe614c8c95dd1560fbbfdcc8e86521a34c63cf97f6e9eeb7f50c42fe39e33d31501dd7a62a0f5ddcd2942ca4f264d669009ea2676a9524e8fad80c41c8882af7230fd69131316d13dd403081a2295fc7491c91428957d55cedc5fdfd410929a218b2dd0b0a671e04ee6874725188ddf818c1fc15af090659f7db40af10cace62fc6ab32d53bff92df93bf962423ab4d8f8e4ed2cd31b40e5ed83a0e99966828b36ecc2fd2297d19d85a0656fe95c5fbc60dee12710201484725f4ab45f485ee513deea73a93b69749595a29a876ec91c36f95f6d590d494f1597dfe1c788294791db119279cb4e2c343ab06fbe496bad7c4f735e04d017caf6d75036e803a04c8b19e05b079e2bde3f3c84f4c4a39dcd1889c13b63e402cf7095518d68a3fb1e3d0676ed281017eadfe02ef2e3c4a85218e31041e38f1c1496e85371a98b09a0c113b10b8f8850d72606dffbb9b8095ed2587a", "8f3d5c15bfc3563223cce300edd058ec85ff3bddd2f3d037ffada89812ec07afdcba05831ad68800177acbbec86f00c4ae918e5e2e58f34bc1d37a6165361cdbf9195cec862119c764ac5f6a400d7719e02ae1deab35167451e66fea60d30b033ab4175e19a14f20fe7c7fe8cfa160d7ef7314d7d933db0d2f2d6e49a3cb837b3979ac0d1eb4a985f898c8c500430088045b1fcfc444472e01bc054c4e066fa955131d91dc0df3b7fb6506d35fa1e6bb2648e6412a15352dc7f3472a5b1e4bfe3964c6a16d3477fc5b3fcc0a35cd6581365321e361fba9eb90942c357815fc773869ac518a98aec4be57550be0d986d8354689aa1f29319829b52fa3a09966305ad346e3ed4c4d9f8b653fa6b220a8d6fbdf04255c270691d5df047858ac5a891690d543ce572fe90f0cf979c14bbef92ed57c094d3f6baff44d9f6dd8488b372fa305d1ed84fad003176837ce4bf3a141332930f8f95152076f1cabbc0b4c12", "92e3473cba389c87a50232fd5a5617caeef482d320242d7d1e405803054cdcea680b4414de675b32eb91d8d61d7349878afa1a4ede02f98533d4117a356eb402f6e7d4077239b153f6d8ca67d9e02fd35888753398fcc94fa439db38ac2d484c1825ff123a64e34d442cb23996d4aa485f75178403a44410129a9a6a2d973c124a6926952974192f7d5afe50d2cd6f99048a9129e938bf2e59acc804b18ce3c61a4a8a218f408ae7b0f9b02412c07e290471651470638c70a91d16104a87a4ae4dfe12ed9ceda31c29ec5eef168073a5c72fe8d1b22e75d7ecec07e104e6425724f80ad134c2a527f7e6120ffda25a692490f19fa46478eec72e528273cac7a45eb707a02afe6a78a1b9c441f955d67f6af8bc7abd6f33974d14db527f49cda4639ab9e391f1f3d81c93548a3d60f0a75ea5f63a4b40dd3e5fa9da708ba9b50a", "86f598db778b672acd3a6f96b98a9d83edb426170935091035e8cd0a9e851177eecc9efddb2dcaa219fc31962287d29c8247a6f5376c538c7cf8df0b54afd35d66d3b79c2d879c365fc44cf7916a1badd8a4f71aa26f509ebe216d91bc7f3a4c2a0b969f543142c13d040200b6bcccbed982824ea6b1bace1ff83f61611d58734dfa0ccde8ffb99712599078e8f4d9cda97d7f98518839edf457fdbf5094b3cf1bd4b072c5146833620f5d40041606f3401cbfa4c47f11a1237e1c1a0863c21a57e85233d342e9041362bcb8f003c521c16762e6ef03d9603b5d4e403542d82004fe56d59236e58547a6b2622184d76b9cebb0c12463950e0c69f2f97721b3712312ef66d35e656b48ef72308dc5a75a8075fe62f37b83d349d9fc13a7d1f419", "8cbb42092eb654dfdb46c99998ada223c6d94066351b708a2fa82133849bc919d8fa749902f4f47fb3d67e6756e57b5c901c41dea76b6e553c896255cad9971ea4a0519b2a2c23de27817e76cf4a5876b55a42ff4c8e185f79c9cd62ae0d1fd007de9077af820b05d5663817d5ac82053877a198b79c75ab52ed7fccf03318e81b7cec6e22bbe2012e0af9fd84abb565457f86a43988be8f0aef2aa42faeb9d9301121a83a8c4124cc132430aab22b8604915a1f06f1663a0587f25bfbb3bce121debad761a99098a9a99e46d4b265cf392e3f52282c2e0a2584f04c9dbac2d23fab68fd1b739b3023433d3837990df323705d946285f3eb207c77305676db9a", "927456513f1c72151504984084d680b3f9ea7ca37869e7a73fc36bf58475c0c1f789ce51287ce8943e5ee614b52d56ccacc67c0698e9234f3ada2468d00dd1e73a154793d44b377629a9576454b9115746c0f12f0b8a59217761794251adb3cd6adb0791eb21cff5ab72cd1d1587ade8c6857d7071bcb02a627b6f643e7eea73440e4051fdab9d5187b140c2686138cd48d0b24c4b0e9f75fc45bc6abe7e543f09c9bcbd19d1d0aaf6708409bfb0ae756b1e69a20aa68d4f7af92ff94f10f57f0505d926cbdbab43f5349b8fd5aca6e8e24e371d90d12652f2ab578ae89abe8c"];

    let mut proof_messages: Vec<ProofMessage> =
        messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

    let signature_with_header = get_expected_signature(EXPECTED_SIGNATURE);
    assert!(signature_with_header
        .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            Some(TEST_HEADER),
            &generators,
            &messages
        )
        .unwrap());

    let mut proof_values_with_header: Vec<String> = Vec::new();
    let mut proof_values_no_header: Vec<String> = Vec::new();
    for i in 0..proof_messages.len() {
        let signature_no_header =
            get_expected_signature(EXPECTED_SIGNATURE_NO_HEADER);
        assert!(signature_no_header
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                &generators,
                &messages
            )
            .unwrap());

        let mut revealed_messages = BTreeMap::new();
        for (j, proof_msg) in proof_messages.iter().take(i).enumerate() {
            revealed_messages.insert(j, proof_msg.get_message());
        }

        // Proof with header but no presentation header
        let proof_with_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_with_header,
            Some(TEST_HEADER),
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_with_header.to_octets(),
            hex::decode(expected_proof_with_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_with_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                Some(TEST_HEADER),
                None,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap());

        // Proof with no header and no presentation header
        let proof_no_header = Proof::new_with_rng::<
            _,
            _,
            _,
            Bls12381Shake256CipherSuiteParameter,
        >(
            &pk,
            &signature_no_header,
            None::<&[u8]>,
            None,
            &generators,
            &proof_messages,
            &mut rng,
        )
        .expect("proof generation failed");

        assert_eq!(
            proof_no_header.to_octets(),
            hex::decode(expected_proof_no_header[i])
                .expect("expected proof decoding failed")
        );
        assert!(proof_no_header
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                None::<&[u8]>,
                None,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap());

        proof_values_with_header
            .push(hex::encode(proof_with_header.to_octets()));
        proof_values_no_header.push(hex::encode(proof_no_header.to_octets()));

        proof_messages[i] = ProofMessage::Revealed(messages[i]);
    }
    // println!("proof values with header = {:?}", proof_values_with_header);
    // println!("proof values with no header = {:?}", proof_values_no_header);
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for (
        (key_pair, header, ph, mut generators, messages),
        failure_debug_message,
    ) in test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature =
            Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.secret_key,
                &key_pair.public_key,
                header,
                &generators,
                messages.clone(),
            )
            .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = BTreeSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            OsRng,
            failure_debug_message,
        );
        assert!(proof
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages,
                None
            )
            .unwrap_or_else(|_| panic!(
                "proof verification failed - {failure_debug_message}"
            )));

        for i in 0..messages.len() {
            let revealed_indices = (0..i)
                .collect::<Vec<usize>>()
                .iter()
                .cloned()
                .collect::<BTreeSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                OsRng,
                failure_debug_message,
            );
            assert!(proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &key_pair.public_key,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages,
                    None
                )
                .unwrap_or_else(|_| panic!(
                    "proof verification failed - {failure_debug_message}, \
                     revealed indices {revealed_indices:#?}"
                )));
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<BTreeSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages;
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<BTreeMap<usize, Message>>();

    assert!(proof_all_revealed_messages
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages_same_but_shuffled_indices,
            None
        )
        .expect("proof-verification should not fail"));
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());
    let indices_all_hidden = BTreeSet::<usize>::new();
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert!(!proof
        .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.public_key,
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        )
        .unwrap_or_else(|_| panic!("proof verification failed ")));

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &PublicKey::default(),
            header,
            ph,
            &mut generators,
            &revealed_messages,
            None
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                ph,
                &mut generators,
                &revealed_messages,
                None
            ),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            MemoryCachedGenerators<Bls12381Shake256CipherSuiteParameter>,
            BTreeMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert!(
            !proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages,
                    None
                )
                .unwrap_or_else(|_| panic!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        c,
        r2_hat,
        z_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_bar.to_affine().to_compressed().as_ref(),
        b_bar.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        z_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_bar = G1Projective::random(&mut OsRng);
    let b_bar = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let z_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_bar: a_bar,
        B_bar: b_bar,
        c,
        r2_hat,
        z_hat,
        m_hat_list,
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
