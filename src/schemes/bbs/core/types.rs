#![allow(non_snake_case)]
use crate::{
    bbs::ciphersuites::BbsCiphersuiteParameters,
    curves::{
        bls12_381::{Scalar, OCTET_POINT_G1_LENGTH, OCTET_SCALAR_LENGTH},
        point_serde::point_to_octets_g1,
        scalar_type::scalar_wrapper,
    },
    error::Error,
};
use blstrs::G1Projective;
use serde::{Deserialize, Serialize};
use subtle::CtOption;

scalar_wrapper!(
    /// A challenge generated by Fiat-Shamir heuristic.
    Challenge
);

scalar_wrapper!(
    /// A Proof generated by Fiat-Shamir heuristic.
    FiatShamirProof
);

scalar_wrapper!(
    /// A message to be signed.
    Message
);

impl Message {
    /// Generate a random `Message`.
    #[cfg(test)]
    pub fn random<R: rand_core::RngCore>(rng: &mut R) -> Self {
        use ff::Field;
        Self(Scalar::random(rng))
    }

    /// Map arbitrary data to `Message`.
    pub fn from_arbitrary_data<C>(
        message: &[u8],
        dst: Option<&[u8]>,
    ) -> Result<Self, Error>
    where
        C: BbsCiphersuiteParameters,
    {
        Ok(Self(C::map_message_to_scalar_as_hash(message, dst)?))
    }
}

/// A message classification by the prover.
#[derive(Copy, Clone, Debug)]
pub(crate) enum ProofMessage {
    /// Message will be revealed to a verifier.
    Revealed(Message),
    /// Message will be hidden from a verifier.
    Hidden(Message),
}

impl ProofMessage {
    /// Extract the internal message.
    pub fn get_message(&self) -> Message {
        match *self {
            ProofMessage::Revealed(r) => r,
            ProofMessage::Hidden(h) => h,
        }
    }
}

/// Result of proof generation and
/// verification initialization.
#[allow(non_snake_case)]
#[derive(Debug, Default)]
pub(crate) struct ProofInitResult {
    pub A_bar: G1Projective,
    pub B_bar: G1Projective,
    pub D: G1Projective,
    pub T1: G1Projective,
    pub T2: G1Projective,
    pub domain: Scalar,
}

/// Random Scalars used to blind the undisclosed messages and the hidden
/// signature value.
#[derive(Default, Debug, Clone)]
pub struct RandomScalars {
    /// The r1 random scalar
    pub r1: Scalar,
    /// The r2_tilde random scalar
    pub r2_tilde: Scalar,
    /// The z_tilde random scalar
    pub z_tilde: Scalar,
    /// The list of m~_i, where each m~ a random scalar
    pub m_tilde_scalars: Vec<Scalar>,
}

impl RandomScalars {
    pub(crate) fn insert_m_tilde(&mut self, m_tilde: Scalar) {
        self.m_tilde_scalars.push(m_tilde);
    }

    pub(crate) fn m_tilde_scalars_len(&self) -> usize {
        self.m_tilde_scalars.len()
    }
}

/// A struct to hold a trace of the signature generation operation
#[derive(Debug, Clone)]
pub struct SignatureTrace {
    /// The point B calculated during proof generation
    pub B: [u8; OCTET_POINT_G1_LENGTH],
    /// The domain scalar value calculated during proof generation
    pub domain: [u8; OCTET_SCALAR_LENGTH],
}

impl Default for SignatureTrace {
    fn default() -> Self {
        Self {
            B: [0u8; OCTET_POINT_G1_LENGTH],
            domain: [0u8; OCTET_SCALAR_LENGTH],
        }
    }
}

/// A struct to hold a trace of the proof generation operation
#[derive(Debug, Clone)]
pub struct ProofTrace {
    /// The random scalars used during proof generation
    pub random_scalars: RandomScalars,
    /// The point A_bar calculated during proof generation
    pub A_bar: [u8; OCTET_POINT_G1_LENGTH],
    /// The point B_bar calculated during proof generation
    pub B_bar: [u8; OCTET_POINT_G1_LENGTH],
    /// The point D calculated during proof generation
    pub D: [u8; OCTET_POINT_G1_LENGTH],
    /// The point T1 calculated during proof generation
    pub T1: [u8; OCTET_POINT_G1_LENGTH],
    /// The point T2 calculated during proof generation
    pub T2: [u8; OCTET_POINT_G1_LENGTH],
    /// The domain scalar value calculated during proof generation
    pub domain: [u8; OCTET_SCALAR_LENGTH],
    /// The challenge scalar value calculated during proof generation
    pub challenge: [u8; OCTET_SCALAR_LENGTH],
}

impl Default for ProofTrace {
    fn default() -> Self {
        Self {
            A_bar: [0u8; OCTET_POINT_G1_LENGTH],
            B_bar: [0u8; OCTET_POINT_G1_LENGTH],
            D: [0u8; OCTET_POINT_G1_LENGTH],
            T1: [0u8; OCTET_POINT_G1_LENGTH],
            T2: [0u8; OCTET_POINT_G1_LENGTH],
            domain: [0u8; OCTET_SCALAR_LENGTH],
            challenge: [0u8; OCTET_SCALAR_LENGTH],
            random_scalars: RandomScalars::default(),
        }
    }
}

impl ProofTrace {
    pub(crate) fn new_with_init_res(
        &mut self,
        init_res: &ProofInitResult,
        challenge: Challenge,
        random_scalars: RandomScalars,
    ) {
        self.A_bar = point_to_octets_g1(&init_res.A_bar);
        self.B_bar = point_to_octets_g1(&init_res.B_bar);
        self.D = point_to_octets_g1(&init_res.D);
        self.T1 = point_to_octets_g1(&init_res.T1);
        self.T2 = point_to_octets_g1(&init_res.T2);
        self.domain = init_res.domain.to_bytes_be();
        self.challenge = challenge.0.to_bytes_be();
        self.random_scalars = random_scalars;
    }
}
