use super::constants::OCTET_SCALAR_LENGTH;
use crate::{
    bbs::{
        ciphersuites::BbsCiphersuiteParameters,
        core::hash_utils::map_message_to_scalar_as_hash,
    },
    curves::bls12_381::Scalar,
    error::Error,
};
use serde::{Deserialize, Serialize};
use subtle::CtOption;

macro_rules! scalar_wrapper {
    ($(#[$docs:meta])*
     $name:ident) => {
        $(#[$docs])*
        #[derive(Debug, Copy, Clone, Eq, PartialEq, Deserialize, Serialize)]
        pub(crate) struct $name(pub Scalar);

        impl Default for $name {
            fn default() -> Self {
                use ff::Field;
                Self(Scalar::zero())
            }
        }

        impl $name {
            /// The number of bytes needed to represent this type.
            pub const SIZE_BYTES: usize = OCTET_SCALAR_LENGTH;

            /// Convert this type to a big-endian representation.
            pub fn to_bytes(self) -> [u8; Self::SIZE_BYTES] {
                self.0.to_bytes_be()
            }

            /// Convert a big-endian representation to this type.
            #[allow(dead_code)]
            pub fn from_bytes(bytes: &[u8; Self::SIZE_BYTES]) -> CtOption<Self> {
                Scalar::from_bytes_be(bytes).map($name)
            }

        }
    };
}

scalar_wrapper!(
    /// A challenge generated by Fiat-Shamir heuristic.
    Challenge
);

scalar_wrapper!(
    /// A Proof generated by Fiat-Shamir heuristic.
    FiatShamirProof
);

scalar_wrapper!(
    /// A message to be signed.
    Message
);

impl Message {
    /// Generate a random `Message`.
    #[cfg(test)]
    pub fn random<R: rand_core::RngCore>(rng: &mut R) -> Self {
        use ff::Field;
        Self(Scalar::random(rng))
    }

    /// Map arbitrary data to `Message`.
    pub fn from_arbitrary_data<C>(
        message: &[u8],
        dst: Option<&[u8]>,
    ) -> Result<Self, Error>
    where
        C: BbsCiphersuiteParameters<'static>,
    {
        Ok(Self(map_message_to_scalar_as_hash::<C>(message, dst)?))
    }
}

/// A message classification by the prover.
#[derive(Copy, Clone, Debug)]
pub(crate) enum ProofMessage {
    /// Message will be revealed to a verifier.
    Revealed(Message),
    /// Message will be hidden from a verifier.
    Hidden(Message),
}

impl ProofMessage {
    /// Extract the internal message.
    pub fn get_message(&self) -> Message {
        match *self {
            ProofMessage::Revealed(r) => r,
            ProofMessage::Hidden(h) => h,
        }
    }
}
